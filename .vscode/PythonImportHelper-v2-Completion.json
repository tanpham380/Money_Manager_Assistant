[
    {
        "label": "ast",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ast",
        "description": "ast",
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "contextlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "contextlib",
        "description": "contextlib",
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "fnmatch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "fnmatch",
        "description": "fnmatch",
        "detail": "fnmatch",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "environ",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "pipes",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pipes",
        "description": "pipes",
        "detail": "pipes",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "shlex",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shlex",
        "description": "shlex",
        "detail": "shlex",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "exit",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "platform",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "stdout",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "zipfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zipfile",
        "description": "zipfile",
        "detail": "zipfile",
        "documentation": {}
    },
    {
        "label": "ZipFile",
        "importPath": "zipfile",
        "description": "zipfile",
        "isExtraImport": true,
        "detail": "zipfile",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "optparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "optparse",
        "description": "optparse",
        "detail": "optparse",
        "documentation": {}
    },
    {
        "label": "OptionParser",
        "importPath": "optparse",
        "description": "optparse",
        "isExtraImport": true,
        "detail": "optparse",
        "documentation": {}
    },
    {
        "label": "build_utils",
        "importPath": "util",
        "description": "util",
        "isExtraImport": true,
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "build_utils",
        "importPath": "util",
        "description": "util",
        "isExtraImport": true,
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "md5_check",
        "importPath": "util",
        "description": "util",
        "isExtraImport": true,
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "ansi_colors",
        "importPath": "util",
        "description": "util",
        "isExtraImport": true,
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "build_utils",
        "importPath": "util",
        "description": "util",
        "isExtraImport": true,
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "md5_check",
        "importPath": "util",
        "description": "util",
        "isExtraImport": true,
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "textwrap",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "textwrap",
        "description": "textwrap",
        "detail": "textwrap",
        "documentation": {}
    },
    {
        "label": "jar",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "jar",
        "description": "jar",
        "detail": "jar",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "errno",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "errno",
        "description": "errno",
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "struct",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "struct",
        "description": "struct",
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "symlink",
        "importPath": "pyutil.file_util",
        "description": "pyutil.file_util",
        "isExtraImport": true,
        "detail": "pyutil.file_util",
        "documentation": {}
    },
    {
        "label": "plistlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "plistlib",
        "description": "plistlib",
        "detail": "plistlib",
        "documentation": {}
    },
    {
        "label": "uuid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uuid",
        "description": "uuid",
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "collections",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections",
        "description": "collections",
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "multiprocessing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "gn_helpers",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gn_helpers",
        "description": "gn_helpers",
        "detail": "gn_helpers",
        "documentation": {}
    },
    {
        "label": "ToGNString",
        "importPath": "gn_helpers",
        "description": "gn_helpers",
        "isExtraImport": true,
        "detail": "gn_helpers",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "stat",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "stat",
        "description": "stat",
        "detail": "stat",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "groupby",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "wrapper_utils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "wrapper_utils",
        "description": "wrapper_utils",
        "detail": "wrapper_utils",
        "documentation": {}
    },
    {
        "label": "gzip",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gzip",
        "description": "gzip",
        "detail": "gzip",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "os.path",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.path",
        "description": "os.path",
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "breakpad",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "breakpad",
        "description": "breakpad",
        "detail": "breakpad",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "git_revision",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "git_revision",
        "description": "git_revision",
        "detail": "git_revision",
        "documentation": {}
    },
    {
        "label": "byte_str_decode",
        "importPath": "compatibility_helper",
        "description": "compatibility_helper",
        "isExtraImport": true,
        "detail": "compatibility_helper",
        "documentation": {}
    },
    {
        "label": "difflib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "difflib",
        "description": "difflib",
        "detail": "difflib",
        "documentation": {}
    },
    {
        "label": "'dart:async';",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "'dart:async';",
        "description": "'dart:async';",
        "detail": "'dart:async';",
        "documentation": {}
    },
    {
        "label": "'package:flutter_driver/driver_extension.dart';",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "'package:flutter_driver.driver_extension.dart';",
        "description": "'package:flutter_driver.driver_extension.dart';",
        "detail": "'package:flutter_driver.driver_extension.dart';",
        "documentation": {}
    },
    {
        "label": "create_xcframework",
        "importPath": "create_xcframework",
        "description": "create_xcframework",
        "isExtraImport": true,
        "detail": "create_xcframework",
        "documentation": {}
    },
    {
        "label": "create_xcframework",
        "importPath": "create_xcframework",
        "description": "create_xcframework",
        "isExtraImport": true,
        "detail": "create_xcframework",
        "documentation": {}
    },
    {
        "label": "sky_utils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sky_utils",
        "description": "sky_utils",
        "detail": "sky_utils",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "PdfPages",
        "importPath": "matplotlib.backends.backend_pdf",
        "description": "matplotlib.backends.backend_pdf",
        "isExtraImport": true,
        "detail": "matplotlib.backends.backend_pdf",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "typing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "typing",
        "description": "typing",
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "yaml",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yaml",
        "description": "yaml",
        "detail": "yaml",
        "documentation": {}
    },
    {
        "label": "run_tests",
        "importPath": "bundled_test_runner",
        "description": "bundled_test_runner",
        "isExtraImport": true,
        "detail": "bundled_test_runner",
        "documentation": {}
    },
    {
        "label": "TestCase",
        "importPath": "bundled_test_runner",
        "description": "bundled_test_runner",
        "isExtraImport": true,
        "detail": "bundled_test_runner",
        "documentation": {}
    },
    {
        "label": "DIR_SRC_ROOT",
        "importPath": "common",
        "description": "common",
        "isExtraImport": true,
        "detail": "common",
        "documentation": {}
    },
    {
        "label": "catch_sigterm",
        "importPath": "common",
        "description": "common",
        "isExtraImport": true,
        "detail": "common",
        "documentation": {}
    },
    {
        "label": "wait_for_sigterm",
        "importPath": "common",
        "description": "common",
        "isExtraImport": true,
        "detail": "common",
        "documentation": {}
    },
    {
        "label": "force_running_unattended",
        "importPath": "compatible_utils",
        "description": "compatible_utils",
        "isExtraImport": true,
        "detail": "compatible_utils",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "pathlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pathlib",
        "description": "pathlib",
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "run_tests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "run_tests",
        "description": "run_tests",
        "detail": "run_tests",
        "documentation": {}
    },
    {
        "label": "logging.handlers",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging.handlers",
        "description": "logging.handlers",
        "detail": "logging.handlers",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "xvfb",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xvfb",
        "description": "xvfb",
        "detail": "xvfb",
        "documentation": {}
    },
    {
        "label": "signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal",
        "description": "signal",
        "detail": "signal",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "filecmp",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "filecmp",
        "description": "filecmp",
        "detail": "filecmp",
        "documentation": {}
    },
    {
        "label": "get_content_hash",
        "importPath": "get_content_hash",
        "description": "get_content_hash",
        "isExtraImport": true,
        "detail": "get_content_hash",
        "documentation": {}
    },
    {
        "label": "get_content_hash",
        "importPath": "get_content_hash",
        "description": "get_content_hash",
        "isExtraImport": true,
        "detail": "get_content_hash",
        "documentation": {}
    },
    {
        "label": "build_fuchsia_artifacts",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "build_fuchsia_artifacts",
        "description": "build_fuchsia_artifacts",
        "detail": "build_fuchsia_artifacts",
        "documentation": {}
    },
    {
        "label": "tarfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tarfile",
        "description": "tarfile",
        "detail": "tarfile",
        "documentation": {}
    },
    {
        "label": "sys,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys.",
        "description": "sys.",
        "detail": "sys.",
        "documentation": {}
    },
    {
        "label": "itemgetter",
        "importPath": "operator",
        "description": "operator",
        "isExtraImport": true,
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "unicodedata",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unicodedata",
        "description": "unicodedata",
        "detail": "unicodedata",
        "documentation": {}
    },
    {
        "label": "fontforge",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "fontforge",
        "description": "fontforge",
        "detail": "fontforge",
        "documentation": {}
    },
    {
        "label": "imp",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "imp",
        "description": "imp",
        "detail": "imp",
        "documentation": {}
    },
    {
        "label": "FOREGROUND_YELLOW",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.ansi_colors",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.ansi_colors",
        "peekOfCode": "FOREGROUND_YELLOW = '\\x1b[33m'\nFOREGROUND_MAGENTA = '\\x1b[35m'\nFOREGROUND_BLUE = '\\x1b[34m'\nFOREGROUND_RESET = '\\x1b[39m'\nSTYLE_RESET_ALL = '\\x1b[0m'\nSTYLE_DIM = '\\x1b[2m'\nSTYLE_BRIGHT = '\\x1b[1m'",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.ansi_colors",
        "documentation": {}
    },
    {
        "label": "FOREGROUND_MAGENTA",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.ansi_colors",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.ansi_colors",
        "peekOfCode": "FOREGROUND_MAGENTA = '\\x1b[35m'\nFOREGROUND_BLUE = '\\x1b[34m'\nFOREGROUND_RESET = '\\x1b[39m'\nSTYLE_RESET_ALL = '\\x1b[0m'\nSTYLE_DIM = '\\x1b[2m'\nSTYLE_BRIGHT = '\\x1b[1m'",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.ansi_colors",
        "documentation": {}
    },
    {
        "label": "FOREGROUND_BLUE",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.ansi_colors",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.ansi_colors",
        "peekOfCode": "FOREGROUND_BLUE = '\\x1b[34m'\nFOREGROUND_RESET = '\\x1b[39m'\nSTYLE_RESET_ALL = '\\x1b[0m'\nSTYLE_DIM = '\\x1b[2m'\nSTYLE_BRIGHT = '\\x1b[1m'",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.ansi_colors",
        "documentation": {}
    },
    {
        "label": "FOREGROUND_RESET",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.ansi_colors",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.ansi_colors",
        "peekOfCode": "FOREGROUND_RESET = '\\x1b[39m'\nSTYLE_RESET_ALL = '\\x1b[0m'\nSTYLE_DIM = '\\x1b[2m'\nSTYLE_BRIGHT = '\\x1b[1m'",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.ansi_colors",
        "documentation": {}
    },
    {
        "label": "STYLE_RESET_ALL",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.ansi_colors",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.ansi_colors",
        "peekOfCode": "STYLE_RESET_ALL = '\\x1b[0m'\nSTYLE_DIM = '\\x1b[2m'\nSTYLE_BRIGHT = '\\x1b[1m'",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.ansi_colors",
        "documentation": {}
    },
    {
        "label": "STYLE_DIM",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.ansi_colors",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.ansi_colors",
        "peekOfCode": "STYLE_DIM = '\\x1b[2m'\nSTYLE_BRIGHT = '\\x1b[1m'",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.ansi_colors",
        "documentation": {}
    },
    {
        "label": "STYLE_BRIGHT",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.ansi_colors",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.ansi_colors",
        "peekOfCode": "STYLE_BRIGHT = '\\x1b[1m'",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.ansi_colors",
        "documentation": {}
    },
    {
        "label": "CalledProcessError",
        "kind": 6,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "class CalledProcessError(Exception):\n  \"\"\"This exception is raised when the process run by CheckOutput\n  exits with a non-zero exit code.\"\"\"\n  def __init__(self, cwd, args, output):\n    super(CalledProcessError, self).__init__()\n    self.cwd = cwd\n    self.args = args\n    self.output = output\n  def __str__(self):\n    # A user should be able to simply copy and paste the command that failed",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "TempDir",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "def TempDir():\n  dirname = tempfile.mkdtemp()\n  try:\n    yield dirname\n  finally:\n    shutil.rmtree(dirname)\ndef MakeDirectory(dir_path):\n  try:\n    os.makedirs(dir_path)\n  except OSError:",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "MakeDirectory",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "def MakeDirectory(dir_path):\n  try:\n    os.makedirs(dir_path)\n  except OSError:\n    pass\ndef DeleteDirectory(dir_path):\n  if os.path.exists(dir_path):\n    shutil.rmtree(dir_path)\ndef Touch(path, fail_if_missing=False):\n  if fail_if_missing and not os.path.exists(path):",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "DeleteDirectory",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "def DeleteDirectory(dir_path):\n  if os.path.exists(dir_path):\n    shutil.rmtree(dir_path)\ndef Touch(path, fail_if_missing=False):\n  if fail_if_missing and not os.path.exists(path):\n    raise Exception(path + ' doesn\\'t exist.')\n  MakeDirectory(os.path.dirname(path))\n  with open(path, 'a'):\n    os.utime(path, None)\ndef FindInDirectory(directory, filename_filter):",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "Touch",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "def Touch(path, fail_if_missing=False):\n  if fail_if_missing and not os.path.exists(path):\n    raise Exception(path + ' doesn\\'t exist.')\n  MakeDirectory(os.path.dirname(path))\n  with open(path, 'a'):\n    os.utime(path, None)\ndef FindInDirectory(directory, filename_filter):\n  files = []\n  for root, _dirnames, filenames in os.walk(directory):\n    matched_files = fnmatch.filter(filenames, filename_filter)",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "FindInDirectory",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "def FindInDirectory(directory, filename_filter):\n  files = []\n  for root, _dirnames, filenames in os.walk(directory):\n    matched_files = fnmatch.filter(filenames, filename_filter)\n    files.extend((os.path.join(root, f) for f in matched_files))\n  return files\ndef FindInDirectories(directories, filename_filter):\n  all_files = []\n  for directory in directories:\n    all_files.extend(FindInDirectory(directory, filename_filter))",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "FindInDirectories",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "def FindInDirectories(directories, filename_filter):\n  all_files = []\n  for directory in directories:\n    all_files.extend(FindInDirectory(directory, filename_filter))\n  return all_files\ndef ParseGnList(gn_string):\n  return ast.literal_eval(gn_string)\ndef ParseGypList(gyp_string):\n  # The ninja generator doesn't support $ in strings, so use ## to\n  # represent $.",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "ParseGnList",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "def ParseGnList(gn_string):\n  return ast.literal_eval(gn_string)\ndef ParseGypList(gyp_string):\n  # The ninja generator doesn't support $ in strings, so use ## to\n  # represent $.\n  # TODO(cjhopman): Remove when\n  # https://code.google.com/p/gyp/issues/detail?id=327\n  # is addressed.\n  gyp_string = gyp_string.replace('##', '$')\n  if gyp_string.startswith('['):",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "ParseGypList",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "def ParseGypList(gyp_string):\n  # The ninja generator doesn't support $ in strings, so use ## to\n  # represent $.\n  # TODO(cjhopman): Remove when\n  # https://code.google.com/p/gyp/issues/detail?id=327\n  # is addressed.\n  gyp_string = gyp_string.replace('##', '$')\n  if gyp_string.startswith('['):\n    return ParseGnList(gyp_string)\n  return shlex.split(gyp_string)",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "CheckOptions",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "def CheckOptions(options, parser, required=None):\n  if not required:\n    return\n  for option_name in required:\n    if getattr(options, option_name) is None:\n      parser.error('--%s is required' % option_name.replace('_', '-'))\ndef WriteJson(obj, path, only_if_changed=False):\n  old_dump = None\n  if os.path.exists(path):\n    with open(path, 'r') as oldfile:",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "WriteJson",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "def WriteJson(obj, path, only_if_changed=False):\n  old_dump = None\n  if os.path.exists(path):\n    with open(path, 'r') as oldfile:\n      old_dump = oldfile.read()\n  new_dump = json.dumps(obj, sort_keys=True, indent=2, separators=(',', ': '))\n  if not only_if_changed or old_dump != new_dump:\n    with open(path, 'w') as outfile:\n      outfile.write(new_dump)\ndef ReadJson(path):",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "ReadJson",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "def ReadJson(path):\n  with open(path, 'r') as jsonfile:\n    return json.load(jsonfile)\nclass CalledProcessError(Exception):\n  \"\"\"This exception is raised when the process run by CheckOutput\n  exits with a non-zero exit code.\"\"\"\n  def __init__(self, cwd, args, output):\n    super(CalledProcessError, self).__init__()\n    self.cwd = cwd\n    self.args = args",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "CheckOutput",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "def CheckOutput(args, cwd=None,\n                print_stdout=False, print_stderr=True,\n                stdout_filter=None,\n                stderr_filter=None,\n                universal_newlines=True,\n                fail_func=lambda returncode, stderr: returncode != 0):\n  if not cwd:\n    cwd = os.getcwd()\n  child = subprocess.Popen(args,\n      universal_newlines=universal_newlines,",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "GetModifiedTime",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "def GetModifiedTime(path):\n  # For a symlink, the modified time should be the greater of the link's\n  # modified time and the modified time of the target.\n  return max(os.lstat(path).st_mtime, os.stat(path).st_mtime)\ndef IsTimeStale(output, inputs):\n  if not os.path.exists(output):\n    return True\n  output_time = GetModifiedTime(output)\n  for i in inputs:\n    if GetModifiedTime(i) > output_time:",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "IsTimeStale",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "def IsTimeStale(output, inputs):\n  if not os.path.exists(output):\n    return True\n  output_time = GetModifiedTime(output)\n  for i in inputs:\n    if GetModifiedTime(i) > output_time:\n      return True\n  return False\ndef IsDeviceReady():\n  device_state = CheckOutput(['adb', 'get-state'])",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "IsDeviceReady",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "def IsDeviceReady():\n  device_state = CheckOutput(['adb', 'get-state'])\n  return device_state.strip() == 'device'\ndef CheckZipPath(name):\n  if os.path.normpath(name) != name:\n    raise Exception('Non-canonical zip path: %s' % name)\n  if os.path.isabs(name):\n    raise Exception('Absolute zip path: %s' % name)\ndef ExtractAll(zip_path, path=None, no_clobber=True, pattern=None):\n  if path is None:",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "CheckZipPath",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "def CheckZipPath(name):\n  if os.path.normpath(name) != name:\n    raise Exception('Non-canonical zip path: %s' % name)\n  if os.path.isabs(name):\n    raise Exception('Absolute zip path: %s' % name)\ndef ExtractAll(zip_path, path=None, no_clobber=True, pattern=None):\n  if path is None:\n    path = os.getcwd()\n  elif not os.path.exists(path):\n    MakeDirectory(path)",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "ExtractAll",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "def ExtractAll(zip_path, path=None, no_clobber=True, pattern=None):\n  if path is None:\n    path = os.getcwd()\n  elif not os.path.exists(path):\n    MakeDirectory(path)\n  with zipfile.ZipFile(zip_path) as z:\n    for name in z.namelist():\n      if name.endswith('/'):\n        continue\n      if pattern is not None:",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "DoZip",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "def DoZip(inputs, output, base_dir):\n  with zipfile.ZipFile(output, 'w') as outfile:\n    for f in inputs:\n      CheckZipPath(os.path.relpath(f, base_dir))\n      outfile.write(f, os.path.relpath(f, base_dir))\ndef ZipDir(output, base_dir):\n  with zipfile.ZipFile(output, 'w') as outfile:\n    for root, _, files in os.walk(base_dir):\n      for f in files:\n        path = os.path.join(root, f)",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "ZipDir",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "def ZipDir(output, base_dir):\n  with zipfile.ZipFile(output, 'w') as outfile:\n    for root, _, files in os.walk(base_dir):\n      for f in files:\n        path = os.path.join(root, f)\n        archive_path = os.path.relpath(path, base_dir)\n        CheckZipPath(archive_path)\n        outfile.write(path, archive_path)\ndef MergeZips(output, inputs, exclude_patterns=None):\n  added_names = set()",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "MergeZips",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "def MergeZips(output, inputs, exclude_patterns=None):\n  added_names = set()\n  def Allow(name):\n    if exclude_patterns is not None:\n      for p in exclude_patterns:\n        if fnmatch.fnmatch(name, p):\n          return False\n    return True\n  with zipfile.ZipFile(output, 'w') as out_zip:\n    for in_file in inputs:",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "PrintWarning",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "def PrintWarning(message):\n  print('WARNING: %s' % message)\ndef PrintBigWarning(message):\n  print('*****     ' * 8)\n  PrintWarning(message)\n  print('*****     ' * 8)\ndef GetSortedTransitiveDependencies(top, deps_func):\n  \"\"\"Gets the list of all transitive dependencies in sorted order.\n  There should be no cycles in the dependency graph.\n  Args:",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "PrintBigWarning",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "def PrintBigWarning(message):\n  print('*****     ' * 8)\n  PrintWarning(message)\n  print('*****     ' * 8)\ndef GetSortedTransitiveDependencies(top, deps_func):\n  \"\"\"Gets the list of all transitive dependencies in sorted order.\n  There should be no cycles in the dependency graph.\n  Args:\n    top: a list of the top level nodes\n    deps_func: A function that takes a node and returns its direct dependencies.",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "GetSortedTransitiveDependencies",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "def GetSortedTransitiveDependencies(top, deps_func):\n  \"\"\"Gets the list of all transitive dependencies in sorted order.\n  There should be no cycles in the dependency graph.\n  Args:\n    top: a list of the top level nodes\n    deps_func: A function that takes a node and returns its direct dependencies.\n  Returns:\n    A list of all transitive dependencies of nodes in top, in order (a node will\n    appear in the list at a higher index than all of its dependencies).\n  \"\"\"",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "GetPythonDependencies",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "def GetPythonDependencies():\n  \"\"\"Gets the paths of imported non-system python modules.\n  A path is assumed to be a \"system\" import if it is outside of chromium's\n  src/. The paths will be relative to the current directory.\n  \"\"\"\n  _ForceLazyModulesToLoad()\n  module_paths = (m.__file__ for m in sys.modules.values()\n                  if m is not None and hasattr(m, '__file__'))\n  abs_module_paths = map(os.path.abspath, filter(lambda p: p is not None, module_paths))\n  assert os.path.isabs(DIR_SOURCE_ROOT)",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "AddDepfileOption",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "def AddDepfileOption(parser):\n  parser.add_option('--depfile',\n                    help='Path to depfile. This must be specified as the '\n                    'action\\'s first output.')\ndef WriteDepfile(path, dependencies):\n  with open(path, 'w') as depfile:\n    depfile.write(path)\n    depfile.write(': ')\n    depfile.write(' '.join(dependencies))\n    depfile.write('\\n')",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "WriteDepfile",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "def WriteDepfile(path, dependencies):\n  with open(path, 'w') as depfile:\n    depfile.write(path)\n    depfile.write(': ')\n    depfile.write(' '.join(dependencies))\n    depfile.write('\\n')\ndef ExpandFileArgs(args):\n  \"\"\"Replaces file-arg placeholders in args.\n  These placeholders have the form:\n    @FileArg(filename:key1:key2:...:keyn)",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "ExpandFileArgs",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "def ExpandFileArgs(args):\n  \"\"\"Replaces file-arg placeholders in args.\n  These placeholders have the form:\n    @FileArg(filename:key1:key2:...:keyn)\n  The value of such a placeholder is calculated by reading 'filename' as json.\n  And then extracting the value at [key1][key2]...[keyn].\n  Note: This intentionally does not return the list of files that appear in such\n  placeholders. An action that uses file-args *must* know the paths of those\n  files prior to the parsing of the arguments (typically by explicitly listing\n  them in the action's inputs in build files).",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "DIR_SOURCE_ROOT",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "DIR_SOURCE_ROOT = os.environ.get('CHECKOUT_SOURCE_ROOT',\n    os.path.abspath(os.path.join(os.path.dirname(__file__),\n                                 os.pardir, os.pardir, os.pardir, os.pardir)))\n# aapt should ignore OWNERS files in addition the default ignore pattern.\nAAPT_IGNORE_PATTERN = ('!OWNERS:!.svn:!.git:!.ds_store:!*.scc:.*:<dir>_*:' +\n                       '!CVS:!thumbs.db:!picasa.ini:!*~:!*.d.stamp')\n@contextlib.contextmanager\ndef TempDir():\n  dirname = tempfile.mkdtemp()\n  try:",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "AAPT_IGNORE_PATTERN",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "peekOfCode": "AAPT_IGNORE_PATTERN = ('!OWNERS:!.svn:!.git:!.ds_store:!*.scc:.*:<dir>_*:' +\n                       '!CVS:!thumbs.db:!picasa.ini:!*~:!*.d.stamp')\n@contextlib.contextmanager\ndef TempDir():\n  dirname = tempfile.mkdtemp()\n  try:\n    yield dirname\n  finally:\n    shutil.rmtree(dirname)\ndef MakeDirectory(dir_path):",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.build_utils",
        "documentation": {}
    },
    {
        "label": "_Md5Checker",
        "kind": 6,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.md5_check",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.md5_check",
        "peekOfCode": "class _Md5Checker(object):\n  def __init__(self, record_path=None, input_paths=None, input_strings=None):\n    if not input_paths:\n      input_paths = []\n    if not input_strings:\n      input_strings = []\n    assert record_path.endswith('.stamp'), (\n        'record paths must end in \\'.stamp\\' so that they are easy to find '\n        'and delete')\n    self.record_path = record_path",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.md5_check",
        "documentation": {}
    },
    {
        "label": "CallAndRecordIfStale",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.md5_check",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.md5_check",
        "peekOfCode": "def CallAndRecordIfStale(\n    function, record_path=None, input_paths=None, input_strings=None,\n    force=False):\n  \"\"\"Calls function if the md5sum of the input paths/strings has changed.\n  The md5sum of the inputs is compared with the one stored in record_path. If\n  this has changed (or the record doesn't exist), function will be called and\n  the new md5sum will be recorded.\n  If force is True, the function will be called regardless of whether the\n  md5sum is out of date.\n  \"\"\"",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.util.md5_check",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.create_flutter_jar",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.create_flutter_jar",
        "peekOfCode": "def main(args):\n  args = build_utils.ExpandFileArgs(args)\n  parser = optparse.OptionParser()\n  build_utils.AddDepfileOption(parser)\n  parser.add_option('--output', help='Path to output jar.')\n  parser.add_option('--output_native_jar', help='Path to output native library jar.')\n  parser.add_option('--dist_jar', help='Flutter shell Java code jar.')\n  parser.add_option('--native_lib', action='append', help='Native code library.')\n  parser.add_option('--android_abi', help='Native code ABI.')\n  parser.add_option('--asset_dir', help='Path to assets.')",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.create_flutter_jar",
        "documentation": {}
    },
    {
        "label": "Jar",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.jar",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.jar",
        "peekOfCode": "def Jar(class_files, classes_dir, jar_path, jar_bin, manifest_file=None, additional_jar_files=None):\n  jar_path = os.path.abspath(jar_path)\n  # The paths of the files in the jar will be the same as they are passed in to\n  # the command. Because of this, the command should be run in\n  # options.classes_dir so the .class file paths in the jar are correct.\n  jar_cwd = classes_dir\n  class_files_rel = [os.path.relpath(f, jar_cwd) for f in class_files]\n  jar_cmd = [jar_bin, 'cf0', jar_path]\n  if manifest_file:\n    jar_cmd[1] += 'm'",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.jar",
        "documentation": {}
    },
    {
        "label": "JarDirectory",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.jar",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.jar",
        "peekOfCode": "def JarDirectory(classes_dir, excluded_classes, jar_path, jar_bin, manifest_file=None, additional_jar_files=None):\n  class_files = build_utils.FindInDirectory(classes_dir, '*.class')\n  for exclude in excluded_classes:\n    class_files = [f for f in class_files if not fnmatch.fnmatch(f, exclude)]\n  Jar(class_files, classes_dir, jar_path, jar_bin, manifest_file=manifest_file,\n      additional_jar_files=additional_jar_files)\ndef main():\n  parser = optparse.OptionParser()\n  parser.add_option('--classes-dir', help='Directory containing .class files.')\n  parser.add_option('--jar-path', help='Jar output path.')",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.jar",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.jar",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.jar",
        "peekOfCode": "def main():\n  parser = optparse.OptionParser()\n  parser.add_option('--classes-dir', help='Directory containing .class files.')\n  parser.add_option('--jar-path', help='Jar output path.')\n  parser.add_option('--excluded-classes',\n      help='List of .class file patterns to exclude from the jar.')\n  parser.add_option('--stamp', help='Path to touch on success.')\n  parser.add_option(\n      '--jar-bin',\n      default='jar',",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.jar",
        "documentation": {}
    },
    {
        "label": "ColorJavacOutput",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.javac",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.javac",
        "peekOfCode": "def ColorJavacOutput(output):\n  fileline_prefix = r'(?P<fileline>(?P<file>[-.\\w/\\\\]+.java):(?P<line>[0-9]+):)'\n  warning_re = re.compile(\n      fileline_prefix + r'(?P<full_message> warning: (?P<message>.*))$')\n  error_re = re.compile(\n      fileline_prefix + r'(?P<full_message> (?P<message>.*))$')\n  marker_re = re.compile(r'\\s*(?P<marker>\\^)\\s*$')\n  warning_color = ['full_message', ansi_colors.FOREGROUND_YELLOW + ansi_colors.STYLE_DIM]\n  error_color = ['full_message', ansi_colors.FOREGROUND_MAGENTA + ansi_colors.STYLE_BRIGHT]\n  marker_color = ['marker',  ansi_colors.FOREGROUND_BLUE + ansi_colors.STYLE_BRIGHT]",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.javac",
        "documentation": {}
    },
    {
        "label": "DoJavac",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.javac",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.javac",
        "peekOfCode": "def DoJavac(\n    bootclasspath, classpath, classes_dir, chromium_code,\n    javac_bin, java_version, java_files):\n  \"\"\"Runs javac.\n  Builds |java_files| with the provided |classpath| and puts the generated\n  .class files into |classes_dir|. If |chromium_code| is true, extra lint\n  checking will be enabled.\n  \"\"\"\n  jar_inputs = []\n  for path in classpath:",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.javac",
        "documentation": {}
    },
    {
        "label": "CreateManifest",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.javac",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.javac",
        "peekOfCode": "def CreateManifest(manifest_path, classpath, main_class=None,\n                   manifest_entries=None):\n  \"\"\"Creates a manifest file with the given parameters.\n  This generates a manifest file that compiles with the spec found at\n  http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#JAR_Manifest\n  Args:\n    manifest_path: The path to the manifest file that should be created.\n    classpath: The JAR files that should be listed on the manifest file's\n      classpath.\n    main_class: If present, the class containing the main() function.",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.javac",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.javac",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.javac",
        "peekOfCode": "def main(argv):\n  argv = build_utils.ExpandFileArgs(argv)\n  parser = optparse.OptionParser()\n  build_utils.AddDepfileOption(parser)\n  parser.add_option(\n      '--src-gendirs',\n      help='Directories containing generated java files.')\n  parser.add_option(\n      '--java-srcjars',\n      action='append',",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.javac",
        "documentation": {}
    },
    {
        "label": "_MAX_MANIFEST_LINE_LEN",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.android.gyp.javac",
        "description": ".fvm.flutter_sdk.engine.src.build.android.gyp.javac",
        "peekOfCode": "_MAX_MANIFEST_LINE_LEN = 72\ndef CreateManifest(manifest_path, classpath, main_class=None,\n                   manifest_entries=None):\n  \"\"\"Creates a manifest file with the given parameters.\n  This generates a manifest file that compiles with the spec found at\n  http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#JAR_Manifest\n  Args:\n    manifest_path: The path to the manifest file that should be created.\n    classpath: The JAR files that should be listed on the manifest file's\n      classpath.",
        "detail": ".fvm.flutter_sdk.engine.src.build.android.gyp.javac",
        "documentation": {}
    },
    {
        "label": "SetConfigPath",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.config.linux.pkg-config",
        "description": ".fvm.flutter_sdk.engine.src.build.config.linux.pkg-config",
        "peekOfCode": "def SetConfigPath(options):\n  \"\"\"Set the PKG_CONFIG_LIBDIR environment variable.\n  This takes into account any sysroot and architecture specification from the\n  options on the given command line.\n  \"\"\"\n  sysroot = options.sysroot\n  assert sysroot\n  # Compute the library path name based on the architecture.\n  arch = options.arch\n  if sysroot and not arch:",
        "detail": ".fvm.flutter_sdk.engine.src.build.config.linux.pkg-config",
        "documentation": {}
    },
    {
        "label": "GetPkgConfigPrefixToStrip",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.config.linux.pkg-config",
        "description": ".fvm.flutter_sdk.engine.src.build.config.linux.pkg-config",
        "peekOfCode": "def GetPkgConfigPrefixToStrip(options, args):\n  \"\"\"Returns the prefix from pkg-config where packages are installed.\n  This returned prefix is the one that should be stripped from the beginning of\n  directory names to take into account sysroots.\n  \"\"\"\n  # Some sysroots, like the Chromium OS ones, may generate paths that are not\n  # relative to the sysroot. For example,\n  # /path/to/chroot/build/x86-generic/usr/lib/pkgconfig/pkg.pc may have all\n  # paths relative to /path/to/chroot (i.e. prefix=/build/x86-generic/usr)\n  # instead of relative to /path/to/chroot/build/x86-generic (i.e prefix=/usr).",
        "detail": ".fvm.flutter_sdk.engine.src.build.config.linux.pkg-config",
        "documentation": {}
    },
    {
        "label": "MatchesAnyRegexp",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.config.linux.pkg-config",
        "description": ".fvm.flutter_sdk.engine.src.build.config.linux.pkg-config",
        "peekOfCode": "def MatchesAnyRegexp(flag, list_of_regexps):\n  \"\"\"Returns true if the first argument matches any regular expression in the\n  given list.\"\"\"\n  for regexp in list_of_regexps:\n    if regexp.search(flag) != None:\n      return True\n  return False\ndef RewritePath(path, strip_prefix, sysroot):\n  \"\"\"Rewrites a path by stripping the prefix and prepending the sysroot.\"\"\"\n  if os.path.isabs(path) and not path.startswith(sysroot):",
        "detail": ".fvm.flutter_sdk.engine.src.build.config.linux.pkg-config",
        "documentation": {}
    },
    {
        "label": "RewritePath",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.config.linux.pkg-config",
        "description": ".fvm.flutter_sdk.engine.src.build.config.linux.pkg-config",
        "peekOfCode": "def RewritePath(path, strip_prefix, sysroot):\n  \"\"\"Rewrites a path by stripping the prefix and prepending the sysroot.\"\"\"\n  if os.path.isabs(path) and not path.startswith(sysroot):\n    if path.startswith(strip_prefix):\n      path = path[len(strip_prefix):]\n    path = path.lstrip('/')\n    return os.path.join(sysroot, path)\n  else:\n    return path\ndef main():",
        "detail": ".fvm.flutter_sdk.engine.src.build.config.linux.pkg-config",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.config.linux.pkg-config",
        "description": ".fvm.flutter_sdk.engine.src.build.config.linux.pkg-config",
        "peekOfCode": "def main():\n  # If this is run on non-Linux platforms, just return nothing and indicate\n  # success. This allows us to \"kind of emulate\" a Linux build from other\n  # platforms.\n  if \"linux\" not in sys.platform:\n    print(\"[[],[],[],[],[]]\")\n    return 0\n  parser = OptionParser()\n  parser.add_option('-d', '--debug', action='store_true')\n  parser.add_option('-p', action='store', dest='pkg_config', type='string',",
        "detail": ".fvm.flutter_sdk.engine.src.build.config.linux.pkg-config",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.config.linux.sysroot_ld_path",
        "description": ".fvm.flutter_sdk.engine.src.build.config.linux.sysroot_ld_path",
        "peekOfCode": "result = subprocess.check_output([sys.argv[1], sys.argv[2]],\n                                 universal_newlines=True).strip()\nprint('\"%s\"' % result)",
        "detail": ".fvm.flutter_sdk.engine.src.build.config.linux.sysroot_ld_path",
        "documentation": {}
    },
    {
        "label": "MakeDirectories",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.config.mac.mac_app",
        "description": ".fvm.flutter_sdk.engine.src.build.config.mac.mac_app",
        "peekOfCode": "def MakeDirectories(path):\n  try:\n    os.makedirs(path)\n  except OSError as exc:\n    if exc.errno == errno.EEXIST and os.path.isdir(path):\n      return 0\n    else:\n      return -1\n  return 0\ndef ProcessInfoPlist(args):",
        "detail": ".fvm.flutter_sdk.engine.src.build.config.mac.mac_app",
        "documentation": {}
    },
    {
        "label": "ProcessInfoPlist",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.config.mac.mac_app",
        "description": ".fvm.flutter_sdk.engine.src.build.config.mac.mac_app",
        "peekOfCode": "def ProcessInfoPlist(args):\n  output_plist_file = os.path.abspath(os.path.join(args.output, 'Info.plist'))\n  return subprocess.check_call( PLUTIL + [\n    '-convert',\n    'binary1',\n    '-o',\n    output_plist_file,\n    '--',\n    args.input,\n  ])",
        "detail": ".fvm.flutter_sdk.engine.src.build.config.mac.mac_app",
        "documentation": {}
    },
    {
        "label": "ProcessNIB",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.config.mac.mac_app",
        "description": ".fvm.flutter_sdk.engine.src.build.config.mac.mac_app",
        "peekOfCode": "def ProcessNIB(args):\n  output_nib_file = os.path.join(os.path.abspath(args.output),\n      \"%s.nib\" % os.path.splitext(os.path.basename(args.input))[0])\n  return subprocess.check_call(IBTOOL + [\n    '--module',\n    args.module,\n    '--auto-activate-custom-fonts',\n    '--target-device',\n    'mac',\n    '--compile',",
        "detail": ".fvm.flutter_sdk.engine.src.build.config.mac.mac_app",
        "documentation": {}
    },
    {
        "label": "GenerateProjectStructure",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.config.mac.mac_app",
        "description": ".fvm.flutter_sdk.engine.src.build.config.mac.mac_app",
        "peekOfCode": "def GenerateProjectStructure(args):\n  application_path = os.path.join( args.dir, args.name + \".app\", \"Contents\" )\n  return MakeDirectories( application_path )\ndef Main():\n  parser = argparse.ArgumentParser(description='A script that aids in '\n                                   'the creation of an Mac application')\n  subparsers = parser.add_subparsers()\n  # Plist Parser\n  plist_parser = subparsers.add_parser('plist',\n                                       help='Process the Info.plist')",
        "detail": ".fvm.flutter_sdk.engine.src.build.config.mac.mac_app",
        "documentation": {}
    },
    {
        "label": "Main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.config.mac.mac_app",
        "description": ".fvm.flutter_sdk.engine.src.build.config.mac.mac_app",
        "peekOfCode": "def Main():\n  parser = argparse.ArgumentParser(description='A script that aids in '\n                                   'the creation of an Mac application')\n  subparsers = parser.add_subparsers()\n  # Plist Parser\n  plist_parser = subparsers.add_parser('plist',\n                                       help='Process the Info.plist')\n  plist_parser.set_defaults(func=ProcessInfoPlist)\n  plist_parser.add_argument('-i', dest='input', help='The input plist path')\n  plist_parser.add_argument('-o', dest='output', help='The output plist dir')",
        "detail": ".fvm.flutter_sdk.engine.src.build.config.mac.mac_app",
        "documentation": {}
    },
    {
        "label": "PLUTIL",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.config.mac.mac_app",
        "description": ".fvm.flutter_sdk.engine.src.build.config.mac.mac_app",
        "peekOfCode": "PLUTIL = [\n  '/usr/bin/env',\n  'xcrun',\n  'plutil'\n]\nIBTOOL = [\n  '/usr/bin/env',\n  'xcrun',\n  'ibtool',\n]",
        "detail": ".fvm.flutter_sdk.engine.src.build.config.mac.mac_app",
        "documentation": {}
    },
    {
        "label": "IBTOOL",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.config.mac.mac_app",
        "description": ".fvm.flutter_sdk.engine.src.build.config.mac.mac_app",
        "peekOfCode": "IBTOOL = [\n  '/usr/bin/env',\n  'xcrun',\n  'ibtool',\n]\ndef MakeDirectories(path):\n  try:\n    os.makedirs(path)\n  except OSError as exc:\n    if exc.errno == errno.EEXIST and os.path.isdir(path):",
        "detail": ".fvm.flutter_sdk.engine.src.build.config.mac.mac_app",
        "documentation": {}
    },
    {
        "label": "Main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.config.mac.package_framework",
        "description": ".fvm.flutter_sdk.engine.src.build.config.mac.package_framework",
        "peekOfCode": "def Main():\n  parser = argparse.ArgumentParser(description='Create Mac Framework symlinks')\n  parser.add_argument('--framework', action='store', type=str, required=True)\n  parser.add_argument('--version', action='store', type=str)\n  parser.add_argument('--contents', action='store', type=str, nargs='+')\n  parser.add_argument('--stamp', action='store', type=str, required=True)\n  args = parser.parse_args()\n  VERSIONS = 'Versions'\n  CURRENT = 'Current'\n  # Ensure the Foo.framework/Versions/A/ directory exists and create the",
        "detail": ".fvm.flutter_sdk.engine.src.build.config.mac.package_framework",
        "documentation": {}
    },
    {
        "label": "Error",
        "kind": 6,
        "importPath": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "description": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "peekOfCode": "class Error(Exception):\n  pass\ndef GetSha1(filename):\n  sha1 = hashlib.sha1()\n  with open(filename, 'rb') as f:\n    while True:\n      # Read in 1mb chunks, so it doesn't all have to be loaded into memory.\n      chunk = f.read(1024*1024)\n      if not chunk:\n        break",
        "detail": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "documentation": {}
    },
    {
        "label": "GetSha1",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "description": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "peekOfCode": "def GetSha1(filename):\n  sha1 = hashlib.sha1()\n  with open(filename, 'rb') as f:\n    while True:\n      # Read in 1mb chunks, so it doesn't all have to be loaded into memory.\n      chunk = f.read(1024*1024)\n      if not chunk:\n        break\n      sha1.update(chunk)\n  return sha1.hexdigest()",
        "detail": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "description": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "peekOfCode": "def main(args):\n  parser = optparse.OptionParser('usage: %prog [OPTIONS]', description=__doc__)\n  parser.add_option('--arch',\n                    help='Sysroot architecture: %s' % ', '.join(VALID_ARCHS))\n  parser.add_option('--all', action='store_true',\n                    help='Install all sysroot images (useful when updating the'\n                         ' images)')\n  parser.add_option('--print-hash',\n                    help='Print the hash of the sysroot for the given arch.')\n  options, _ = parser.parse_args(args)",
        "detail": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "documentation": {}
    },
    {
        "label": "GetSysrootDict",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "description": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "peekOfCode": "def GetSysrootDict(target_platform, target_arch):\n  if target_arch not in VALID_ARCHS:\n    raise Error('Unknown architecture: %s' % target_arch)\n  sysroots_file = os.path.join(SCRIPT_DIR, 'sysroots.json')\n  sysroots = json.load(open(sysroots_file))\n  sysroot_key = '%s_%s' % (target_platform, target_arch)\n  if sysroot_key not in sysroots:\n    raise Error('No sysroot for: %s %s' % (target_platform, target_arch))\n  return sysroots[sysroot_key]\ndef InstallSysroot(target_platform, target_arch):",
        "detail": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "documentation": {}
    },
    {
        "label": "InstallSysroot",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "description": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "peekOfCode": "def InstallSysroot(target_platform, target_arch):\n  sysroot_dict = GetSysrootDict(target_platform, target_arch)\n  tarball_filename = sysroot_dict['Tarball']\n  tarball_sha1sum = sysroot_dict['Sha1Sum']\n  # TODO(thestig) Consider putting this elsewhere to avoid having to recreate\n  # it on every build.\n  linux_dir = os.path.dirname(SCRIPT_DIR)\n  sysroot = os.path.join(linux_dir, sysroot_dict['SysrootDir'])\n  url = '%s/%s/%s/%s' % (URL_PREFIX, URL_PATH, tarball_sha1sum,\n                         tarball_filename)",
        "detail": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "documentation": {}
    },
    {
        "label": "SCRIPT_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "description": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "peekOfCode": "SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))\nURL_PREFIX = 'https://commondatastorage.googleapis.com'\nURL_PATH = 'chrome-linux-sysroot/toolchain'\nVALID_ARCHS = ('arm', 'arm64', 'i386', 'amd64')\nARCH_TRANSLATIONS = {\n    'x64': 'amd64',\n    'x86': 'i386',\n}\nDEFAULT_TARGET_PLATFORM = 'sid'\nclass Error(Exception):",
        "detail": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "documentation": {}
    },
    {
        "label": "URL_PREFIX",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "description": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "peekOfCode": "URL_PREFIX = 'https://commondatastorage.googleapis.com'\nURL_PATH = 'chrome-linux-sysroot/toolchain'\nVALID_ARCHS = ('arm', 'arm64', 'i386', 'amd64')\nARCH_TRANSLATIONS = {\n    'x64': 'amd64',\n    'x86': 'i386',\n}\nDEFAULT_TARGET_PLATFORM = 'sid'\nclass Error(Exception):\n  pass",
        "detail": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "documentation": {}
    },
    {
        "label": "URL_PATH",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "description": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "peekOfCode": "URL_PATH = 'chrome-linux-sysroot/toolchain'\nVALID_ARCHS = ('arm', 'arm64', 'i386', 'amd64')\nARCH_TRANSLATIONS = {\n    'x64': 'amd64',\n    'x86': 'i386',\n}\nDEFAULT_TARGET_PLATFORM = 'sid'\nclass Error(Exception):\n  pass\ndef GetSha1(filename):",
        "detail": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "documentation": {}
    },
    {
        "label": "VALID_ARCHS",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "description": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "peekOfCode": "VALID_ARCHS = ('arm', 'arm64', 'i386', 'amd64')\nARCH_TRANSLATIONS = {\n    'x64': 'amd64',\n    'x86': 'i386',\n}\nDEFAULT_TARGET_PLATFORM = 'sid'\nclass Error(Exception):\n  pass\ndef GetSha1(filename):\n  sha1 = hashlib.sha1()",
        "detail": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "documentation": {}
    },
    {
        "label": "ARCH_TRANSLATIONS",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "description": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "peekOfCode": "ARCH_TRANSLATIONS = {\n    'x64': 'amd64',\n    'x86': 'i386',\n}\nDEFAULT_TARGET_PLATFORM = 'sid'\nclass Error(Exception):\n  pass\ndef GetSha1(filename):\n  sha1 = hashlib.sha1()\n  with open(filename, 'rb') as f:",
        "detail": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TARGET_PLATFORM",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "description": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "peekOfCode": "DEFAULT_TARGET_PLATFORM = 'sid'\nclass Error(Exception):\n  pass\ndef GetSha1(filename):\n  sha1 = hashlib.sha1()\n  with open(filename, 'rb') as f:\n    while True:\n      # Read in 1mb chunks, so it doesn't all have to be loaded into memory.\n      chunk = f.read(1024*1024)\n      if not chunk:",
        "detail": ".fvm.flutter_sdk.engine.src.build.linux.sysroot_scripts.install-sysroot",
        "documentation": {}
    },
    {
        "label": "dumpsyms",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.linux.dump_app_syms",
        "description": ".fvm.flutter_sdk.engine.src.build.linux.dump_app_syms",
        "peekOfCode": "dumpsyms = sys.argv[1]\nstrip_binary = sys.argv[2]\ninfile = sys.argv[3]\noutfile = sys.argv[4]\n# Dump only when the output file is out-of-date.\nif not os.path.isfile(outfile) or \\\n   os.stat(outfile).st_mtime > os.stat(infile).st_mtime:\n  with open(outfile, 'w') as outfileobj:\n    subprocess.check_call([dumpsyms, '-r', infile], stdout=outfileobj)\nif strip_binary != '0':",
        "detail": ".fvm.flutter_sdk.engine.src.build.linux.dump_app_syms",
        "documentation": {}
    },
    {
        "label": "strip_binary",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.linux.dump_app_syms",
        "description": ".fvm.flutter_sdk.engine.src.build.linux.dump_app_syms",
        "peekOfCode": "strip_binary = sys.argv[2]\ninfile = sys.argv[3]\noutfile = sys.argv[4]\n# Dump only when the output file is out-of-date.\nif not os.path.isfile(outfile) or \\\n   os.stat(outfile).st_mtime > os.stat(infile).st_mtime:\n  with open(outfile, 'w') as outfileobj:\n    subprocess.check_call([dumpsyms, '-r', infile], stdout=outfileobj)\nif strip_binary != '0':\n  subprocess.check_call(['strip', infile])",
        "detail": ".fvm.flutter_sdk.engine.src.build.linux.dump_app_syms",
        "documentation": {}
    },
    {
        "label": "infile",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.linux.dump_app_syms",
        "description": ".fvm.flutter_sdk.engine.src.build.linux.dump_app_syms",
        "peekOfCode": "infile = sys.argv[3]\noutfile = sys.argv[4]\n# Dump only when the output file is out-of-date.\nif not os.path.isfile(outfile) or \\\n   os.stat(outfile).st_mtime > os.stat(infile).st_mtime:\n  with open(outfile, 'w') as outfileobj:\n    subprocess.check_call([dumpsyms, '-r', infile], stdout=outfileobj)\nif strip_binary != '0':\n  subprocess.check_call(['strip', infile])",
        "detail": ".fvm.flutter_sdk.engine.src.build.linux.dump_app_syms",
        "documentation": {}
    },
    {
        "label": "outfile",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.linux.dump_app_syms",
        "description": ".fvm.flutter_sdk.engine.src.build.linux.dump_app_syms",
        "peekOfCode": "outfile = sys.argv[4]\n# Dump only when the output file is out-of-date.\nif not os.path.isfile(outfile) or \\\n   os.stat(outfile).st_mtime > os.stat(infile).st_mtime:\n  with open(outfile, 'w') as outfileobj:\n    subprocess.check_call([dumpsyms, '-r', infile], stdout=outfileobj)\nif strip_binary != '0':\n  subprocess.check_call(['strip', infile])",
        "detail": ".fvm.flutter_sdk.engine.src.build.linux.dump_app_syms",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.linux.install-chromeos-fonts",
        "description": ".fvm.flutter_sdk.engine.src.build.linux.install-chromeos-fonts",
        "peekOfCode": "def main(args):\n  if not sys.platform.startswith('linux'):\n    print(\"Error: %s must be run on Linux.\" % __file__)\n    return 1\n  if os.getuid() != 0:\n    print(\"Error: %s must be run as root.\" % __file__)\n    return 1\n  if not os.path.isdir(FONTS_DIR):\n    print(\"Error: Destination directory does not exist: %s\" % FONTS_DIR)\n    return 1",
        "detail": ".fvm.flutter_sdk.engine.src.build.linux.install-chromeos-fonts",
        "documentation": {}
    },
    {
        "label": "VERSION",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.linux.install-chromeos-fonts",
        "description": ".fvm.flutter_sdk.engine.src.build.linux.install-chromeos-fonts",
        "peekOfCode": "VERSION = '20140815'\nURL = ('https://commondatastorage.googleapis.com/chromeos-localmirror/'\n       'distfiles/notofonts-%s.tar.bz2') % (VERSION)\nFONTS_DIR = '/usr/local/share/fonts'\ndef main(args):\n  if not sys.platform.startswith('linux'):\n    print(\"Error: %s must be run on Linux.\" % __file__)\n    return 1\n  if os.getuid() != 0:\n    print(\"Error: %s must be run as root.\" % __file__)",
        "detail": ".fvm.flutter_sdk.engine.src.build.linux.install-chromeos-fonts",
        "documentation": {}
    },
    {
        "label": "URL",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.linux.install-chromeos-fonts",
        "description": ".fvm.flutter_sdk.engine.src.build.linux.install-chromeos-fonts",
        "peekOfCode": "URL = ('https://commondatastorage.googleapis.com/chromeos-localmirror/'\n       'distfiles/notofonts-%s.tar.bz2') % (VERSION)\nFONTS_DIR = '/usr/local/share/fonts'\ndef main(args):\n  if not sys.platform.startswith('linux'):\n    print(\"Error: %s must be run on Linux.\" % __file__)\n    return 1\n  if os.getuid() != 0:\n    print(\"Error: %s must be run as root.\" % __file__)\n    return 1",
        "detail": ".fvm.flutter_sdk.engine.src.build.linux.install-chromeos-fonts",
        "documentation": {}
    },
    {
        "label": "FONTS_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.linux.install-chromeos-fonts",
        "description": ".fvm.flutter_sdk.engine.src.build.linux.install-chromeos-fonts",
        "peekOfCode": "FONTS_DIR = '/usr/local/share/fonts'\ndef main(args):\n  if not sys.platform.startswith('linux'):\n    print(\"Error: %s must be run on Linux.\" % __file__)\n    return 1\n  if os.getuid() != 0:\n    print(\"Error: %s must be run as root.\" % __file__)\n    return 1\n  if not os.path.isdir(FONTS_DIR):\n    print(\"Error: Destination directory does not exist: %s\" % FONTS_DIR)",
        "detail": ".fvm.flutter_sdk.engine.src.build.linux.install-chromeos-fonts",
        "documentation": {}
    },
    {
        "label": "RewritePath",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.linux.rewrite_dirs",
        "description": ".fvm.flutter_sdk.engine.src.build.linux.rewrite_dirs",
        "peekOfCode": "def RewritePath(path, opts):\n  \"\"\"Rewrites a path by stripping the prefix and prepending the sysroot.\"\"\"\n  sysroot = opts.sysroot\n  prefix = opts.strip_prefix\n  if os.path.isabs(path) and not path.startswith(sysroot):\n    if path.startswith(prefix):\n      path = path[len(prefix):]\n    path = path.lstrip('/')\n    return os.path.join(sysroot, path)\n  else:",
        "detail": ".fvm.flutter_sdk.engine.src.build.linux.rewrite_dirs",
        "documentation": {}
    },
    {
        "label": "RewriteLine",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.linux.rewrite_dirs",
        "description": ".fvm.flutter_sdk.engine.src.build.linux.rewrite_dirs",
        "peekOfCode": "def RewriteLine(line, opts):\n  \"\"\"Rewrites all the paths in recognized options.\"\"\"\n  args = line.split()\n  count = len(args)\n  i = 0\n  while i < count:\n    for prefix in REWRITE_PREFIX:\n      # The option can be either in the form \"-I /path/to/dir\" or\n      # \"-I/path/to/dir\" so handle both.\n      if args[i] == prefix:",
        "detail": ".fvm.flutter_sdk.engine.src.build.linux.rewrite_dirs",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.linux.rewrite_dirs",
        "description": ".fvm.flutter_sdk.engine.src.build.linux.rewrite_dirs",
        "peekOfCode": "def main(argv):\n  parser = optparse.OptionParser()\n  parser.add_option('-s', '--sysroot', default='/', help='sysroot to prepend')\n  parser.add_option('-p', '--strip-prefix', default='', help='prefix to strip')\n  opts, args = parser.parse_args(argv[1:])\n  for line in sys.stdin.readlines():\n    line = RewriteLine(line.strip(), opts)\n    print(line)\n  return 0\nif __name__ == '__main__':",
        "detail": ".fvm.flutter_sdk.engine.src.build.linux.rewrite_dirs",
        "documentation": {}
    },
    {
        "label": "REWRITE_PREFIX",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.linux.rewrite_dirs",
        "description": ".fvm.flutter_sdk.engine.src.build.linux.rewrite_dirs",
        "peekOfCode": "REWRITE_PREFIX = ['-I',\n                  '-idirafter',\n                  '-imacros',\n                  '-imultilib',\n                  '-include',\n                  '-iprefix',\n                  '-iquote',\n                  '-isystem',\n                  '-L']\ndef RewritePath(path, opts):",
        "detail": ".fvm.flutter_sdk.engine.src.build.linux.rewrite_dirs",
        "documentation": {}
    },
    {
        "label": "MachOError",
        "kind": 6,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "peekOfCode": "class MachOError(Exception):\n  \"\"\"A class for exceptions thrown by this module.\"\"\"\n  pass\ndef CheckedSeek(file, offset):\n  \"\"\"Seeks the file-like object at |file| to offset |offset| and raises a\n  MachOError if anything funny happens.\"\"\"\n  file.seek(offset, os.SEEK_SET)\n  new_offset = file.tell()\n  if new_offset != offset:\n    raise MachOError('seek: expected offset %d, observed %d' % (offset, new_offset))",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "documentation": {}
    },
    {
        "label": "CheckedSeek",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "peekOfCode": "def CheckedSeek(file, offset):\n  \"\"\"Seeks the file-like object at |file| to offset |offset| and raises a\n  MachOError if anything funny happens.\"\"\"\n  file.seek(offset, os.SEEK_SET)\n  new_offset = file.tell()\n  if new_offset != offset:\n    raise MachOError('seek: expected offset %d, observed %d' % (offset, new_offset))\ndef CheckedRead(file, count):\n  \"\"\"Reads |count| bytes from the file-like |file| object, raising a\n  MachOError if any other number of bytes is read.\"\"\"",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "documentation": {}
    },
    {
        "label": "CheckedRead",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "peekOfCode": "def CheckedRead(file, count):\n  \"\"\"Reads |count| bytes from the file-like |file| object, raising a\n  MachOError if any other number of bytes is read.\"\"\"\n  bytes = file.read(count)\n  if len(bytes) != count:\n    raise MachOError('read: expected length %d, observed %d' % (count, len(bytes)))\n  return bytes\ndef ReadUInt32(file, endian):\n  \"\"\"Reads an unsinged 32-bit integer from the file-like |file| object,\n  treating it as having endianness specified by |endian| (per the |struct|",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "documentation": {}
    },
    {
        "label": "ReadUInt32",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "peekOfCode": "def ReadUInt32(file, endian):\n  \"\"\"Reads an unsinged 32-bit integer from the file-like |file| object,\n  treating it as having endianness specified by |endian| (per the |struct|\n  module), and returns it as a number. Raises a MachOError if the proper\n  length of data can't be read from |file|.\"\"\"\n  bytes = CheckedRead(file, 4)\n  (uint32,) = struct.unpack(endian + 'I', bytes)\n  return uint32\ndef ReadMachHeader(file, endian):\n  \"\"\"Reads an entire |mach_header| structure (<mach-o/loader.h>) from the",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "documentation": {}
    },
    {
        "label": "ReadMachHeader",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "peekOfCode": "def ReadMachHeader(file, endian):\n  \"\"\"Reads an entire |mach_header| structure (<mach-o/loader.h>) from the\n  file-like |file| object, treating it as having endianness specified by\n  |endian| (per the |struct| module), and returns a 7-tuple of its members\n  as numbers. Raises a MachOError if the proper length of data can't be read\n  from |file|.\"\"\"\n  bytes = CheckedRead(file, 28)\n  magic, cputype, cpusubtype, filetype, ncmds, sizeofcmds, flags = \\\n      struct.unpack(endian + '7I', bytes)\n  return magic, cputype, cpusubtype, filetype, ncmds, sizeofcmds, flags",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "documentation": {}
    },
    {
        "label": "ReadFatArch",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "peekOfCode": "def ReadFatArch(file):\n  \"\"\"Reads an entire |fat_arch| structure (<mach-o/fat.h>) from the file-like\n  |file| object, treating it as having endianness specified by |endian|\n  (per the |struct| module), and returns a 5-tuple of its members as numbers.\n  Raises a MachOError if the proper length of data can't be read from\n  |file|.\"\"\"\n  bytes = CheckedRead(file, 20)\n  cputype, cpusubtype, offset, size, align = struct.unpack('>5I', bytes)\n  return cputype, cpusubtype, offset, size, align\ndef WriteUInt32(file, uint32, endian):",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "documentation": {}
    },
    {
        "label": "WriteUInt32",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "peekOfCode": "def WriteUInt32(file, uint32, endian):\n  \"\"\"Writes |uint32| as an unsinged 32-bit integer to the file-like |file|\n  object, treating it as having endianness specified by |endian| (per the\n  |struct| module).\"\"\"\n  bytes = struct.pack(endian + 'I', uint32)\n  assert len(bytes) == 4\n  file.write(bytes)\ndef HandleMachOFile(file, options, offset=0):\n  \"\"\"Seeks the file-like |file| object to |offset|, reads its |mach_header|,\n  and rewrites the header's |flags| field if appropriate. The header's",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "documentation": {}
    },
    {
        "label": "HandleMachOFile",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "peekOfCode": "def HandleMachOFile(file, options, offset=0):\n  \"\"\"Seeks the file-like |file| object to |offset|, reads its |mach_header|,\n  and rewrites the header's |flags| field if appropriate. The header's\n  endianness is detected. Both 32-bit and 64-bit Mach-O headers are supported\n  (mach_header and mach_header_64). Raises MachOError if used on a header that\n  does not have a known magic number or is not of type MH_EXECUTE. The\n  MH_PIE and MH_NO_HEAP_EXECUTION bits are set or cleared in the |flags| field\n  according to |options| and written to |file| if any changes need to be made.\n  If already set or clear as specified by |options|, nothing is written.\"\"\"\n  CheckedSeek(file, offset)",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "documentation": {}
    },
    {
        "label": "HandleFatFile",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "peekOfCode": "def HandleFatFile(file, options, fat_offset=0):\n  \"\"\"Seeks the file-like |file| object to |offset| and loops over its\n  |fat_header| entries, calling HandleMachOFile for each.\"\"\"\n  CheckedSeek(file, fat_offset)\n  magic = ReadUInt32(file, '>')\n  assert magic == FAT_MAGIC\n  nfat_arch = ReadUInt32(file, '>')\n  for index in range(0, nfat_arch):\n    cputype, cpusubtype, offset, size, align = ReadFatArch(file)\n    assert size >= 28",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "peekOfCode": "def main(me, args):\n  parser = optparse.OptionParser('%prog [options] <executable_path>')\n  parser.add_option('--executable-heap', action='store_false',\n                    dest='no_heap_execution', default=True,\n                    help='Clear the MH_NO_HEAP_EXECUTION bit')\n  parser.add_option('--no-pie', action='store_false',\n                    dest='pie', default=True,\n                    help='Clear the MH_PIE bit')\n  (options, loose_args) = parser.parse_args(args)\n  if len(loose_args) != 1:",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "documentation": {}
    },
    {
        "label": "FAT_MAGIC",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "peekOfCode": "FAT_MAGIC = 0xcafebabe\nFAT_CIGAM = 0xbebafeca\n# <mach-o/loader.h>\nMH_MAGIC = 0xfeedface\nMH_CIGAM = 0xcefaedfe\nMH_MAGIC_64 = 0xfeedfacf\nMH_CIGAM_64 = 0xcffaedfe\nMH_EXECUTE = 0x2\nMH_PIE = 0x00200000\nMH_NO_HEAP_EXECUTION = 0x01000000",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "documentation": {}
    },
    {
        "label": "FAT_CIGAM",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "peekOfCode": "FAT_CIGAM = 0xbebafeca\n# <mach-o/loader.h>\nMH_MAGIC = 0xfeedface\nMH_CIGAM = 0xcefaedfe\nMH_MAGIC_64 = 0xfeedfacf\nMH_CIGAM_64 = 0xcffaedfe\nMH_EXECUTE = 0x2\nMH_PIE = 0x00200000\nMH_NO_HEAP_EXECUTION = 0x01000000\nclass MachOError(Exception):",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "documentation": {}
    },
    {
        "label": "MH_MAGIC",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "peekOfCode": "MH_MAGIC = 0xfeedface\nMH_CIGAM = 0xcefaedfe\nMH_MAGIC_64 = 0xfeedfacf\nMH_CIGAM_64 = 0xcffaedfe\nMH_EXECUTE = 0x2\nMH_PIE = 0x00200000\nMH_NO_HEAP_EXECUTION = 0x01000000\nclass MachOError(Exception):\n  \"\"\"A class for exceptions thrown by this module.\"\"\"\n  pass",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "documentation": {}
    },
    {
        "label": "MH_CIGAM",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "peekOfCode": "MH_CIGAM = 0xcefaedfe\nMH_MAGIC_64 = 0xfeedfacf\nMH_CIGAM_64 = 0xcffaedfe\nMH_EXECUTE = 0x2\nMH_PIE = 0x00200000\nMH_NO_HEAP_EXECUTION = 0x01000000\nclass MachOError(Exception):\n  \"\"\"A class for exceptions thrown by this module.\"\"\"\n  pass\ndef CheckedSeek(file, offset):",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "documentation": {}
    },
    {
        "label": "MH_MAGIC_64",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "peekOfCode": "MH_MAGIC_64 = 0xfeedfacf\nMH_CIGAM_64 = 0xcffaedfe\nMH_EXECUTE = 0x2\nMH_PIE = 0x00200000\nMH_NO_HEAP_EXECUTION = 0x01000000\nclass MachOError(Exception):\n  \"\"\"A class for exceptions thrown by this module.\"\"\"\n  pass\ndef CheckedSeek(file, offset):\n  \"\"\"Seeks the file-like object at |file| to offset |offset| and raises a",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "documentation": {}
    },
    {
        "label": "MH_CIGAM_64",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "peekOfCode": "MH_CIGAM_64 = 0xcffaedfe\nMH_EXECUTE = 0x2\nMH_PIE = 0x00200000\nMH_NO_HEAP_EXECUTION = 0x01000000\nclass MachOError(Exception):\n  \"\"\"A class for exceptions thrown by this module.\"\"\"\n  pass\ndef CheckedSeek(file, offset):\n  \"\"\"Seeks the file-like object at |file| to offset |offset| and raises a\n  MachOError if anything funny happens.\"\"\"",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "documentation": {}
    },
    {
        "label": "MH_EXECUTE",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "peekOfCode": "MH_EXECUTE = 0x2\nMH_PIE = 0x00200000\nMH_NO_HEAP_EXECUTION = 0x01000000\nclass MachOError(Exception):\n  \"\"\"A class for exceptions thrown by this module.\"\"\"\n  pass\ndef CheckedSeek(file, offset):\n  \"\"\"Seeks the file-like object at |file| to offset |offset| and raises a\n  MachOError if anything funny happens.\"\"\"\n  file.seek(offset, os.SEEK_SET)",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "documentation": {}
    },
    {
        "label": "MH_PIE",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "peekOfCode": "MH_PIE = 0x00200000\nMH_NO_HEAP_EXECUTION = 0x01000000\nclass MachOError(Exception):\n  \"\"\"A class for exceptions thrown by this module.\"\"\"\n  pass\ndef CheckedSeek(file, offset):\n  \"\"\"Seeks the file-like object at |file| to offset |offset| and raises a\n  MachOError if anything funny happens.\"\"\"\n  file.seek(offset, os.SEEK_SET)\n  new_offset = file.tell()",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "documentation": {}
    },
    {
        "label": "MH_NO_HEAP_EXECUTION",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "peekOfCode": "MH_NO_HEAP_EXECUTION = 0x01000000\nclass MachOError(Exception):\n  \"\"\"A class for exceptions thrown by this module.\"\"\"\n  pass\ndef CheckedSeek(file, offset):\n  \"\"\"Seeks the file-like object at |file| to offset |offset| and raises a\n  MachOError if anything funny happens.\"\"\"\n  file.seek(offset, os.SEEK_SET)\n  new_offset = file.tell()\n  if new_offset != offset:",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.change_mach_o_flags",
        "documentation": {}
    },
    {
        "label": "TargetSdk",
        "kind": 6,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "peekOfCode": "class TargetSdk:\n  \"\"\"A target-platform SDK.\"\"\"\n  name: str\n  platform_path: str\n  sdk_path: str\n@dataclass\nclass SdkInfo:\n  \"\"\"The host toolchain and all requested SDK paths.\"\"\"\n  toolchain_path: str\n  sdks: list",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "documentation": {}
    },
    {
        "label": "SdkInfo",
        "kind": 6,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "peekOfCode": "class SdkInfo:\n  \"\"\"The host toolchain and all requested SDK paths.\"\"\"\n  toolchain_path: str\n  sdks: list\ndef get_sdk_info(sdks) -> SdkInfo:\n  \"\"\"Collects paths for host toolchain and all specified SDKs.\"\"\"\n  sdk_info = SdkInfo(get_toolchain_path(), [])\n  for sdk in sdks:\n    platform_path = get_platform_path(sdk)\n    sdk_path = get_sdk_path(sdk)",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "documentation": {}
    },
    {
        "label": "parse_arguments",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "peekOfCode": "def parse_arguments():\n  \"\"\"Parses command-line arguments.\"\"\"\n  parser = argparse.ArgumentParser()\n  parser.add_argument(\n    '--as-gclient-hook',\n    default=False,\n    action='store_true',\n    help='Whether the script is running as a gclient hook.',\n  )\n  parser.add_argument(",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "documentation": {}
    },
    {
        "label": "get_toolchain_path",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "peekOfCode": "def get_toolchain_path() -> str:\n  \"\"\"Returns path for the host toolchain.\"\"\"\n  xcode_path = subprocess.check_output(['xcode-select', '-print-path'], timeout=300).decode('utf-8').strip()\n  return os.path.join(xcode_path, 'Toolchains/XcodeDefault.xctoolchain')\ndef get_platform_path(sdk) -> str:\n  \"\"\"Returns the platform path for the specified SDK.\"\"\"\n  return subprocess.check_output(['xcrun', '--sdk', sdk, '--show-sdk-platform-path'], timeout=300).decode('utf-8').strip()\ndef get_sdk_path(sdk) -> str:\n  \"\"\"Returns the SDK path for the specified SDK.\"\"\"\n  return subprocess.check_output(['xcrun', '--sdk', sdk, '--show-sdk-path'], timeout=300).decode('utf-8').strip()",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "documentation": {}
    },
    {
        "label": "get_platform_path",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "peekOfCode": "def get_platform_path(sdk) -> str:\n  \"\"\"Returns the platform path for the specified SDK.\"\"\"\n  return subprocess.check_output(['xcrun', '--sdk', sdk, '--show-sdk-platform-path'], timeout=300).decode('utf-8').strip()\ndef get_sdk_path(sdk) -> str:\n  \"\"\"Returns the SDK path for the specified SDK.\"\"\"\n  return subprocess.check_output(['xcrun', '--sdk', sdk, '--show-sdk-path'], timeout=300).decode('utf-8').strip()\n@dataclass\nclass TargetSdk:\n  \"\"\"A target-platform SDK.\"\"\"\n  name: str",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "documentation": {}
    },
    {
        "label": "get_sdk_path",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "peekOfCode": "def get_sdk_path(sdk) -> str:\n  \"\"\"Returns the SDK path for the specified SDK.\"\"\"\n  return subprocess.check_output(['xcrun', '--sdk', sdk, '--show-sdk-path'], timeout=300).decode('utf-8').strip()\n@dataclass\nclass TargetSdk:\n  \"\"\"A target-platform SDK.\"\"\"\n  name: str\n  platform_path: str\n  sdk_path: str\n@dataclass",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "documentation": {}
    },
    {
        "label": "get_sdk_info",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "peekOfCode": "def get_sdk_info(sdks) -> SdkInfo:\n  \"\"\"Collects paths for host toolchain and all specified SDKs.\"\"\"\n  sdk_info = SdkInfo(get_toolchain_path(), [])\n  for sdk in sdks:\n    platform_path = get_platform_path(sdk)\n    sdk_path = get_sdk_path(sdk)\n    sdk_info.sdks.append(TargetSdk(sdk, platform_path, sdk_path))\n  return sdk_info\ndef print_paths(sdk_info) -> None:\n  \"\"\"Prints all SDK paths in key=value from to stdout.\"\"\"",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "documentation": {}
    },
    {
        "label": "print_paths",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "peekOfCode": "def print_paths(sdk_info) -> None:\n  \"\"\"Prints all SDK paths in key=value from to stdout.\"\"\"\n  print('toolchain_path=\"%s\"' % sdk_info.toolchain_path)\n  for sdk in sdk_info.sdks:\n    print('%s_platform_path=\"%s\"' % (sdk.name, sdk.platform_path))\n    print('%s_sdk_path=\"%s\"' % (sdk.name, sdk.sdk_path))\ndef create_symlink(target_dir, orig_path) -> str:\n  \"\"\"Creates a symlink in target_dir that points to orig_path and has the same basename.\"\"\"\n  target_path = os.path.join(target_dir, os.path.basename(orig_path))\n  symlink(orig_path, target_path)",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "documentation": {}
    },
    {
        "label": "create_symlink",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "peekOfCode": "def create_symlink(target_dir, orig_path) -> str:\n  \"\"\"Creates a symlink in target_dir that points to orig_path and has the same basename.\"\"\"\n  target_path = os.path.join(target_dir, os.path.basename(orig_path))\n  symlink(orig_path, target_path)\n  return target_path\ndef create_symlinks(sdk_info, symlink_path, delete_existing_links) -> SdkInfo:\n  \"\"\"\n  Creates SDK symlinks under symlink_path.\n  Returns an SdkInfo with paths updated to use the symlinks instead of original paths.\n  \"\"\"",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "documentation": {}
    },
    {
        "label": "create_symlinks",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "peekOfCode": "def create_symlinks(sdk_info, symlink_path, delete_existing_links) -> SdkInfo:\n  \"\"\"\n  Creates SDK symlinks under symlink_path.\n  Returns an SdkInfo with paths updated to use the symlinks instead of original paths.\n  \"\"\"\n  platforms_path = os.path.join(symlink_path, 'Platforms')\n  sdks_path = os.path.join(symlink_path, 'SDKs')\n  if delete_existing_links:\n    # Remove any old files created by this script under the prebuilts dir.\n    if os.path.isdir(platforms_path):",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "peekOfCode": "def main(argv):\n  args = parse_arguments()\n  # On CI, Xcode is not yet installed when gclient hooks are being run.\n  # This is because the version of Xcode that CI installs might depend on the\n  # contents of the repo, so the repo must be set up first, which includes\n  # running the gclient hooks. Instead, on CI, this script will be run during\n  # GN.\n  running_on_luci = os.environ.get('LUCI_CONTEXT') is not None\n  if running_on_luci and args.as_gclient_hook:\n    return 0",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "documentation": {}
    },
    {
        "label": "PREBUILTS",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "peekOfCode": "PREBUILTS = os.path.realpath(os.path.join(\n  os.path.dirname(__file__), os.pardir, os.pardir, 'flutter', 'prebuilts',\n))\n# Supported SDKs.\nSDKS = ['iphoneos', 'iphonesimulator', 'macosx']\ndef parse_arguments():\n  \"\"\"Parses command-line arguments.\"\"\"\n  parser = argparse.ArgumentParser()\n  parser.add_argument(\n    '--as-gclient-hook',",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "documentation": {}
    },
    {
        "label": "SDKS",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "peekOfCode": "SDKS = ['iphoneos', 'iphonesimulator', 'macosx']\ndef parse_arguments():\n  \"\"\"Parses command-line arguments.\"\"\"\n  parser = argparse.ArgumentParser()\n  parser.add_argument(\n    '--as-gclient-hook',\n    default=False,\n    action='store_true',\n    help='Whether the script is running as a gclient hook.',\n  )",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.darwin_sdk",
        "documentation": {}
    },
    {
        "label": "Main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.tweak_info_plist",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.tweak_info_plist",
        "peekOfCode": "def Main(argv):\n  parser = optparse.OptionParser('%prog [options]')\n  parser.add_option('--breakpad', dest='use_breakpad', action='store',\n      type='int', default=False, help='Enable Breakpad [1 or 0]')\n  parser.add_option('--breakpad_uploads', dest='breakpad_uploads',\n      action='store', type='int', default=False,\n      help='Enable Breakpad\\'s uploading of crash dumps [1 or 0]')\n  parser.add_option('--keystone', dest='use_keystone', action='store',\n      type='int', default=False, help='Enable Keystone [1 or 0]')\n  parser.add_option('--scm', dest='add_scm_info', action='store', type='int',",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.tweak_info_plist",
        "documentation": {}
    },
    {
        "label": "TOP",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.mac.tweak_info_plist",
        "description": ".fvm.flutter_sdk.engine.src.build.mac.tweak_info_plist",
        "peekOfCode": "TOP = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))\ndef _GetOutput(args):\n  \"\"\"Runs a subprocess and waits for termination. Returns (stdout, returncode)\n  of the process. stderr is attached to the parent.\"\"\"\n  proc = subprocess.Popen(args, stdout=subprocess.PIPE)\n  (stdout, stderr) = proc.communicate()\n  return (stdout, proc.returncode)\ndef _GetOutputNoError(args):\n  \"\"\"Similar to _GetOutput() but ignores stderr. If there's an error launching\n  the child (like file not found), the exception will be caught and (None, 1)",
        "detail": ".fvm.flutter_sdk.engine.src.build.mac.tweak_info_plist",
        "documentation": {}
    },
    {
        "label": "mkdir_p",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.pyutil.file_util",
        "description": ".fvm.flutter_sdk.engine.src.build.pyutil.file_util",
        "peekOfCode": "def mkdir_p(path):\n  try:\n    os.makedirs(path)\n  except OSError as exc:\n    if exc.errno == errno.EEXIST and os.path.isdir(path):\n      pass\n    else:\n      raise\n\"\"\"Creates or ovewrites a symlink from `link` to `target`.\"\"\"\ndef symlink(target, link):",
        "detail": ".fvm.flutter_sdk.engine.src.build.pyutil.file_util",
        "documentation": {}
    },
    {
        "label": "symlink",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.pyutil.file_util",
        "description": ".fvm.flutter_sdk.engine.src.build.pyutil.file_util",
        "peekOfCode": "def symlink(target, link):\n  mkdir_p(os.path.dirname(link))\n  tmp_link = link + '.tmp.' + uuid.uuid4().hex\n  try:\n    os.remove(tmp_link)\n  except OSError:\n    pass\n  os.symlink(target, tmp_link)\n  try:\n    os.rename(tmp_link, link)",
        "detail": ".fvm.flutter_sdk.engine.src.build.pyutil.file_util",
        "documentation": {}
    },
    {
        "label": "ArgumentForwarder",
        "kind": 6,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "peekOfCode": "class ArgumentForwarder(object):\n  \"\"\"Class used to abstract forwarding arguments to the swiftc compiler.\n  Arguments:\n    - arg_name: string corresponding to the argument to pass to the compiler\n    - arg_join: function taking the compiler name and returning whether the\n                argument value is attached to the argument or separated\n    - to_swift: function taking the argument value and returning whether it\n                must be passed to the swift compiler\n    - to_clang: function taking the argument value and returning whether it\n                must be passed to the clang compiler",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "documentation": {}
    },
    {
        "label": "IncludeArgumentForwarder",
        "kind": 6,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "peekOfCode": "class IncludeArgumentForwarder(ArgumentForwarder):\n  \"\"\"Argument forwarder for -I and -isystem.\"\"\"\n  def __init__(self, arg_name):\n    ArgumentForwarder.__init__(self,\n                               arg_name,\n                               arg_join=lambda _: len(arg_name) == 1,\n                               to_swift=lambda _: arg_name != '-isystem',\n                               to_clang=lambda _: True)\nclass FrameworkArgumentForwarder(ArgumentForwarder):\n  \"\"\"Argument forwarder for -F and -Fsystem.\"\"\"",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "documentation": {}
    },
    {
        "label": "FrameworkArgumentForwarder",
        "kind": 6,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "peekOfCode": "class FrameworkArgumentForwarder(ArgumentForwarder):\n  \"\"\"Argument forwarder for -F and -Fsystem.\"\"\"\n  def __init__(self, arg_name):\n    ArgumentForwarder.__init__(self,\n                               arg_name,\n                               arg_join=lambda _: len(arg_name) == 1,\n                               to_swift=lambda _: True,\n                               to_clang=lambda _: True)\nclass DefineArgumentForwarder(ArgumentForwarder):\n  \"\"\"Argument forwarder for -D.\"\"\"",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "documentation": {}
    },
    {
        "label": "DefineArgumentForwarder",
        "kind": 6,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "peekOfCode": "class DefineArgumentForwarder(ArgumentForwarder):\n  \"\"\"Argument forwarder for -D.\"\"\"\n  def __init__(self, arg_name):\n    ArgumentForwarder.__init__(self,\n                               arg_name,\n                               arg_join=lambda _: _ == 'clang',\n                               to_swift=lambda _: '=' not in _,\n                               to_clang=lambda _: True)\n# Dictionary mapping argument names to their ArgumentForwarder.\nARGUMENT_FORWARDER_FOR_ATTR = (",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "documentation": {}
    },
    {
        "label": "FileWriter",
        "kind": 6,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "peekOfCode": "class FileWriter(contextlib.AbstractContextManager):\n  \"\"\"\n  FileWriter is a file-like object that only write data to disk if changed.\n  This object implements the context manager protocols and thus can be used\n  in a with-clause. The data is written to disk when the context is exited,\n  and only if the content is different from current file content.\n    with FileWriter(path) as stream:\n      stream.write('...')\n  If the with-clause ends with an exception, no data is written to the disk\n  and any existing file is left untouched.",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "documentation": {}
    },
    {
        "label": "existing_directory",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "peekOfCode": "def existing_directory(path):\n  \"\"\"Returns a context manager wrapping an existing directory.\"\"\"\n  yield path\ndef create_stamp_file(path):\n  \"\"\"Writes an empty stamp file at path.\"\"\"\n  with FileWriter(path) as stream:\n    stream.write('')\ndef create_build_cache_dir(args, build_signature):\n  \"\"\"Creates the build cache directory according to `args`.\n  This function returns an object that implements the context manager",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "documentation": {}
    },
    {
        "label": "create_stamp_file",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "peekOfCode": "def create_stamp_file(path):\n  \"\"\"Writes an empty stamp file at path.\"\"\"\n  with FileWriter(path) as stream:\n    stream.write('')\ndef create_build_cache_dir(args, build_signature):\n  \"\"\"Creates the build cache directory according to `args`.\n  This function returns an object that implements the context manager\n  protocol and thus can be used in a with-clause. If -derived-data-dir\n  argument is not used, the returned directory is a temporary directory\n  that will be deleted when the with-clause is exited.",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "documentation": {}
    },
    {
        "label": "create_build_cache_dir",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "peekOfCode": "def create_build_cache_dir(args, build_signature):\n  \"\"\"Creates the build cache directory according to `args`.\n  This function returns an object that implements the context manager\n  protocol and thus can be used in a with-clause. If -derived-data-dir\n  argument is not used, the returned directory is a temporary directory\n  that will be deleted when the with-clause is exited.\n  \"\"\"\n  if not args.derived_data_dir:\n    return tempfile.TemporaryDirectory()\n  # The derived data cache can be quite large, so delete any obsolete",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "documentation": {}
    },
    {
        "label": "ensure_directory",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "peekOfCode": "def ensure_directory(path):\n  \"\"\"Creates directory at `path` if it does not exists.\"\"\"\n  if not os.path.isdir(path):\n    os.makedirs(path)\n  return path\ndef build_signature(env, args):\n  \"\"\"Generates the build signature from `env` and `args`.\n  This allow re-using the derived data dir between builds while still\n  forcing the data to be recreated from scratch in case of significant\n  changes to the build settings (different arguments or tool versions).",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "documentation": {}
    },
    {
        "label": "build_signature",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "peekOfCode": "def build_signature(env, args):\n  \"\"\"Generates the build signature from `env` and `args`.\n  This allow re-using the derived data dir between builds while still\n  forcing the data to be recreated from scratch in case of significant\n  changes to the build settings (different arguments or tool versions).\n  \"\"\"\n  m = hashlib.sha1()\n  for key in sorted(env):\n    if key.endswith('_VERSION') or key == 'DEVELOPER_DIR':\n      m.update(f'{key}={env[key]}'.encode('utf8'))",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "documentation": {}
    },
    {
        "label": "generate_source_output_file_map_fragment",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "peekOfCode": "def generate_source_output_file_map_fragment(args, filename):\n  \"\"\"Generates source OutputFileMap.json fragment according to `args`.\n  Create the fragment for a single .swift source file for OutputFileMap.\n  The output depends on whether -whole-module-optimization argument is\n  used or not.\n  \"\"\"\n  assert os.path.splitext(filename)[1] == '.swift', filename\n  basename = os.path.splitext(os.path.basename(filename))[0]\n  out_name = os.path.join(args.target_out_dir, basename)\n  fragment = {",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "documentation": {}
    },
    {
        "label": "generate_module_output_file_map_fragment",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "peekOfCode": "def generate_module_output_file_map_fragment(args):\n  \"\"\"Generates module OutputFileMap.json fragment according to `args`.\n  Create the fragment for the module itself for OutputFileMap. The output\n  depends on whether -whole-module-optimization argument is used or not.\n  \"\"\"\n  out_name = os.path.join(args.target_out_dir, args.module_name)\n  if args.whole_module_optimization:\n    fragment = {\n        'const-values': f'{out_name}.swiftconstvalues',\n        'dependencies': f'{out_name}.d',",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "documentation": {}
    },
    {
        "label": "generate_output_file_map",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "peekOfCode": "def generate_output_file_map(args):\n  \"\"\"Generates OutputFileMap.json according to `args`.\n  Returns the mapping as a python dictionary that can be serialized to\n  disk as JSON.\n  \"\"\"\n  output_file_map = {'': generate_module_output_file_map_fragment(args)}\n  for filename in args.sources:\n    fragment = generate_source_output_file_map_fragment(args, filename)\n    output_file_map[filename] = fragment\n  return output_file_map",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "documentation": {}
    },
    {
        "label": "fix_generated_header",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "peekOfCode": "def fix_generated_header(header_path, output_path, src_dir, gen_dir):\n  \"\"\"Fix the Objective-C header generated by the Swift compiler.\n  The Swift compiler assumes that the generated Objective-C header will be\n  imported from code compiled with module support enabled (-fmodules). The\n  generated code thus uses @import and provides no fallback if modules are\n  not enabled.\n  The Swift compiler also uses absolute path when including the bridging\n  header or another module's generated header. This causes issues with the\n  distributed compiler (i.e. reclient or siso) who expects all paths to be\n  relative to the build directory",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "documentation": {}
    },
    {
        "label": "invoke_swift_compiler",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "peekOfCode": "def invoke_swift_compiler(args, extras_args, build_cache_dir, output_file_map):\n  \"\"\"Invokes Swift compiler to compile module according to `args`.\n  The `build_cache_dir` and `output_file_map` should be path to existing\n  directory to use for writing intermediate build artifact (optionally\n  a temporary directory) and path to $module-OutputFileMap.json file that\n  lists the outputs to generate for the module and each source file.\n  If -fix-module-imports argument is passed, the generated header for the\n  module is written to a temporary location and then modified to replace\n  @import by corresponding #import.\n  \"\"\"",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "documentation": {}
    },
    {
        "label": "generate_depfile",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "peekOfCode": "def generate_depfile(args, output_file_map):\n  \"\"\"Generates compilation depfile according to `args`.\n  Parses all intermediate depfile generated by the Swift compiler and\n  replaces absolute path by relative paths (since ninja compares paths\n  as strings and does not resolve relative paths to absolute).\n  Converts path to the SDK and toolchain files to the sdk/xcode_link\n  symlinks if possible and available.\n  \"\"\"\n  xcode_paths = {}\n  if os.path.islink(args.sdk_path):",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "documentation": {}
    },
    {
        "label": "compile_module",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "peekOfCode": "def compile_module(args, extras_args, build_signature):\n  \"\"\"Compiles Swift module according to `args`.\"\"\"\n  for path in (args.target_out_dir, os.path.dirname(args.header_path)):\n    ensure_directory(path)\n  # Write the $module-OutputFileMap.json file.\n  output_file_map = generate_output_file_map(args)\n  output_file_map_path = os.path.join(args.target_out_dir,\n                                      f'{args.module_name}-OutputFileMap.json')\n  with FileWriter(output_file_map_path) as stream:\n    json.dump(output_file_map, stream, indent=' ', sort_keys=True)",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "peekOfCode": "def main(args):\n  parser = argparse.ArgumentParser(allow_abbrev=False, add_help=False)\n  # Required arguments.\n  parser.add_argument('--module-name',\n                      required=True,\n                      help='name of the Swift module')\n  parser.add_argument('--src-dir',\n                      required=True,\n                      help='path to the source directory')\n  parser.add_argument('--gen-dir',",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "documentation": {}
    },
    {
        "label": "ARGUMENT_FORWARDER_FOR_ATTR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "peekOfCode": "ARGUMENT_FORWARDER_FOR_ATTR = (\n    ('include_dirs', IncludeArgumentForwarder('-I')),\n    ('system_include_dirs', IncludeArgumentForwarder('-isystem')),\n    ('framework_dirs', FrameworkArgumentForwarder('-F')),\n    ('system_framework_dirs', FrameworkArgumentForwarder('-Fsystem')),\n    ('defines', DefineArgumentForwarder('-D')),\n)\n# Regexp used to parse #import lines.\nIMPORT_LINE_REGEXP = re.compile('#import \"([^\"]*)\"')\nclass FileWriter(contextlib.AbstractContextManager):",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "documentation": {}
    },
    {
        "label": "IMPORT_LINE_REGEXP",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "peekOfCode": "IMPORT_LINE_REGEXP = re.compile('#import \"([^\"]*)\"')\nclass FileWriter(contextlib.AbstractContextManager):\n  \"\"\"\n  FileWriter is a file-like object that only write data to disk if changed.\n  This object implements the context manager protocols and thus can be used\n  in a with-clause. The data is written to disk when the context is exited,\n  and only if the content is different from current file content.\n    with FileWriter(path) as stream:\n      stream.write('...')\n  If the with-clause ends with an exception, no data is written to the disk",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.darwin.swiftc",
        "documentation": {}
    },
    {
        "label": "FindFileInEnvList",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.win.setup_toolchain",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.win.setup_toolchain",
        "peekOfCode": "def FindFileInEnvList(env, env_name, separator, file_name, optional=False):\n  parts = env[env_name].split(separator)\n  for path in parts:\n    if os.path.exists(os.path.join(path, file_name)):\n      return os.path.realpath(path)\n  assert optional, \"%s is not found in %s:\\n%s\\nCheck if it is installed.\" % (\n      file_name, env_name, '\\n'.join(parts))\n  return ''\ndef main():\n  if len(sys.argv) != 7:",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.win.setup_toolchain",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.win.setup_toolchain",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.win.setup_toolchain",
        "peekOfCode": "def main():\n  if len(sys.argv) != 7:\n    print('Usage setup_toolchain.py '\n          '<visual studio path> <win sdk path> '\n          '<runtime dirs> <target_os> <target_cpu> '\n          '<environment block name|none>')\n    sys.exit(2)\n  # toolchain_root and win_sdk_path are only read if the hermetic Windows\n  # toolchain is set, that is if DEPOT_TOOLS_WIN_TOOLCHAIN is not set to 0.\n  # With the hermetic Windows toolchain, the visual studio path in argv[1]",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.win.setup_toolchain",
        "documentation": {}
    },
    {
        "label": "SCRIPT_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.win.setup_toolchain",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.win.setup_toolchain",
        "peekOfCode": "SCRIPT_DIR = os.path.dirname(__file__)\nSDK_VERSION = '10.0.22621.0'\ndef _ExtractImportantEnvironment(output_of_set):\n  \"\"\"Extracts environment variables required for the toolchain to run from\n  a textual dump output by the cmd.exe 'set' command.\"\"\"\n  envvars_to_save = (\n      'cipd_cache_dir', # needed by vpython\n      'homedrive', # needed by vpython\n      'homepath', # needed by vpython\n      'goma_.*', # TODO(scottmg): This is ugly, but needed for goma.",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.win.setup_toolchain",
        "documentation": {}
    },
    {
        "label": "SDK_VERSION",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.win.setup_toolchain",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.win.setup_toolchain",
        "peekOfCode": "SDK_VERSION = '10.0.22621.0'\ndef _ExtractImportantEnvironment(output_of_set):\n  \"\"\"Extracts environment variables required for the toolchain to run from\n  a textual dump output by the cmd.exe 'set' command.\"\"\"\n  envvars_to_save = (\n      'cipd_cache_dir', # needed by vpython\n      'homedrive', # needed by vpython\n      'homepath', # needed by vpython\n      'goma_.*', # TODO(scottmg): This is ugly, but needed for goma.\n      'include',",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.win.setup_toolchain",
        "documentation": {}
    },
    {
        "label": "WinTool",
        "kind": 6,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.win.tool_wrapper",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.win.tool_wrapper",
        "peekOfCode": "class WinTool(object):\n  \"\"\"This class performs all the Windows tooling steps. The methods can either\n  be executed directly, or dispatched from an argument list.\"\"\"\n  def _UseSeparateMspdbsrv(self, env, args):\n    \"\"\"Allows to use a unique instance of mspdbsrv.exe per linker instead of a\n    shared one.\"\"\"\n    if len(args) < 1:\n      raise Exception(\"Not enough arguments\")\n    if args[0] != 'link.exe':\n      return",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.win.tool_wrapper",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.win.tool_wrapper",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.win.tool_wrapper",
        "peekOfCode": "def main(args):\n  exit_code = WinTool().Dispatch(args)\n  if exit_code is not None:\n    sys.exit(exit_code)\nclass WinTool(object):\n  \"\"\"This class performs all the Windows tooling steps. The methods can either\n  be executed directly, or dispatched from an argument list.\"\"\"\n  def _UseSeparateMspdbsrv(self, env, args):\n    \"\"\"Allows to use a unique instance of mspdbsrv.exe per linker instead of a\n    shared one.\"\"\"",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.win.tool_wrapper",
        "documentation": {}
    },
    {
        "label": "BASE_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.win.tool_wrapper",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.win.tool_wrapper",
        "peekOfCode": "BASE_DIR = os.path.dirname(os.path.abspath(__file__))\n# A regex matching an argument corresponding to the output filename passed to\n# link.exe.\n_LINK_EXE_OUT_ARG = re.compile('/OUT:(?P<out>.+)$', re.IGNORECASE)\ndef main(args):\n  exit_code = WinTool().Dispatch(args)\n  if exit_code is not None:\n    sys.exit(exit_code)\nclass WinTool(object):\n  \"\"\"This class performs all the Windows tooling steps. The methods can either",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.win.tool_wrapper",
        "documentation": {}
    },
    {
        "label": "_LINK_EXE_OUT_ARG",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.win.tool_wrapper",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.win.tool_wrapper",
        "peekOfCode": "_LINK_EXE_OUT_ARG = re.compile('/OUT:(?P<out>.+)$', re.IGNORECASE)\ndef main(args):\n  exit_code = WinTool().Dispatch(args)\n  if exit_code is not None:\n    sys.exit(exit_code)\nclass WinTool(object):\n  \"\"\"This class performs all the Windows tooling steps. The methods can either\n  be executed directly, or dispatched from an argument list.\"\"\"\n  def _UseSeparateMspdbsrv(self, env, args):\n    \"\"\"Allows to use a unique instance of mspdbsrv.exe per linker instead of a",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.win.tool_wrapper",
        "documentation": {}
    },
    {
        "label": "interleave_args",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.clang_static_analyzer_wrapper",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.clang_static_analyzer_wrapper",
        "peekOfCode": "def interleave_args(args, token):\n  return list(sum(list(zip([token] * len(args), args)), ()))\ndef main():\n  parser = argparse.ArgumentParser()\n  parser.add_argument('--mode',\n                      choices=['clang', 'cl'],\n                      required=True,\n                      help='Specifies the compiler argument convention to use.')\n  parser.add_argument('args', nargs=argparse.REMAINDER)\n  parsed_args = parser.parse_args()",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.clang_static_analyzer_wrapper",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.clang_static_analyzer_wrapper",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.clang_static_analyzer_wrapper",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser()\n  parser.add_argument('--mode',\n                      choices=['clang', 'cl'],\n                      required=True,\n                      help='Specifies the compiler argument convention to use.')\n  parser.add_argument('args', nargs=argparse.REMAINDER)\n  parsed_args = parser.parse_args()\n  prefix = '-Xclang' if parsed_args.mode == 'cl' else '-Xanalyzer'\n  cmd = parsed_args.args + analyzer_enable_flags + \\",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.clang_static_analyzer_wrapper",
        "documentation": {}
    },
    {
        "label": "analyzer_enable_flags",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.clang_static_analyzer_wrapper",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.clang_static_analyzer_wrapper",
        "peekOfCode": "analyzer_enable_flags = [\n    '--analyze',\n]\n# Flags used to configure the analyzer's behavior.\nanalyzer_option_flags = [\n    '-fdiagnostics-show-option',\n    '-analyzer-checker=cplusplus',\n    '-analyzer-opt-analyze-nested-blocks',\n    '-analyzer-output=text',\n    '-analyzer-config',",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.clang_static_analyzer_wrapper",
        "documentation": {}
    },
    {
        "label": "analyzer_option_flags",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.clang_static_analyzer_wrapper",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.clang_static_analyzer_wrapper",
        "peekOfCode": "analyzer_option_flags = [\n    '-fdiagnostics-show-option',\n    '-analyzer-checker=cplusplus',\n    '-analyzer-opt-analyze-nested-blocks',\n    '-analyzer-output=text',\n    '-analyzer-config',\n    'suppress-c++-stdlib=true',\n# List of checkers to execute.\n# The full list of checkers can be found at\n# https://clang-analyzer.llvm.org/available_checks.html.",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.clang_static_analyzer_wrapper",
        "documentation": {}
    },
    {
        "label": "CommandToRun",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.wrapper_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.wrapper_utils",
        "peekOfCode": "def CommandToRun(command):\n  \"\"\"Generates commands compatible with Windows.\n  When running on a Windows host and using a toolchain whose tools are\n  actually wrapper scripts (i.e. .bat files on Windows) rather than binary\n  executables, the |command| to run has to be prefixed with this magic.\n  The GN toolchain definitions take care of that for when GN/Ninja is\n  running the tool directly.  When that command is passed in to this\n  script, it appears as a unitary string but needs to be split up so that\n  just 'cmd' is the actual command given to Python's subprocess module.\n  Args:",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.wrapper_utils",
        "documentation": {}
    },
    {
        "label": "RunLinkWithOptionalMapFile",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.wrapper_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.wrapper_utils",
        "peekOfCode": "def RunLinkWithOptionalMapFile(command, env=None, map_file=None):\n  \"\"\"Runs the given command, adding in -Wl,-Map when |map_file| is given.\n  Also takes care of gzipping when |map_file| ends with .gz.\n  Args:\n    command: List of arguments comprising the command.\n    env: Environment variables.\n    map_file: Path to output map_file.\n  Returns:\n    The exit code of running |command|.\n  \"\"\"",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.wrapper_utils",
        "documentation": {}
    },
    {
        "label": "CaptureCommandStderr",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.wrapper_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.wrapper_utils",
        "peekOfCode": "def CaptureCommandStderr(command, env=None):\n  \"\"\"Returns the stderr of a command.\n  Args:\n    command: A list containing the command and arguments.\n    env: Environment variables for the new process.\n  \"\"\"\n  child = subprocess.Popen(command, stderr=subprocess.PIPE, env=env)\n  _, stderr = child.communicate()\n  return child.returncode, stderr",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.wrapper_utils",
        "documentation": {}
    },
    {
        "label": "_BAT_PREFIX",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.toolchain.wrapper_utils",
        "description": ".fvm.flutter_sdk.engine.src.build.toolchain.wrapper_utils",
        "peekOfCode": "_BAT_PREFIX = 'cmd /c call '\ndef _GzipThenDelete(src_path, dest_path):\n  # Results for Android map file with GCC on a z620:\n  # Uncompressed: 207MB\n  # gzip -9: 16.4MB, takes 8.7 seconds.\n  # gzip -1: 21.8MB, takes 2.0 seconds.\n  # Piping directly from the linker via -print-map (or via -Map with a fifo)\n  # adds a whopping 30-45 seconds!\n  with open(src_path, 'rb') as f_in, gzip.GzipFile(dest_path, 'wb', 1) as f_out:\n    shutil.copyfileobj(f_in, f_out)",
        "detail": ".fvm.flutter_sdk.engine.src.build.toolchain.wrapper_utils",
        "documentation": {}
    },
    {
        "label": "extract_gn_build_commands",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.clobber",
        "description": ".fvm.flutter_sdk.engine.src.build.clobber",
        "peekOfCode": "def extract_gn_build_commands(build_ninja_file):\n  \"\"\"Extracts from a build.ninja the commands to run GN.\n  The commands to run GN are the gn rule and build.ninja build step at the\n  top of the build.ninja file. We want to keep these when deleting GN builds\n  since we want to preserve the command-line flags to GN.\n  On error, returns the empty string.\"\"\"\n  result = \"\"\n  with open(build_ninja_file, 'r') as f:\n    # Read until the second blank line. The first thing GN writes to the file\n    # is the \"rule gn\" and the second is the section for \"build build.ninja\",",
        "detail": ".fvm.flutter_sdk.engine.src.build.clobber",
        "documentation": {}
    },
    {
        "label": "delete_build_dir",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.clobber",
        "description": ".fvm.flutter_sdk.engine.src.build.clobber",
        "peekOfCode": "def delete_build_dir(build_dir):\n  # GN writes a build.ninja.d file. Note that not all GN builds have args.gn.\n  build_ninja_d_file = os.path.join(build_dir, 'build.ninja.d')\n  if not os.path.exists(build_ninja_d_file):\n    shutil.rmtree(build_dir)\n    return\n  # GN builds aren't automatically regenerated when you sync. To avoid\n  # messing with the GN workflow, erase everything but the args file, and\n  # write a dummy build.ninja file that will automatically rerun GN the next\n  # time Ninja is run.",
        "detail": ".fvm.flutter_sdk.engine.src.build.clobber",
        "documentation": {}
    },
    {
        "label": "clobber",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.clobber",
        "description": ".fvm.flutter_sdk.engine.src.build.clobber",
        "peekOfCode": "def clobber(out_dir):\n  \"\"\"Clobber contents of build directory.\n  Don't delete the directory itself: some checkouts have the build directory\n  mounted.\"\"\"\n  for f in os.listdir(out_dir):\n    path = os.path.join(out_dir, f)\n    if os.path.isfile(path):\n      os.unlink(path)\n    elif os.path.isdir(path):\n      delete_build_dir(path)",
        "detail": ".fvm.flutter_sdk.engine.src.build.clobber",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.clobber",
        "description": ".fvm.flutter_sdk.engine.src.build.clobber",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser()\n  parser.add_argument('out_dir', help='The output directory to clobber')\n  args = parser.parse_args()\n  clobber(args.out_dir)\n  return 0\nif __name__ == '__main__':\n  sys.exit(main())",
        "detail": ".fvm.flutter_sdk.engine.src.build.clobber",
        "documentation": {}
    },
    {
        "label": "command",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.clobber",
        "description": ".fvm.flutter_sdk.engine.src.build.clobber",
        "peekOfCode": "command = gn -q gen //out/%s/\ndescription = Regenerating ninja files\nbuild build.ninja: gn\ngenerator = 1\ndepfile = build.ninja.d\n''' % (os.path.split(build_dir)[1]))\n  # Write a .d file for the build which references a nonexistant file. This\n  # will make Ninja always mark the build as dirty.\n  with open(build_ninja_d_file, 'w') as f:\n    f.write('build.ninja: nonexistant_file.gn\\n')",
        "detail": ".fvm.flutter_sdk.engine.src.build.clobber",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.clobber",
        "description": ".fvm.flutter_sdk.engine.src.build.clobber",
        "peekOfCode": "description = Regenerating ninja files\nbuild build.ninja: gn\ngenerator = 1\ndepfile = build.ninja.d\n''' % (os.path.split(build_dir)[1]))\n  # Write a .d file for the build which references a nonexistant file. This\n  # will make Ninja always mark the build as dirty.\n  with open(build_ninja_d_file, 'w') as f:\n    f.write('build.ninja: nonexistant_file.gn\\n')\ndef clobber(out_dir):",
        "detail": ".fvm.flutter_sdk.engine.src.build.clobber",
        "documentation": {}
    },
    {
        "label": "generator",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.clobber",
        "description": ".fvm.flutter_sdk.engine.src.build.clobber",
        "peekOfCode": "generator = 1\ndepfile = build.ninja.d\n''' % (os.path.split(build_dir)[1]))\n  # Write a .d file for the build which references a nonexistant file. This\n  # will make Ninja always mark the build as dirty.\n  with open(build_ninja_d_file, 'w') as f:\n    f.write('build.ninja: nonexistant_file.gn\\n')\ndef clobber(out_dir):\n  \"\"\"Clobber contents of build directory.\n  Don't delete the directory itself: some checkouts have the build directory",
        "detail": ".fvm.flutter_sdk.engine.src.build.clobber",
        "documentation": {}
    },
    {
        "label": "depfile",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.clobber",
        "description": ".fvm.flutter_sdk.engine.src.build.clobber",
        "peekOfCode": "depfile = build.ninja.d\n''' % (os.path.split(build_dir)[1]))\n  # Write a .d file for the build which references a nonexistant file. This\n  # will make Ninja always mark the build as dirty.\n  with open(build_ninja_d_file, 'w') as f:\n    f.write('build.ninja: nonexistant_file.gn\\n')\ndef clobber(out_dir):\n  \"\"\"Clobber contents of build directory.\n  Don't delete the directory itself: some checkouts have the build directory\n  mounted.\"\"\"",
        "detail": ".fvm.flutter_sdk.engine.src.build.clobber",
        "documentation": {}
    },
    {
        "label": "Usage",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.compiler_version",
        "description": ".fvm.flutter_sdk.engine.src.build.compiler_version",
        "peekOfCode": "def Usage(program_name):\n  print('%s MODE TOOL' % os.path.basename(program_name))\n  print('MODE: host or target.')\n  print('TOOL: assembler or compiler or linker.')\n  return 1\ndef ParseArgs(args):\n  if len(args) != 2:\n    raise Exception('Invalid number of arguments')\n  mode = args[0]\n  tool = args[1]",
        "detail": ".fvm.flutter_sdk.engine.src.build.compiler_version",
        "documentation": {}
    },
    {
        "label": "ParseArgs",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.compiler_version",
        "description": ".fvm.flutter_sdk.engine.src.build.compiler_version",
        "peekOfCode": "def ParseArgs(args):\n  if len(args) != 2:\n    raise Exception('Invalid number of arguments')\n  mode = args[0]\n  tool = args[1]\n  if mode not in ('host', 'target'):\n    raise Exception('Invalid mode: %s' % mode)\n  if tool not in ('assembler', 'compiler', 'linker'):\n    raise Exception('Invalid tool: %s' % tool)\n  return mode, tool",
        "detail": ".fvm.flutter_sdk.engine.src.build.compiler_version",
        "documentation": {}
    },
    {
        "label": "GetEnvironFallback",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.compiler_version",
        "description": ".fvm.flutter_sdk.engine.src.build.compiler_version",
        "peekOfCode": "def GetEnvironFallback(var_list, default):\n  \"\"\"Look up an environment variable from a possible list of variable names.\"\"\"\n  for var in var_list:\n    if var in os.environ:\n      return os.environ[var]\n  return default\ndef GetVersion(compiler, tool):\n  tool_output = tool_error = None\n  cache_key = (compiler, tool)\n  cached_version = compiler_version_cache.get(cache_key)",
        "detail": ".fvm.flutter_sdk.engine.src.build.compiler_version",
        "documentation": {}
    },
    {
        "label": "GetVersion",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.compiler_version",
        "description": ".fvm.flutter_sdk.engine.src.build.compiler_version",
        "peekOfCode": "def GetVersion(compiler, tool):\n  tool_output = tool_error = None\n  cache_key = (compiler, tool)\n  cached_version = compiler_version_cache.get(cache_key)\n  if cached_version:\n    return cached_version\n  try:\n    # Note that compiler could be something tricky like \"distcc g++\".\n    if tool == \"compiler\":\n      compiler = compiler + \" -dumpversion\"",
        "detail": ".fvm.flutter_sdk.engine.src.build.compiler_version",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.compiler_version",
        "description": ".fvm.flutter_sdk.engine.src.build.compiler_version",
        "peekOfCode": "def main(args):\n  try:\n    (mode, tool) = ParseArgs(args[1:])\n  except Exception as e:\n    sys.stderr.write(e.message + '\\n\\n')\n    return Usage(args[0])\n  ret_code, result = ExtractVersion(mode, tool)\n  if ret_code == 0:\n    print(result)\n  return ret_code",
        "detail": ".fvm.flutter_sdk.engine.src.build.compiler_version",
        "documentation": {}
    },
    {
        "label": "DoMain",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.compiler_version",
        "description": ".fvm.flutter_sdk.engine.src.build.compiler_version",
        "peekOfCode": "def DoMain(args):\n  \"\"\"Hook to be called from gyp without starting a separate python\n  interpreter.\"\"\"\n  (mode, tool) = ParseArgs(args)\n  ret_code, result = ExtractVersion(mode, tool)\n  if ret_code == 0:\n    return result\n  raise Exception(\"Failed to extract compiler version for args: %s\" % args)\ndef ExtractVersion(mode, tool):\n  # Check if various CXX environment variables exist and use them if they",
        "detail": ".fvm.flutter_sdk.engine.src.build.compiler_version",
        "documentation": {}
    },
    {
        "label": "ExtractVersion",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.compiler_version",
        "description": ".fvm.flutter_sdk.engine.src.build.compiler_version",
        "peekOfCode": "def ExtractVersion(mode, tool):\n  # Check if various CXX environment variables exist and use them if they\n  # exist. The preferences and fallback order is a close approximation of\n  # GenerateOutputForConfig() in GYP's ninja generator.\n  # The main difference being not supporting GYP's make_global_settings.\n  environments = ['CXX_target', 'CXX']\n  if mode == 'host':\n    environments = ['CXX_host'] + environments;\n  compiler = GetEnvironFallback(environments, 'c++')\n  if compiler:",
        "detail": ".fvm.flutter_sdk.engine.src.build.compiler_version",
        "documentation": {}
    },
    {
        "label": "compiler_version_cache",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.compiler_version",
        "description": ".fvm.flutter_sdk.engine.src.build.compiler_version",
        "peekOfCode": "compiler_version_cache = {}  # Map from (compiler, tool) -> version.\ndef Usage(program_name):\n  print('%s MODE TOOL' % os.path.basename(program_name))\n  print('MODE: host or target.')\n  print('TOOL: assembler or compiler or linker.')\n  return 1\ndef ParseArgs(args):\n  if len(args) != 2:\n    raise Exception('Invalid number of arguments')\n  mode = args[0]",
        "detail": ".fvm.flutter_sdk.engine.src.build.compiler_version",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.dir_exists",
        "description": ".fvm.flutter_sdk.engine.src.build.dir_exists",
        "peekOfCode": "def main():\n  sys.stdout.write(_is_dir(sys.argv[1]))\n  return 0\ndef _is_dir(dir_name):\n  return str(os.path.isdir(dir_name))\ndef DoMain(args):\n  \"\"\"Hook to be called from gyp without starting a separate python\n  interpreter.\"\"\"\n  return _is_dir(args[0])\nif __name__ == '__main__':",
        "detail": ".fvm.flutter_sdk.engine.src.build.dir_exists",
        "documentation": {}
    },
    {
        "label": "DoMain",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.dir_exists",
        "description": ".fvm.flutter_sdk.engine.src.build.dir_exists",
        "peekOfCode": "def DoMain(args):\n  \"\"\"Hook to be called from gyp without starting a separate python\n  interpreter.\"\"\"\n  return _is_dir(args[0])\nif __name__ == '__main__':\n  sys.exit(main())",
        "detail": ".fvm.flutter_sdk.engine.src.build.dir_exists",
        "documentation": {}
    },
    {
        "label": "IsRealDepotTools",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.find_depot_tools",
        "description": ".fvm.flutter_sdk.engine.src.build.find_depot_tools",
        "peekOfCode": "def IsRealDepotTools(path):\n  expanded_path = os.path.expanduser(path)\n  return os.path.isfile(os.path.join(expanded_path, 'gclient.py'))\ndef add_depot_tools_to_path():\n  \"\"\"Search for depot_tools and add it to sys.path.\"\"\"\n  # First, check if we have a DEPS'd in \"depot_tools\".\n  deps_depot_tools = os.path.join(SRC, 'flutter', 'third_party', 'depot_tools')\n  if IsRealDepotTools(deps_depot_tools):\n    # Put the pinned version at the start of the sys.path, in case there\n    # are other non-pinned versions already on the sys.path.",
        "detail": ".fvm.flutter_sdk.engine.src.build.find_depot_tools",
        "documentation": {}
    },
    {
        "label": "add_depot_tools_to_path",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.find_depot_tools",
        "description": ".fvm.flutter_sdk.engine.src.build.find_depot_tools",
        "peekOfCode": "def add_depot_tools_to_path():\n  \"\"\"Search for depot_tools and add it to sys.path.\"\"\"\n  # First, check if we have a DEPS'd in \"depot_tools\".\n  deps_depot_tools = os.path.join(SRC, 'flutter', 'third_party', 'depot_tools')\n  if IsRealDepotTools(deps_depot_tools):\n    # Put the pinned version at the start of the sys.path, in case there\n    # are other non-pinned versions already on the sys.path.\n    sys.path.insert(0, deps_depot_tools)\n    return deps_depot_tools\n  # Then look if depot_tools is already in PYTHONPATH.",
        "detail": ".fvm.flutter_sdk.engine.src.build.find_depot_tools",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.find_depot_tools",
        "description": ".fvm.flutter_sdk.engine.src.build.find_depot_tools",
        "peekOfCode": "def main():\n  if DEPOT_TOOLS_PATH is None:\n    return 1\n  print(DEPOT_TOOLS_PATH)\n  return 0\nif __name__ == '__main__':\n  sys.exit(main())",
        "detail": ".fvm.flutter_sdk.engine.src.build.find_depot_tools",
        "documentation": {}
    },
    {
        "label": "SRC",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.find_depot_tools",
        "description": ".fvm.flutter_sdk.engine.src.build.find_depot_tools",
        "peekOfCode": "SRC = os.path.abspath(os.path.join(os.path.dirname(__file__), os.pardir))\ndef IsRealDepotTools(path):\n  expanded_path = os.path.expanduser(path)\n  return os.path.isfile(os.path.join(expanded_path, 'gclient.py'))\ndef add_depot_tools_to_path():\n  \"\"\"Search for depot_tools and add it to sys.path.\"\"\"\n  # First, check if we have a DEPS'd in \"depot_tools\".\n  deps_depot_tools = os.path.join(SRC, 'flutter', 'third_party', 'depot_tools')\n  if IsRealDepotTools(deps_depot_tools):\n    # Put the pinned version at the start of the sys.path, in case there",
        "detail": ".fvm.flutter_sdk.engine.src.build.find_depot_tools",
        "documentation": {}
    },
    {
        "label": "DEPOT_TOOLS_PATH",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.find_depot_tools",
        "description": ".fvm.flutter_sdk.engine.src.build.find_depot_tools",
        "peekOfCode": "DEPOT_TOOLS_PATH = add_depot_tools_to_path()\n# pylint: disable=W0611\nimport breakpad\ndef main():\n  if DEPOT_TOOLS_PATH is None:\n    return 1\n  print(DEPOT_TOOLS_PATH)\n  return 0\nif __name__ == '__main__':\n  sys.exit(main())",
        "detail": ".fvm.flutter_sdk.engine.src.build.find_depot_tools",
        "documentation": {}
    },
    {
        "label": "GNError",
        "kind": 6,
        "importPath": ".fvm.flutter_sdk.engine.src.build.gn_helpers",
        "description": ".fvm.flutter_sdk.engine.src.build.gn_helpers",
        "peekOfCode": "class GNError(Exception):\n  pass\n# Computes ASCII code of an element of encoded Python 2 str / Python 3 bytes.\n_Ord = ord if sys.version_info.major < 3 else lambda c: c\ndef _TranslateToGnChars(s):\n  for decoded_ch in s.encode('utf-8'):  # str in Python 2, bytes in Python 3.\n    code = _Ord(decoded_ch)  # int\n    if code in (34, 36, 92):  # For '\"', '$', or '\\\\'.\n      yield '\\\\' + chr(code)\n    elif 32 <= code < 127:",
        "detail": ".fvm.flutter_sdk.engine.src.build.gn_helpers",
        "documentation": {}
    },
    {
        "label": "ToGNString",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.gn_helpers",
        "description": ".fvm.flutter_sdk.engine.src.build.gn_helpers",
        "peekOfCode": "def ToGNString(value, pretty=False):\n  \"\"\"Returns a stringified GN equivalent of a Python value.\n  Args:\n    value: The Python value to convert.\n    pretty: Whether to pretty print. If true, then non-empty lists are rendered\n        recursively with one item per line, with indents. Otherwise lists are\n        rendered without new line.\n  Returns:\n    The stringified GN equivalent to |value|.\n  Raises:",
        "detail": ".fvm.flutter_sdk.engine.src.build.gn_helpers",
        "documentation": {}
    },
    {
        "label": "_Ord",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.gn_helpers",
        "description": ".fvm.flutter_sdk.engine.src.build.gn_helpers",
        "peekOfCode": "_Ord = ord if sys.version_info.major < 3 else lambda c: c\ndef _TranslateToGnChars(s):\n  for decoded_ch in s.encode('utf-8'):  # str in Python 2, bytes in Python 3.\n    code = _Ord(decoded_ch)  # int\n    if code in (34, 36, 92):  # For '\"', '$', or '\\\\'.\n      yield '\\\\' + chr(code)\n    elif 32 <= code < 127:\n      yield chr(code)\n    else:\n      yield '$0x%02X' % code",
        "detail": ".fvm.flutter_sdk.engine.src.build.gn_helpers",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.gn_run_binary",
        "description": ".fvm.flutter_sdk.engine.src.build.gn_run_binary",
        "peekOfCode": "path = './' + sys.argv[1]\n# The rest of the arguements are passed directly to the executable.\nargs = [path] + sys.argv[2:]\ntry:\n  subprocess.check_output(args, stderr=subprocess.STDOUT)\nexcept subprocess.CalledProcessError as ex:\n  print(\"Command failed: \" + ' '.join(args))\n  print(\"exitCode: \" + str(ex.returncode))\n  print(ex.output.decode('utf-8', errors='replace'))\n  sys.exit(ex.returncode)",
        "detail": ".fvm.flutter_sdk.engine.src.build.gn_run_binary",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.gn_run_binary",
        "description": ".fvm.flutter_sdk.engine.src.build.gn_run_binary",
        "peekOfCode": "args = [path] + sys.argv[2:]\ntry:\n  subprocess.check_output(args, stderr=subprocess.STDOUT)\nexcept subprocess.CalledProcessError as ex:\n  print(\"Command failed: \" + ' '.join(args))\n  print(\"exitCode: \" + str(ex.returncode))\n  print(ex.output.decode('utf-8', errors='replace'))\n  sys.exit(ex.returncode)",
        "detail": ".fvm.flutter_sdk.engine.src.build.gn_run_binary",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.gn_run_malioc",
        "description": ".fvm.flutter_sdk.engine.src.build.gn_run_malioc",
        "peekOfCode": "path = './' + sys.argv[1]\nmalioc_output = sys.argv[2]\n# The rest of the arguements are passed directly to the executable.\nargs = [path, '--output', malioc_output] + sys.argv[3:]\ntry:\n  subprocess.check_output(args, stderr=subprocess.STDOUT)\nexcept subprocess.CalledProcessError as ex:\n  print(ex.output.decode('utf-8', errors='replace'))\n  if os.path.exists(malioc_output):\n    with open(malioc_output, 'r') as malioc_file:",
        "detail": ".fvm.flutter_sdk.engine.src.build.gn_run_malioc",
        "documentation": {}
    },
    {
        "label": "malioc_output",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.gn_run_malioc",
        "description": ".fvm.flutter_sdk.engine.src.build.gn_run_malioc",
        "peekOfCode": "malioc_output = sys.argv[2]\n# The rest of the arguements are passed directly to the executable.\nargs = [path, '--output', malioc_output] + sys.argv[3:]\ntry:\n  subprocess.check_output(args, stderr=subprocess.STDOUT)\nexcept subprocess.CalledProcessError as ex:\n  print(ex.output.decode('utf-8', errors='replace'))\n  if os.path.exists(malioc_output):\n    with open(malioc_output, 'r') as malioc_file:\n      malioc_json = malioc_file.read()",
        "detail": ".fvm.flutter_sdk.engine.src.build.gn_run_malioc",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.gn_run_malioc",
        "description": ".fvm.flutter_sdk.engine.src.build.gn_run_malioc",
        "peekOfCode": "args = [path, '--output', malioc_output] + sys.argv[3:]\ntry:\n  subprocess.check_output(args, stderr=subprocess.STDOUT)\nexcept subprocess.CalledProcessError as ex:\n  print(ex.output.decode('utf-8', errors='replace'))\n  if os.path.exists(malioc_output):\n    with open(malioc_output, 'r') as malioc_file:\n      malioc_json = malioc_file.read()\n    print('malioc output:')\n    # Attempt to pretty print the json output, but fall back to printing the",
        "detail": ".fvm.flutter_sdk.engine.src.build.gn_run_malioc",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.ls",
        "description": ".fvm.flutter_sdk.engine.src.build.ls",
        "peekOfCode": "def main(target_directory, file_extension):\n  for root, dirs, files in os.walk(target_directory):\n    files = [f for f in files if not f[0] == '.']\n    dirs[:] = [d for d in dirs if not d[0] == '.']\n    for f in files:\n      if file_extension is None or os.path.splitext(f)[-1] == file_extension:\n        path = os.path.join(root, f)\n        print(path)\nif __name__ == '__main__':\n  parser = argparse.ArgumentParser(",
        "detail": ".fvm.flutter_sdk.engine.src.build.ls",
        "documentation": {}
    },
    {
        "label": "SetEnvironmentAndGetRuntimeDllDirs",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "description": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "peekOfCode": "def SetEnvironmentAndGetRuntimeDllDirs():\n  \"\"\"Sets up os.environ to use the depot_tools VS toolchain with gyp, and\n  returns the location of the VC runtime DLLs so they can be copied into\n  the output directory after gyp generation.\n  Return value is [x64path, x86path, 'Arm64Unused'] or None. arm64path is\n  generated separately because there are multiple folders for the arm64 VC\n  runtime.\n  \"\"\"\n  vs_runtime_dll_dirs = None\n  depot_tools_win_toolchain = \\",
        "detail": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "documentation": {}
    },
    {
        "label": "GetVisualStudioVersion",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "description": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "peekOfCode": "def GetVisualStudioVersion():\n  \"\"\"Return best available version of Visual Studio.\n  \"\"\"\n  env_version = os.environ.get('GYP_MSVS_VERSION')\n  if env_version:\n    return env_version\n  supported_versions = list(MSVS_VERSIONS.keys())\n  # VS installed in depot_tools for Googlers\n  if bool(int(os.environ.get('DEPOT_TOOLS_WIN_TOOLCHAIN', '1'))):\n    return list(supported_versions)[0]",
        "detail": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "documentation": {}
    },
    {
        "label": "DetectVisualStudioPath",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "description": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "peekOfCode": "def DetectVisualStudioPath():\n  \"\"\"Return path to the GYP_MSVS_VERSION of Visual Studio.\n  \"\"\"\n  # Note that this code is used from\n  # build/toolchain/win/setup_toolchain.py as well.\n  version_as_year = GetVisualStudioVersion()\n  # The VC++ >=2017 install location needs to be located using COM instead of\n  # the registry. For details see:\n  # https://blogs.msdn.microsoft.com/heaths/2016/09/15/changes-to-visual-studio-15-setup/\n  # For now we use a hardcoded default with an environment variable override.",
        "detail": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "documentation": {}
    },
    {
        "label": "FindVCComponentRoot",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "description": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "peekOfCode": "def FindVCComponentRoot(component):\n  \"\"\"Find the most recent Tools or Redist or other directory in an MSVC install.\n  Typical results are {toolchain_root}/VC/{component}/MSVC/{x.y.z}. The {x.y.z}\n  version number part changes frequently so the highest version number found is\n  used.\n  \"\"\"\n  SetEnvironmentAndGetRuntimeDllDirs()\n  assert ('GYP_MSVS_OVERRIDE_PATH' in os.environ)\n  vc_component_msvc_root = os.path.join(os.environ['GYP_MSVS_OVERRIDE_PATH'],\n      'VC', component, 'MSVC')",
        "detail": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "documentation": {}
    },
    {
        "label": "FindVCRedistRoot",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "description": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "peekOfCode": "def FindVCRedistRoot():\n  \"\"\"In >=VS2017, Redist binaries are located in\n  {toolchain_root}/VC/Redist/MSVC/{x.y.z}/{target_cpu}/.\n  This returns the '{toolchain_root}/VC/Redist/MSVC/{x.y.z}/' path.\n  \"\"\"\n  return FindVCComponentRoot('Redist')\ndef _CopyRuntime(target_dir, source_dir, target_cpu, debug):\n  \"\"\"Copy the VS runtime DLLs, only if the target doesn't exist, but the target\n  directory does exist. Handles VS 2015, 2017 and 2019.\"\"\"\n  suffix = 'd.dll' if debug else '.dll'",
        "detail": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "documentation": {}
    },
    {
        "label": "CopyDlls",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "description": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "peekOfCode": "def CopyDlls(target_dir, configuration, target_cpu):\n  \"\"\"Copy the VS runtime DLLs into the requested directory as needed.\n  configuration is one of 'Debug' or 'Release'.\n  target_cpu is one of 'x86', 'x64' or 'arm64'.\n  The debug configuration gets both the debug and release DLLs; the\n  release config only the latter.\n  \"\"\"\n  vs_runtime_dll_dirs = SetEnvironmentAndGetRuntimeDllDirs()\n  if not vs_runtime_dll_dirs:\n    return",
        "detail": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "documentation": {}
    },
    {
        "label": "ShouldUpdateToolchain",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "description": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "peekOfCode": "def ShouldUpdateToolchain():\n  \"\"\"Check if the toolchain should be upgraded.\"\"\"\n  if not os.path.exists(json_data_file):\n    return True\n  with open(json_data_file, 'r') as tempf:\n    toolchain_data = json.load(tempf)\n  version = toolchain_data['version']\n  env_version = GetVisualStudioVersion()\n  # If there's a mismatch between the version set in the environment and the one\n  # in the json file then the toolchain should be updated.",
        "detail": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "documentation": {}
    },
    {
        "label": "Update",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "description": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "peekOfCode": "def Update(force=False, no_download=False):\n  \"\"\"Requests an update of the toolchain to the specific hashes we have at\n  this revision. The update outputs a .json of the various configuration\n  information required to pass to gyp which we use in |GetToolchainDir()|.\n  If no_download is true then the toolchain will be configured if present but\n  will not be downloaded.\n  \"\"\"\n  if force != False and force != '--force':\n    print('Unknown parameter \"%s\"' % force, file=sys.stderr)\n    return 1",
        "detail": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "documentation": {}
    },
    {
        "label": "NormalizePath",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "description": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "peekOfCode": "def NormalizePath(path):\n  while path.endswith('\\\\'):\n    path = path[:-1]\n  return path\ndef SetEnvironmentAndGetSDKDir():\n  \"\"\"Gets location information about the current sdk (must have been\n  previously updated by 'update'). This is used for the GN build.\"\"\"\n  SetEnvironmentAndGetRuntimeDllDirs()\n  # If WINDOWSSDKDIR is not set, search the default SDK path and set it.\n  if not 'WINDOWSSDKDIR' in os.environ:",
        "detail": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "documentation": {}
    },
    {
        "label": "SetEnvironmentAndGetSDKDir",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "description": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "peekOfCode": "def SetEnvironmentAndGetSDKDir():\n  \"\"\"Gets location information about the current sdk (must have been\n  previously updated by 'update'). This is used for the GN build.\"\"\"\n  SetEnvironmentAndGetRuntimeDllDirs()\n  # If WINDOWSSDKDIR is not set, search the default SDK path and set it.\n  if not 'WINDOWSSDKDIR' in os.environ:\n    default_sdk_path = os.path.expandvars('%ProgramFiles(x86)%'\n                                          '\\\\Windows Kits\\\\10')\n    if os.path.isdir(default_sdk_path):\n      os.environ['WINDOWSSDKDIR'] = default_sdk_path",
        "detail": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "documentation": {}
    },
    {
        "label": "GetToolchainDir",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "description": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "peekOfCode": "def GetToolchainDir():\n  \"\"\"Gets location information about the current toolchain (must have been\n  previously updated by 'update'). This is used for the GN build.\"\"\"\n  runtime_dll_dirs = SetEnvironmentAndGetRuntimeDllDirs()\n  win_sdk_dir = SetEnvironmentAndGetSDKDir()\n  print('''vs_path = %s\nsdk_path = %s\nvs_version = %s\nwdk_dir = %s\nruntime_dirs = %s",
        "detail": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "description": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "peekOfCode": "def main():\n  commands = {\n      'update': Update,\n      'get_toolchain_dir': GetToolchainDir,\n      'copy_dlls': CopyDlls,\n  }\n  if len(sys.argv) < 2 or sys.argv[1] not in commands:\n    print('Expected one of: %s' % ', '.join(commands), file=sys.stderr)\n    return 1\n  return commands[sys.argv[1]](*sys.argv[2:])",
        "detail": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "documentation": {}
    },
    {
        "label": "script_dir",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "description": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "peekOfCode": "script_dir = os.path.dirname(os.path.realpath(__file__))\njson_data_file = os.path.join(script_dir, 'new_win_toolchain.json')\nsys.path.insert(0, os.path.join(script_dir))\n# VS versions are listed in descending order of priority (highest first).\nMSVS_VERSIONS = collections.OrderedDict([\n  ('2019', '16.0'),\n  ('2017', '15.0'),\n  ('2022', '17.0'),\n])\nVC_VERSIONS = {",
        "detail": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "documentation": {}
    },
    {
        "label": "json_data_file",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "description": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "peekOfCode": "json_data_file = os.path.join(script_dir, 'new_win_toolchain.json')\nsys.path.insert(0, os.path.join(script_dir))\n# VS versions are listed in descending order of priority (highest first).\nMSVS_VERSIONS = collections.OrderedDict([\n  ('2019', '16.0'),\n  ('2017', '15.0'),\n  ('2022', '17.0'),\n])\nVC_VERSIONS = {\n  '2017': 'VC141',",
        "detail": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "documentation": {}
    },
    {
        "label": "MSVS_VERSIONS",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "description": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "peekOfCode": "MSVS_VERSIONS = collections.OrderedDict([\n  ('2019', '16.0'),\n  ('2017', '15.0'),\n  ('2022', '17.0'),\n])\nVC_VERSIONS = {\n  '2017': 'VC141',\n  '2019': 'VC142',\n  '2022': 'VC143',\n}",
        "detail": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "documentation": {}
    },
    {
        "label": "VC_VERSIONS",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "description": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "peekOfCode": "VC_VERSIONS = {\n  '2017': 'VC141',\n  '2019': 'VC142',\n  '2022': 'VC143',\n}\ndef SetEnvironmentAndGetRuntimeDllDirs():\n  \"\"\"Sets up os.environ to use the depot_tools VS toolchain with gyp, and\n  returns the location of the VC runtime DLLs so they can be copied into\n  the output directory after gyp generation.\n  Return value is [x64path, x86path, 'Arm64Unused'] or None. arm64path is",
        "detail": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "documentation": {}
    },
    {
        "label": "sdk_path",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "description": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "peekOfCode": "sdk_path = %s\nvs_version = %s\nwdk_dir = %s\nruntime_dirs = %s\n''' % (ToGNString(NormalizePath(os.environ['GYP_MSVS_OVERRIDE_PATH'])),\n       ToGNString(win_sdk_dir), ToGNString(GetVisualStudioVersion()),\n       ToGNString(NormalizePath(os.environ.get('WDK_DIR', ''))),\n       ToGNString(os.path.pathsep.join(runtime_dll_dirs or ['None']))))\ndef main():\n  commands = {",
        "detail": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "documentation": {}
    },
    {
        "label": "vs_version",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "description": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "peekOfCode": "vs_version = %s\nwdk_dir = %s\nruntime_dirs = %s\n''' % (ToGNString(NormalizePath(os.environ['GYP_MSVS_OVERRIDE_PATH'])),\n       ToGNString(win_sdk_dir), ToGNString(GetVisualStudioVersion()),\n       ToGNString(NormalizePath(os.environ.get('WDK_DIR', ''))),\n       ToGNString(os.path.pathsep.join(runtime_dll_dirs or ['None']))))\ndef main():\n  commands = {\n      'update': Update,",
        "detail": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "documentation": {}
    },
    {
        "label": "wdk_dir",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "description": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "peekOfCode": "wdk_dir = %s\nruntime_dirs = %s\n''' % (ToGNString(NormalizePath(os.environ['GYP_MSVS_OVERRIDE_PATH'])),\n       ToGNString(win_sdk_dir), ToGNString(GetVisualStudioVersion()),\n       ToGNString(NormalizePath(os.environ.get('WDK_DIR', ''))),\n       ToGNString(os.path.pathsep.join(runtime_dll_dirs or ['None']))))\ndef main():\n  commands = {\n      'update': Update,\n      'get_toolchain_dir': GetToolchainDir,",
        "detail": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "documentation": {}
    },
    {
        "label": "runtime_dirs",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "description": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "peekOfCode": "runtime_dirs = %s\n''' % (ToGNString(NormalizePath(os.environ['GYP_MSVS_OVERRIDE_PATH'])),\n       ToGNString(win_sdk_dir), ToGNString(GetVisualStudioVersion()),\n       ToGNString(NormalizePath(os.environ.get('WDK_DIR', ''))),\n       ToGNString(os.path.pathsep.join(runtime_dll_dirs or ['None']))))\ndef main():\n  commands = {\n      'update': Update,\n      'get_toolchain_dir': GetToolchainDir,\n      'copy_dlls': CopyDlls,",
        "detail": ".fvm.flutter_sdk.engine.src.build.vs_toolchain",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.dart.internal.gen_executable_call",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.dart.internal.gen_executable_call",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser(description=__doc__)\n  parser.add_argument('--output', required=True, help='Output file')\n  parser.add_argument('--command', required=True, help='Command to run')\n  parser.add_argument('--cwd', required=False, help='Working directory')\n  parser.add_argument('rest', nargs='*', help='Arguments to pass to the command')\n  # Rest of the arguments are passed to the command.\n  args = parser.parse_args()\n  out_path = os.path.dirname(args.output)\n  if not os.path.exists(out_path):",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.dart.internal.gen_executable_call",
        "documentation": {}
    },
    {
        "label": "dart_filter",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.dart.tools.dart_pkg",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.dart.tools.dart_pkg",
        "peekOfCode": "def dart_filter(path):\n  if os.path.isdir(path):\n    return True\n  _, ext = os.path.splitext(path)\n  return ext == '.dart'\ndef ensure_dir_exists(path):\n  abspath = os.path.abspath(path)\n  if not os.path.exists(abspath):\n    os.makedirs(abspath)\ndef has_pubspec_yaml(paths):",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.dart.tools.dart_pkg",
        "documentation": {}
    },
    {
        "label": "ensure_dir_exists",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.dart.tools.dart_pkg",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.dart.tools.dart_pkg",
        "peekOfCode": "def ensure_dir_exists(path):\n  abspath = os.path.abspath(path)\n  if not os.path.exists(abspath):\n    os.makedirs(abspath)\ndef has_pubspec_yaml(paths):\n  for path in paths:\n    _, filename = os.path.split(path)\n    if filename == 'pubspec.yaml':\n      return True\n  return False",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.dart.tools.dart_pkg",
        "documentation": {}
    },
    {
        "label": "has_pubspec_yaml",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.dart.tools.dart_pkg",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.dart.tools.dart_pkg",
        "peekOfCode": "def has_pubspec_yaml(paths):\n  for path in paths:\n    _, filename = os.path.split(path)\n    if filename == 'pubspec.yaml':\n      return True\n  return False\ndef copy(from_root, to_root, filter_func=None):\n  if not os.path.exists(from_root):\n    return\n  if os.path.isfile(from_root):",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.dart.tools.dart_pkg",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.dart.tools.dart_pkg",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.dart.tools.dart_pkg",
        "peekOfCode": "def copy(from_root, to_root, filter_func=None):\n  if not os.path.exists(from_root):\n    return\n  if os.path.isfile(from_root):\n    ensure_dir_exists(os.path.dirname(to_root))\n    shutil.copy(from_root, to_root)\n    return\n  ensure_dir_exists(to_root)\n  for root, dirs, files in os.walk(from_root):\n    # filter_func expects paths not names, so wrap it to make them absolute.",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.dart.tools.dart_pkg",
        "documentation": {}
    },
    {
        "label": "remove_if_exists",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.dart.tools.dart_pkg",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.dart.tools.dart_pkg",
        "peekOfCode": "def remove_if_exists(path):\n  try:\n    os.remove(path)\n  except OSError as err:\n    if err.errno != errno.ENOENT:\n      raise\ndef list_files(from_root, filter_func=None):\n  file_list = []\n  for root, dirs, files in os.walk(from_root):\n    # filter_func expects paths not names, so wrap it to make them absolute.",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.dart.tools.dart_pkg",
        "documentation": {}
    },
    {
        "label": "list_files",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.dart.tools.dart_pkg",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.dart.tools.dart_pkg",
        "peekOfCode": "def list_files(from_root, filter_func=None):\n  file_list = []\n  for root, dirs, files in os.walk(from_root):\n    # filter_func expects paths not names, so wrap it to make them absolute.\n    wrapped_filter = None\n    if filter_func:\n      wrapped_filter = lambda name, rt=root: filter_func(os.path.join(rt, name))\n    for name in filter(wrapped_filter, files):\n      path = os.path.join(root, name)\n      file_list.append(path)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.dart.tools.dart_pkg",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.dart.tools.dart_pkg",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.dart.tools.dart_pkg",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser(description='Generate a dart-pkg')\n  parser.add_argument(\n      '--dart-sdk', action='store', metavar='dart_sdk', help='Path to the Dart SDK.'\n  )\n  parser.add_argument(\n      '--package-name',\n      action='store',\n      metavar='package_name',\n      help='Name of package',",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.dart.tools.dart_pkg",
        "documentation": {}
    },
    {
        "label": "get_files",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.gen",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.gen",
        "peekOfCode": "def get_files(path, exclude=[]):\n    cmd = [\"git\", \"ls-files\", \"--\"]\n    for ex in exclude:\n        cmd.append(\":!%s\" % ex)\n    cmd.append(path)\n    git_ls = subprocess.Popen(\n        cmd,\n        stdout=subprocess.PIPE,\n        cwd=os.path.join(os.environ[\"FUCHSIA_DIR\"], \"third_party\", \"protobuf\"))\n    sed1 = subprocess.Popen(",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.gen",
        "documentation": {}
    },
    {
        "label": "gn_in",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.gen",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.gen",
        "peekOfCode": "gn_in = open(\"BUILD.input.gn\", \"rb\")\ngn_file = gn_in.read()\ngn_in.close()\ndef get_files(path, exclude=[]):\n    cmd = [\"git\", \"ls-files\", \"--\"]\n    for ex in exclude:\n        cmd.append(\":!%s\" % ex)\n    cmd.append(path)\n    git_ls = subprocess.Popen(\n        cmd,",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.gen",
        "documentation": {}
    },
    {
        "label": "gn_file",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.gen",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.gen",
        "peekOfCode": "gn_file = gn_in.read()\ngn_in.close()\ndef get_files(path, exclude=[]):\n    cmd = [\"git\", \"ls-files\", \"--\"]\n    for ex in exclude:\n        cmd.append(\":!%s\" % ex)\n    cmd.append(path)\n    git_ls = subprocess.Popen(\n        cmd,\n        stdout=subprocess.PIPE,",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.gen",
        "documentation": {}
    },
    {
        "label": "gn_file",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.gen",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.gen",
        "peekOfCode": "gn_file = gn_file.replace(\n    b\"PROTOBUF_LITE_PUBLIC\",\n    get_files(\n        \"src/google/protobuf/*.h\",\n        exclude=[\"*/compiler/*\", \"*/testing/*\", \"*/util/*\"]))\ngn_file = gn_file.replace(\n    b\"PROTOBUF_FULL_PUBLIC\",\n    get_files(\n        \"src/google/protobuf/*.h\", exclude=[\"*/compiler/*\", \"*/testing/*\"]))\ngn_file = gn_file.replace(",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.gen",
        "documentation": {}
    },
    {
        "label": "gn_file",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.gen",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.gen",
        "peekOfCode": "gn_file = gn_file.replace(\n    b\"PROTOBUF_FULL_PUBLIC\",\n    get_files(\n        \"src/google/protobuf/*.h\", exclude=[\"*/compiler/*\", \"*/testing/*\"]))\ngn_file = gn_file.replace(\n    b\"PROTOC_LIB_SOURCES\",\n    get_files(\n        \"src/google/protobuf/compiler/*.cc\",\n        exclude=[\"*/main.cc\", \"*test*\", \"*mock*\"]))\ngn_file = subprocess.check_output([\"gn\", \"format\", \"--stdin\"], input=gn_file)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.gen",
        "documentation": {}
    },
    {
        "label": "gn_file",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.gen",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.gen",
        "peekOfCode": "gn_file = gn_file.replace(\n    b\"PROTOC_LIB_SOURCES\",\n    get_files(\n        \"src/google/protobuf/compiler/*.cc\",\n        exclude=[\"*/main.cc\", \"*test*\", \"*mock*\"]))\ngn_file = subprocess.check_output([\"gn\", \"format\", \"--stdin\"], input=gn_file)\ngn_out = open(\"BUILD.gn\", \"wb\")\ngn_out.write(\n    b\"# THIS FILE IS GENERATED FROM BUILD.input.gn BY gen.py\\n# EDIT BUILD.input.gn FIRST AND THEN RUN gen.py\\n#\\n#\\n\"\n)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.gen",
        "documentation": {}
    },
    {
        "label": "gn_file",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.gen",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.gen",
        "peekOfCode": "gn_file = subprocess.check_output([\"gn\", \"format\", \"--stdin\"], input=gn_file)\ngn_out = open(\"BUILD.gn\", \"wb\")\ngn_out.write(\n    b\"# THIS FILE IS GENERATED FROM BUILD.input.gn BY gen.py\\n# EDIT BUILD.input.gn FIRST AND THEN RUN gen.py\\n#\\n#\\n\"\n)\ngn_out.write(gn_file)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.gen",
        "documentation": {}
    },
    {
        "label": "gn_out",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.gen",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.gen",
        "peekOfCode": "gn_out = open(\"BUILD.gn\", \"wb\")\ngn_out.write(\n    b\"# THIS FILE IS GENERATED FROM BUILD.input.gn BY gen.py\\n# EDIT BUILD.input.gn FIRST AND THEN RUN gen.py\\n#\\n#\\n\"\n)\ngn_out.write(gn_file)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.gen",
        "documentation": {}
    },
    {
        "label": "FormatGeneratorOptions",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "peekOfCode": "def FormatGeneratorOptions(options):\n  if not options:\n    return \"\"\n  if options.endswith(\":\"):\n    return options\n  return options + \":\"\ndef VerifyProtoNames(protos):\n  for filename in protos:\n    if \"-\" in filename:\n      raise RuntimeError(\"Proto file names must not contain hyphens \"",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "documentation": {}
    },
    {
        "label": "VerifyProtoNames",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "peekOfCode": "def VerifyProtoNames(protos):\n  for filename in protos:\n    if \"-\" in filename:\n      raise RuntimeError(\"Proto file names must not contain hyphens \"\n                         \"(see http://crbug.com/386125 for more information).\")\ndef StripProtoExtension(filename):\n  if not filename.endswith(\".proto\"):\n    raise RuntimeError(\"Invalid proto filename extension: \"\n                       \"{0} .\".format(filename))\n  return filename.rsplit(\".\", 1)[0]",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "documentation": {}
    },
    {
        "label": "StripProtoExtension",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "peekOfCode": "def StripProtoExtension(filename):\n  if not filename.endswith(\".proto\"):\n    raise RuntimeError(\"Invalid proto filename extension: \"\n                       \"{0} .\".format(filename))\n  return filename.rsplit(\".\", 1)[0]\ndef WriteIncludes(headers, include):\n  for filename in headers:\n    include_point_found = False\n    contents = []\n    with open(filename) as f:",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "documentation": {}
    },
    {
        "label": "WriteIncludes",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "peekOfCode": "def WriteIncludes(headers, include):\n  for filename in headers:\n    include_point_found = False\n    contents = []\n    with open(filename) as f:\n      for line in f:\n        stripped_line = line.strip()\n        contents.append(stripped_line)\n        if stripped_line == PROTOC_INCLUDE_POINT:\n          if include_point_found:",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "documentation": {}
    },
    {
        "label": "WriteDepfile",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "peekOfCode": "def WriteDepfile(depfile, out_list, dep_list):\n  os.makedirs(os.path.dirname(depfile), exist_ok=True)\n  with open(depfile, 'w') as f:\n    print(\"{0}: {1}\".format(\" \".join(out_list), \" \".join(dep_list)), file=f)\ndef WritePluginDepfile(depfile, outputs, dependencies):\n  with open(outputs) as f:\n    outs = [line.strip() for line in f]\n  with open(dependencies) as f:\n    deps = [line.strip() for line in f]\n  WriteDepfile(depfile, outs, deps)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "documentation": {}
    },
    {
        "label": "WritePluginDepfile",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "peekOfCode": "def WritePluginDepfile(depfile, outputs, dependencies):\n  with open(outputs) as f:\n    outs = [line.strip() for line in f]\n  with open(dependencies) as f:\n    deps = [line.strip() for line in f]\n  WriteDepfile(depfile, outs, deps)\ndef WriteProtocDepfile(depfile, outputs, deps_list):\n  with open(outputs) as f:\n    outs = [line.strip() for line in f]\n  WriteDepfile(depfile, outs, deps_list)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "documentation": {}
    },
    {
        "label": "WriteProtocDepfile",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "peekOfCode": "def WriteProtocDepfile(depfile, outputs, deps_list):\n  with open(outputs) as f:\n    outs = [line.strip() for line in f]\n  WriteDepfile(depfile, outs, deps_list)\ndef ExtractImports(proto, proto_dir, import_dirs):\n  filename = os.path.join(proto_dir, proto)\n  imports = set()\n  with open(filename) as f:\n    # Search the file for import.\n    for line in f:",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "documentation": {}
    },
    {
        "label": "ExtractImports",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "peekOfCode": "def ExtractImports(proto, proto_dir, import_dirs):\n  filename = os.path.join(proto_dir, proto)\n  imports = set()\n  with open(filename) as f:\n    # Search the file for import.\n    for line in f:\n      match = re.match(r'^\\s*import(?:\\s+public)?\\s+\"([^\"]+)\"\\s*;\\s*$', line)\n      if match:\n        imported = match[1]\n        # Check import directories to find the imported file.",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "peekOfCode": "def main(argv):\n  parser = argparse.ArgumentParser()\n  parser.add_argument(\"--protoc\",\n                      help=\"Relative path to compiler.\")\n  parser.add_argument(\"--proto-in-dir\",\n                      help=\"Base directory with source protos.\")\n  parser.add_argument(\"--cc-out-dir\",\n                      help=\"Output directory for standard C++ generator.\")\n  parser.add_argument(\"--py-out-dir\",\n                      help=\"Output directory for standard Python generator.\")",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "documentation": {}
    },
    {
        "label": "PROTOC_INCLUDE_POINT",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "peekOfCode": "PROTOC_INCLUDE_POINT = \"// @@protoc_insertion_point(includes)\"\ndef FormatGeneratorOptions(options):\n  if not options:\n    return \"\"\n  if options.endswith(\":\"):\n    return options\n  return options + \":\"\ndef VerifyProtoNames(protos):\n  for filename in protos:\n    if \"-\" in filename:",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.secondary.third_party.protobuf.protoc_wrapper",
        "documentation": {}
    },
    {
        "label": "cp_files",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.android_artifacts",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.android_artifacts",
        "peekOfCode": "def cp_files(args):\n  \"\"\"Copies files from source to destination.\n  It creates the destination folder if it does not exists yet.\n  \"\"\"\n  for src, dst in args.input_pairs:\n    os.makedirs(os.path.dirname(dst), exist_ok=True)\n    shutil.copyfile(src, dst)\ndef main():\n  parser = argparse.ArgumentParser()\n  parser.add_argument(",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.android_artifacts",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.android_artifacts",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.android_artifacts",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser()\n  parser.add_argument(\n      '-i',\n      dest='input_pairs',\n      nargs=2,\n      action='append',\n      help='The input file and its destination.'\n  )\n  cp_files(parser.parse_args())",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.android_artifacts",
        "documentation": {}
    },
    {
        "label": "get_clang_version",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.copy_info_plist",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.copy_info_plist",
        "peekOfCode": "def get_clang_version():\n  clang_executable = str(\n      os.path.join(_src_root_dir, 'flutter', 'buildtools', 'mac-x64', 'clang', 'bin', 'clang++')\n  )\n  version = subprocess.check_output([clang_executable, '--version'])\n  return version.splitlines()[0]\ndef main():\n  parser = argparse.ArgumentParser(\n      description='Copies the Info.plist and adds extra fields to it like the '\n      'git hash of the engine'",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.copy_info_plist",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.copy_info_plist",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.copy_info_plist",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser(\n      description='Copies the Info.plist and adds extra fields to it like the '\n      'git hash of the engine'\n  )\n  parser.add_argument(\n      '--source', help='Path to Info.plist source template', type=str, required=True\n  )\n  parser.add_argument(\n      '--destination', help='Path to destination Info.plist', type=str, required=True",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.copy_info_plist",
        "documentation": {}
    },
    {
        "label": "_script_dir",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.copy_info_plist",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.copy_info_plist",
        "peekOfCode": "_script_dir = os.path.abspath(os.path.join(os.path.realpath(__file__), '..'))\n_src_root_dir = os.path.join(_script_dir, '..', '..')\ndef get_clang_version():\n  clang_executable = str(\n      os.path.join(_src_root_dir, 'flutter', 'buildtools', 'mac-x64', 'clang', 'bin', 'clang++')\n  )\n  version = subprocess.check_output([clang_executable, '--version'])\n  return version.splitlines()[0]\ndef main():\n  parser = argparse.ArgumentParser(",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.copy_info_plist",
        "documentation": {}
    },
    {
        "label": "_src_root_dir",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.copy_info_plist",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.copy_info_plist",
        "peekOfCode": "_src_root_dir = os.path.join(_script_dir, '..', '..')\ndef get_clang_version():\n  clang_executable = str(\n      os.path.join(_src_root_dir, 'flutter', 'buildtools', 'mac-x64', 'clang', 'bin', 'clang++')\n  )\n  version = subprocess.check_output([clang_executable, '--version'])\n  return version.splitlines()[0]\ndef main():\n  parser = argparse.ArgumentParser(\n      description='Copies the Info.plist and adds extra fields to it like the '",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.copy_info_plist",
        "documentation": {}
    },
    {
        "label": "get_llvm_bin_directory",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.generate_coverage",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.generate_coverage",
        "peekOfCode": "def get_llvm_bin_directory():\n  buildtool_dir = os.path.join(os.path.dirname(os.path.realpath(__file__)), '../../buildtools')\n  platform_dir = ''\n  if sys.platform.startswith('linux'):\n    platform_dir = 'linux-x64'\n  elif sys.platform == 'darwin':\n    platform_dir = 'mac-x64'\n  else:\n    raise Exception('Unknown/Unsupported platform.')\n  llvm_bin_dir = os.path.abspath(os.path.join(buildtool_dir, platform_dir, 'clang/bin'))",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.generate_coverage",
        "documentation": {}
    },
    {
        "label": "make_dirs",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.generate_coverage",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.generate_coverage",
        "peekOfCode": "def make_dirs(new_dir):\n  \"\"\"A wrapper around os.makedirs() that emulates \"mkdir -p\".\"\"\"\n  try:\n    os.makedirs(new_dir)\n  except OSError as err:\n    if err.errno != errno.EEXIST:\n      raise\ndef remove_if_exists(path):\n  if os.path.isdir(path) and not os.path.islink(path):\n    shutil.rmtree(path)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.generate_coverage",
        "documentation": {}
    },
    {
        "label": "remove_if_exists",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.generate_coverage",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.generate_coverage",
        "peekOfCode": "def remove_if_exists(path):\n  if os.path.isdir(path) and not os.path.islink(path):\n    shutil.rmtree(path)\n  elif os.path.exists(path):\n    os.remove(path)\ndef collect_profiles(args):\n  raw_profiles = []\n  binaries = []\n  # Run all unit tests and collect raw profiles.\n  for test in args.tests:",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.generate_coverage",
        "documentation": {}
    },
    {
        "label": "collect_profiles",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.generate_coverage",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.generate_coverage",
        "peekOfCode": "def collect_profiles(args):\n  raw_profiles = []\n  binaries = []\n  # Run all unit tests and collect raw profiles.\n  for test in args.tests:\n    absolute_test_path = os.path.abspath(test)\n    absolute_test_dir = os.path.dirname(absolute_test_path)\n    test_name = os.path.basename(absolute_test_path)\n    if not os.path.exists(absolute_test_path):\n      print('Path %s does not exist.' % absolute_test_path)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.generate_coverage",
        "documentation": {}
    },
    {
        "label": "merge_profiles",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.generate_coverage",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.generate_coverage",
        "peekOfCode": "def merge_profiles(llvm_bin_dir, raw_profiles, output):\n  # Merge all raw profiles into a single profile.\n  profdata_binary = os.path.join(llvm_bin_dir, 'llvm-profdata')\n  print('Merging %d raw profile(s) into single profile.' % len(raw_profiles))\n  merged_profile_path = os.path.join(output, 'all.profile')\n  remove_if_exists(merged_profile_path)\n  merge_command = [profdata_binary, 'merge', '-sparse'] + raw_profiles + ['-o', merged_profile_path]\n  subprocess.check_call(merge_command)\n  print('Done.')\n  return merged_profile_path",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.generate_coverage",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.generate_coverage",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.generate_coverage",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser()\n  parser.add_argument(\n      '-t',\n      '--tests',\n      nargs='+',\n      dest='tests',\n      required=True,\n      help='The unit tests to run and gather coverage data on.'\n  )",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.generate_coverage",
        "documentation": {}
    },
    {
        "label": "is_windows",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.git_revision",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.git_revision",
        "peekOfCode": "def is_windows():\n  os_id = sys.platform\n  return os_id.startswith('win32') or os_id.startswith('cygwin')\ndef get_repository_version(repository):\n  'Returns the Git HEAD for the supplied repository path as a string.'\n  if not os.path.exists(repository):\n    raise IOError('path does not exist')\n  git = 'git'\n  if is_windows():\n    git = 'git.bat'",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.git_revision",
        "documentation": {}
    },
    {
        "label": "get_repository_version",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.git_revision",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.git_revision",
        "peekOfCode": "def get_repository_version(repository):\n  'Returns the Git HEAD for the supplied repository path as a string.'\n  if not os.path.exists(repository):\n    raise IOError('path does not exist')\n  git = 'git'\n  if is_windows():\n    git = 'git.bat'\n  version = subprocess.check_output([\n      git,\n      '-C',",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.git_revision",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.git_revision",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.git_revision",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser()\n  parser.add_argument(\n      '--repository', action='store', help='Path to the Git repository.', required=True\n  )\n  args = parser.parse_args()\n  repository = os.path.abspath(args.repository)\n  version = get_repository_version(repository)\n  print(version.strip())\n  return 0",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.git_revision",
        "documentation": {}
    },
    {
        "label": "add_symlink",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.zip",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.zip",
        "peekOfCode": "def add_symlink(zip_file, source, target):\n  \"\"\"Adds a symlink to a zip file.\n  Args:\n    zip_file: The ZipFile obj where the symlink will be added.\n    source: The full path to the symlink.\n    target: The target path for the symlink within the zip file.\n  \"\"\"\n  zip_info = zipfile.ZipInfo(target)\n  zip_info.create_system = 3  # Unix like system\n  unix_st_mode = (",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.zip",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.build.zip",
        "description": ".fvm.flutter_sdk.engine.src.flutter.build.zip",
        "peekOfCode": "def main(args):\n  zip_file = zipfile.ZipFile(args.output, 'w', zipfile.ZIP_DEFLATED)\n  if args.source_file:\n    with open(args.source_file) as source_file:\n      file_dict_list = json.load(source_file)\n      for file_dict in file_dict_list:\n        if os.path.islink(file_dict['source']):\n          add_symlink(zip_file, file_dict['source'], file_dict['destination'])\n          continue\n        if os.path.isdir(file_dict['source']):",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.build.zip",
        "documentation": {}
    },
    {
        "label": "byte_str_decode",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.ci.compatibility_helper",
        "description": ".fvm.flutter_sdk.engine.src.flutter.ci.compatibility_helper",
        "peekOfCode": "def byte_str_decode(str_or_bytes):\n  \"\"\"Returns a string if given either a string or bytes.\n    TODO: This function should be removed when the supported python\n    version is only python 3.\n    Args:\n        str_or_bytes (string or bytes) we want to convert or return as\n        the possible value changes depending on the version of python\n        used.\n    \"\"\"\n  return str_or_bytes if isinstance(str_or_bytes, str) else str_or_bytes.decode(ENCODING)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.ci.compatibility_helper",
        "documentation": {}
    },
    {
        "label": "ENCODING",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.ci.compatibility_helper",
        "description": ".fvm.flutter_sdk.engine.src.flutter.ci.compatibility_helper",
        "peekOfCode": "ENCODING = 'UTF-8'\ndef byte_str_decode(str_or_bytes):\n  \"\"\"Returns a string if given either a string or bytes.\n    TODO: This function should be removed when the supported python\n    version is only python 3.\n    Args:\n        str_or_bytes (string or bytes) we want to convert or return as\n        the possible value changes depending on the version of python\n        used.\n    \"\"\"",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.ci.compatibility_helper",
        "documentation": {}
    },
    {
        "label": "VarImpl",
        "kind": 6,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "description": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "peekOfCode": "class VarImpl:\n  _env_vars = {\n      'host_cpu': 'x64',\n      'host_os': 'linux',\n  }\n  def __init__(self, local_scope):\n    self._local_scope = local_scope\n  def lookup(self, var_name):\n    \"\"\"Implements the Var syntax.\"\"\"\n    if var_name in self._local_scope.get('vars', {}):",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "documentation": {}
    },
    {
        "label": "extract_deps",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "description": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "peekOfCode": "def extract_deps(deps_file):\n  local_scope = {}\n  var = VarImpl(local_scope)\n  global_scope = {\n      'Var': var.lookup,\n      'deps_os': {},\n  }\n  # Read the content.\n  with open(deps_file, 'r') as file:\n    deps_content = file.read()",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "documentation": {}
    },
    {
        "label": "parse_readme",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "description": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "peekOfCode": "def parse_readme():\n  \"\"\"\n  Opens the Flutter Accessibility Library README and uses the commit hash\n  found in the README to check for viulnerabilities.\n  The commit hash in this README will always be in the same format\n  \"\"\"\n  file_path = os.path.join(CHECKOUT_ROOT, CHROMIUM_README_FILE)\n  with open(file_path) as file:\n    # Read the content of the file opened.\n    content = file.readlines()",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "documentation": {}
    },
    {
        "label": "get_common_ancestor",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "description": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "peekOfCode": "def get_common_ancestor(dep, deps_list):\n  \"\"\"\n  Given an input of a mirrored dep,\n  compare to the mapping of deps to their upstream\n  in DEPS and find a common ancestor\n  commit SHA value.\n  This is done by first cloning the mirrored dep,\n  then a branch which tracks the upstream.\n  From there,  git merge-base operates using the HEAD\n  commit SHA of the upstream branch and the pinned",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "description": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "peekOfCode": "def parse_args(args):\n  args = args[1:]\n  parser = argparse.ArgumentParser(description='A script to find common ancestor commit SHAs')\n  parser.add_argument(\n      '--deps',\n      '-d',\n      type=str,\n      help='Input DEPS file to extract.',\n      default=os.path.join(CHECKOUT_ROOT, 'DEPS')\n  )",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "documentation": {}
    },
    {
        "label": "write_manifest",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "description": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "peekOfCode": "def write_manifest(deps, manifest_file):\n  output = {'results': deps}\n  print(json.dumps(output, indent=2))\n  with open(manifest_file, 'w') as manifest:\n    json.dump(output, manifest, indent=2)\ndef main(argv):\n  args = parse_args(argv)\n  deps = extract_deps(args.deps)\n  readme_deps = parse_readme()\n  write_manifest([deps, readme_deps], args.output)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "description": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "peekOfCode": "def main(argv):\n  args = parse_args(argv)\n  deps = extract_deps(args.deps)\n  readme_deps = parse_readme()\n  write_manifest([deps, readme_deps], args.output)\n  return 0\nif __name__ == '__main__':\n  sys.exit(main(sys.argv))",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "documentation": {}
    },
    {
        "label": "SCRIPT_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "description": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "peekOfCode": "SCRIPT_DIR = os.path.dirname(sys.argv[0])\nCHECKOUT_ROOT = os.path.realpath(os.path.join(SCRIPT_DIR, '..'))\nCHROMIUM_README_FILE = 'third_party/accessibility/README.md'\nCHROMIUM_README_COMMIT_LINE = 4  # The fifth line will always contain the commit hash.\nCHROMIUM = 'https://chromium.googlesource.com/chromium/src'\nDEP_CLONE_DIR = CHECKOUT_ROOT + '/clone-test'\nDEPS = os.path.join(CHECKOUT_ROOT, 'DEPS')\nUPSTREAM_PREFIX = 'upstream_'\n# Used in parsing the DEPS file.\nclass VarImpl:",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "documentation": {}
    },
    {
        "label": "CHECKOUT_ROOT",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "description": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "peekOfCode": "CHECKOUT_ROOT = os.path.realpath(os.path.join(SCRIPT_DIR, '..'))\nCHROMIUM_README_FILE = 'third_party/accessibility/README.md'\nCHROMIUM_README_COMMIT_LINE = 4  # The fifth line will always contain the commit hash.\nCHROMIUM = 'https://chromium.googlesource.com/chromium/src'\nDEP_CLONE_DIR = CHECKOUT_ROOT + '/clone-test'\nDEPS = os.path.join(CHECKOUT_ROOT, 'DEPS')\nUPSTREAM_PREFIX = 'upstream_'\n# Used in parsing the DEPS file.\nclass VarImpl:\n  _env_vars = {",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "documentation": {}
    },
    {
        "label": "CHROMIUM_README_FILE",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "description": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "peekOfCode": "CHROMIUM_README_FILE = 'third_party/accessibility/README.md'\nCHROMIUM_README_COMMIT_LINE = 4  # The fifth line will always contain the commit hash.\nCHROMIUM = 'https://chromium.googlesource.com/chromium/src'\nDEP_CLONE_DIR = CHECKOUT_ROOT + '/clone-test'\nDEPS = os.path.join(CHECKOUT_ROOT, 'DEPS')\nUPSTREAM_PREFIX = 'upstream_'\n# Used in parsing the DEPS file.\nclass VarImpl:\n  _env_vars = {\n      'host_cpu': 'x64',",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "documentation": {}
    },
    {
        "label": "CHROMIUM_README_COMMIT_LINE",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "description": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "peekOfCode": "CHROMIUM_README_COMMIT_LINE = 4  # The fifth line will always contain the commit hash.\nCHROMIUM = 'https://chromium.googlesource.com/chromium/src'\nDEP_CLONE_DIR = CHECKOUT_ROOT + '/clone-test'\nDEPS = os.path.join(CHECKOUT_ROOT, 'DEPS')\nUPSTREAM_PREFIX = 'upstream_'\n# Used in parsing the DEPS file.\nclass VarImpl:\n  _env_vars = {\n      'host_cpu': 'x64',\n      'host_os': 'linux',",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "documentation": {}
    },
    {
        "label": "CHROMIUM",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "description": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "peekOfCode": "CHROMIUM = 'https://chromium.googlesource.com/chromium/src'\nDEP_CLONE_DIR = CHECKOUT_ROOT + '/clone-test'\nDEPS = os.path.join(CHECKOUT_ROOT, 'DEPS')\nUPSTREAM_PREFIX = 'upstream_'\n# Used in parsing the DEPS file.\nclass VarImpl:\n  _env_vars = {\n      'host_cpu': 'x64',\n      'host_os': 'linux',\n  }",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "documentation": {}
    },
    {
        "label": "DEP_CLONE_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "description": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "peekOfCode": "DEP_CLONE_DIR = CHECKOUT_ROOT + '/clone-test'\nDEPS = os.path.join(CHECKOUT_ROOT, 'DEPS')\nUPSTREAM_PREFIX = 'upstream_'\n# Used in parsing the DEPS file.\nclass VarImpl:\n  _env_vars = {\n      'host_cpu': 'x64',\n      'host_os': 'linux',\n  }\n  def __init__(self, local_scope):",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "documentation": {}
    },
    {
        "label": "DEPS",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "description": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "peekOfCode": "DEPS = os.path.join(CHECKOUT_ROOT, 'DEPS')\nUPSTREAM_PREFIX = 'upstream_'\n# Used in parsing the DEPS file.\nclass VarImpl:\n  _env_vars = {\n      'host_cpu': 'x64',\n      'host_os': 'linux',\n  }\n  def __init__(self, local_scope):\n    self._local_scope = local_scope",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "documentation": {}
    },
    {
        "label": "UPSTREAM_PREFIX",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "description": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "peekOfCode": "UPSTREAM_PREFIX = 'upstream_'\n# Used in parsing the DEPS file.\nclass VarImpl:\n  _env_vars = {\n      'host_cpu': 'x64',\n      'host_os': 'linux',\n  }\n  def __init__(self, local_scope):\n    self._local_scope = local_scope\n  def lookup(self, var_name):",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.ci.scan_deps",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_cores",
        "description": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_cores",
        "peekOfCode": "def parse_args(argv):\n  parser = argparse.ArgumentParser(\n      description='This script sanitizes GPU core info output from malioc',\n  )\n  parser.add_argument(\n      '--malioc',\n      '-m',\n      type=str,\n      help='The path to malioc.',\n  )",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_cores",
        "documentation": {}
    },
    {
        "label": "validate_args",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_cores",
        "description": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_cores",
        "peekOfCode": "def validate_args(args):\n  if not args.malioc or not os.path.isfile(args.malioc):\n    print('The --malioc argument must refer to the malioc binary.')\n    return False\n  return True\ndef malioc_core_list(malioc):\n  malioc_cores = subprocess.check_output(\n      [malioc, '--list', '--format', 'json'],\n      stderr=subprocess.STDOUT,\n  )",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_cores",
        "documentation": {}
    },
    {
        "label": "malioc_core_list",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_cores",
        "description": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_cores",
        "peekOfCode": "def malioc_core_list(malioc):\n  malioc_cores = subprocess.check_output(\n      [malioc, '--list', '--format', 'json'],\n      stderr=subprocess.STDOUT,\n  )\n  cores_json = json.loads(malioc_cores)\n  cores = []\n  for core in cores_json['cores']:\n    cores.append(core['core'])\n  return cores",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_cores",
        "documentation": {}
    },
    {
        "label": "malioc_core_info",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_cores",
        "description": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_cores",
        "peekOfCode": "def malioc_core_info(malioc, core):\n  malioc_info = subprocess.check_output(\n      [malioc, '--info', '--core', core, '--format', 'json'],\n      stderr=subprocess.STDOUT,\n  )\n  info_json = json.loads(malioc_info)\n  apis = info_json['apis']\n  opengles_max_version = 0\n  if 'opengles' in apis:\n    opengles = apis['opengles']",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_cores",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_cores",
        "description": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_cores",
        "peekOfCode": "def main(argv):\n  args = parse_args(argv[1:])\n  if not validate_args(args):\n    return 1\n  infos = []\n  for core in malioc_core_list(args.malioc):\n    infos.append(malioc_core_info(args.malioc, core))\n  if args.output:\n    with open(args.output, 'w') as file:\n      json.dump(infos, file, sort_keys=True)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_cores",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "description": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "peekOfCode": "def parse_args(argv):\n  parser = argparse.ArgumentParser(\n      description='A script that compares before/after malioc analysis results',\n  )\n  parser.add_argument(\n      '--after',\n      '-a',\n      type=str,\n      help='The path to a directory tree containing new malioc results in json files.',\n  )",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "documentation": {}
    },
    {
        "label": "validate_args",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "description": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "peekOfCode": "def validate_args(args):\n  if not args.after and not args.after_relative_to_src:\n    print('--after argument or --after-relative-to-src must be specified.')\n    return False\n  if not args.before and not args.before_relative_to_src:\n    print('--before argument or --before-relative-to-src must be specified.')\n    return False\n  # Generate full paths if relative ones are provided with before and\n  # after taking precedence.\n  args.before = (args.before or os.path.join(BUILD_ROOT_DIR, args.before_relative_to_src))",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "documentation": {}
    },
    {
        "label": "read_malioc_file_performance",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "description": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "peekOfCode": "def read_malioc_file_performance(performance_json):\n  performance = {}\n  performance['pipelines'] = performance_json['pipelines']\n  longest_path_cycles = performance_json['longest_path_cycles']\n  performance['longest_path_cycles'] = longest_path_cycles['cycle_count']\n  performance['longest_path_bound_pipelines'] = longest_path_cycles['bound_pipelines']\n  shortest_path_cycles = performance_json['shortest_path_cycles']\n  performance['shortest_path_cycles'] = shortest_path_cycles['cycle_count']\n  performance['shortest_path_bound_pipelines'] = shortest_path_cycles['bound_pipelines']\n  total_cycles = performance_json['total_cycles']",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "documentation": {}
    },
    {
        "label": "read_malioc_file",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "description": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "peekOfCode": "def read_malioc_file(malioc_tree, json_file):\n  with open(json_file, 'r') as file:\n    json_obj = json.load(file)\n  build_gen_dir = os.path.dirname(malioc_tree)\n  results = []\n  for shader in json_obj['shaders']:\n    # Ignore cores not in the allowlist above.\n    if shader['hardware']['core'] not in CORES:\n      continue\n    result = {}",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "documentation": {}
    },
    {
        "label": "read_malioc_tree",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "description": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "peekOfCode": "def read_malioc_tree(malioc_tree):\n  results = {}\n  for root, _, files in os.walk(malioc_tree):\n    for file in files:\n      if not file.endswith('.json'):\n        continue\n      full_path = os.path.join(root, file)\n      for shader in read_malioc_file(malioc_tree, full_path):\n        if shader['filename'] not in results:\n          results[shader['filename']] = {}",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "documentation": {}
    },
    {
        "label": "pretty_list",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "description": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "peekOfCode": "def pretty_list(lst, fmt='s', sep='', width=12):\n  formats = ['{:<{width}{fmt}}' if ele is not None else '{:<{width}s}' for ele in lst]\n  sanitized_list = [x if x is not None else 'null' for x in lst]\n  return (sep.join(formats)).format(width='' if width == 0 else width, fmt=fmt, *sanitized_list)\ndef compare_performance(variant, before, after):\n  cycles = [['longest_path_cycles', 'longest_path_bound_pipelines'],\n            ['shortest_path_cycles', 'shortest_path_bound_pipelines'],\n            ['total_cycles', 'total_bound_pipelines']]\n  differences = []\n  for cycle in cycles:",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "documentation": {}
    },
    {
        "label": "compare_performance",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "description": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "peekOfCode": "def compare_performance(variant, before, after):\n  cycles = [['longest_path_cycles', 'longest_path_bound_pipelines'],\n            ['shortest_path_cycles', 'shortest_path_bound_pipelines'],\n            ['total_cycles', 'total_bound_pipelines']]\n  differences = []\n  for cycle in cycles:\n    if before[cycle[0]] == after[cycle[0]]:\n      continue\n    before_cycles = before[cycle[0]]\n    before_bounds = before[cycle[1]]",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "documentation": {}
    },
    {
        "label": "compare_variants",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "description": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "peekOfCode": "def compare_variants(befores, afters):\n  differences = []\n  for variant_name, before_variant in befores.items():\n    if variant_name in afters:\n      after_variant = afters[variant_name]\n      for variant_key, before_variant_val in before_variant.items():\n        after_variant_val = after_variant[variant_key]\n        if variant_key == 'performance':\n          differences += compare_performance(variant_name, before_variant_val, after_variant_val)\n        elif before_variant_val != after_variant_val:",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "documentation": {}
    },
    {
        "label": "compare_shaders",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "description": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "peekOfCode": "def compare_shaders(malioc_tree, before_shader, after_shader):\n  differences = []\n  for key, before_val in before_shader.items():\n    after_val = after_shader[key]\n    if key == 'variants':\n      differences += compare_variants(before_val, after_val)\n    elif key == 'performance':\n      differences += compare_performance('Default', before_val, after_val)\n    elif before_val != after_val:\n      differences += ['{}:\\n  {} <- before\\n  {} <- after'.format(key, before_val, after_val)]",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "description": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "peekOfCode": "def main(argv):\n  args = parse_args(argv[1:])\n  if not validate_args(args):\n    return 1\n  after_json = read_malioc_tree(args.after)\n  if not bool(after_json):\n    print('Did not find any malioc results under {}.'.format(args.after))\n    return 1\n  if args.update:\n    # Write the new results to the file given by --before, then exit.",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "documentation": {}
    },
    {
        "label": "SRC_ROOT",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "description": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "peekOfCode": "SRC_ROOT = os.path.dirname(\n    os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n)\nCORES = [\n    'Mali-G78',  # Pixel 6 / 2020\n    'Mali-T880',  # 2016\n]\n# Path to the engine root checkout. This is used to calculate absolute\n# paths if relative ones are passed to the script.\nBUILD_ROOT_DIR = os.path.abspath(os.path.join(os.path.realpath(__file__), '..', '..', '..', '..'))",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "documentation": {}
    },
    {
        "label": "CORES",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "description": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "peekOfCode": "CORES = [\n    'Mali-G78',  # Pixel 6 / 2020\n    'Mali-T880',  # 2016\n]\n# Path to the engine root checkout. This is used to calculate absolute\n# paths if relative ones are passed to the script.\nBUILD_ROOT_DIR = os.path.abspath(os.path.join(os.path.realpath(__file__), '..', '..', '..', '..'))\ndef parse_args(argv):\n  parser = argparse.ArgumentParser(\n      description='A script that compares before/after malioc analysis results',",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "documentation": {}
    },
    {
        "label": "BUILD_ROOT_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "description": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "peekOfCode": "BUILD_ROOT_DIR = os.path.abspath(os.path.join(os.path.realpath(__file__), '..', '..', '..', '..'))\ndef parse_args(argv):\n  parser = argparse.ArgumentParser(\n      description='A script that compares before/after malioc analysis results',\n  )\n  parser.add_argument(\n      '--after',\n      '-a',\n      type=str,\n      help='The path to a directory tree containing new malioc results in json files.',",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.malioc_diff",
        "documentation": {}
    },
    {
        "label": "make_directories",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.metal_library",
        "description": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.metal_library",
        "peekOfCode": "def make_directories(path):\n  try:\n    os.makedirs(path)\n  except OSError as exc:\n    if exc.errno == errno.EEXIST and os.path.isdir(path):\n      pass\n    else:\n      raise\ndef main():\n  parser = argparse.ArgumentParser()",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.metal_library",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.metal_library",
        "description": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.metal_library",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser()\n  parser.add_argument(\n      '--output', type=str, required=True, help='The location to generate the Metal library to.'\n  )\n  parser.add_argument('--depfile', type=str, required=True, help='The location of the depfile.')\n  parser.add_argument(\n      '--source',\n      type=str,\n      action='append',",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.metal_library",
        "documentation": {}
    },
    {
        "label": "make_directories",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.xxd",
        "description": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.xxd",
        "peekOfCode": "def make_directories(path):\n  try:\n    os.makedirs(path)\n  except OSError as exc:\n    if exc.errno == errno.EEXIST and os.path.isdir(path):\n      pass\n    else:\n      raise\n# Dump the bytes of file into a C translation unit.\n# This can be used to embed the file contents into a binary.",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.xxd",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.xxd",
        "description": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.xxd",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser()\n  parser.add_argument(\n      '--symbol-name', type=str, required=True, help='The name of the symbol referencing the data.'\n  )\n  parser.add_argument(\n      '--output-header',\n      type=str,\n      required=True,\n      help='The header file containing the symbol reference.'",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.impeller.tools.xxd",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.shell.platform.fuchsia.flutter.build.asset_package",
        "description": ".fvm.flutter_sdk.engine.src.flutter.shell.platform.fuchsia.flutter.build.asset_package",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser(description='Package a Flutter application')\n  parser.add_argument('--flutter-root', type=str, required=True, help='The root of the Flutter SDK')\n  parser.add_argument(\n      '--flutter-tools', type=str, required=True, help='The executable for the Flutter tool'\n  )\n  parser.add_argument(\n      '--asset-dir', type=str, required=True, help='The directory where to put intermediate files'\n  )\n  parser.add_argument('--app-dir', type=str, required=True, help='The root of the app')",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.shell.platform.fuchsia.flutter.build.asset_package",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.shell.platform.fuchsia.flutter.build.gen_debug_wrapper_main",
        "description": ".fvm.flutter_sdk.engine.src.flutter.shell.platform.fuchsia.flutter.build.gen_debug_wrapper_main",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser(\n      sys.argv[0], description=\"Generate main file for Fuchsia dart test\"\n  )\n  parser.add_argument(\"--out\", help=\"Path to .dart file to generate\", required=True)\n  parser.add_argument(\"--main-dart\", help=\"Path to main.dart file to import\", required=True)\n  args = parser.parse_args()\n  out_dir = os.path.dirname(args.out)\n  assert os.path.isfile(os.path.join(os.path.dirname(args.out), args.main_dart))\n  outfile = open(args.out, 'w')",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.shell.platform.fuchsia.flutter.build.gen_debug_wrapper_main",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.cp",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.cp",
        "peekOfCode": "def main(src, dst):\n  # Use copy instead of copyfile to ensure the executable bit is copied.\n  dstpath = os.path.normpath(dst)\n  try:\n    shutil.copy(src, dstpath)\n  except shutil.SameFileError:\n    if not (os.path.islink(dstpath) or os.stat(dstpath).st_nlink > 1):\n      raise\n    # Copy will fail if the destination is the link to the source.\n    # If that's the case, then delete the destination link first,",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.cp",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_embedder_framework",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_embedder_framework",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser(description='Creates FlutterEmbedder.framework for macOS')\n  parser.add_argument('--dst', type=str, required=True)\n  parser.add_argument('--arm64-out-dir', type=str, required=True)\n  parser.add_argument('--x64-out-dir', type=str, required=True)\n  parser.add_argument('--strip', action='store_true', default=False)\n  parser.add_argument('--dsym', action='store_true', default=False)\n  # TODO(godofredoc): Remove after recipes v2 have landed.\n  parser.add_argument('--zip', action='store_true', default=False)\n  args = parser.parse_args()",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_embedder_framework",
        "documentation": {}
    },
    {
        "label": "regenerate_symlinks",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_embedder_framework",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_embedder_framework",
        "peekOfCode": "def regenerate_symlinks(fat_framework):\n  \"\"\"Regenerates the symlinks structure.\n  Recipes V2 upload artifacts in CAS before integration and CAS follows symlinks.\n  This logic regenerates the symlinks in the expected structure.\n  \"\"\"\n  if os.path.islink(os.path.join(fat_framework, 'FlutterEmbedder')):\n    return\n  os.remove(os.path.join(fat_framework, 'FlutterEmbedder'))\n  shutil.rmtree(os.path.join(fat_framework, 'Headers'), True)\n  shutil.rmtree(os.path.join(fat_framework, 'Modules'), True)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_embedder_framework",
        "documentation": {}
    },
    {
        "label": "process_framework",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_embedder_framework",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_embedder_framework",
        "peekOfCode": "def process_framework(dst, args, fat_framework, fat_framework_binary):\n  if args.dsym:\n    dsym_out = os.path.splitext(fat_framework)[0] + '.dSYM'\n    subprocess.check_call([DSYMUTIL, '-o', dsym_out, fat_framework_binary])\n    if args.zip:\n      dsym_dst = os.path.join(dst, 'FlutterEmbedder.dSYM')\n      subprocess.check_call(['zip', '-r', '-y', 'FlutterEmbedder.dSYM.zip', '.'], cwd=dsym_dst)\n      dsym_final_src_path = os.path.join(dsym_dst, 'FlutterEmbedder.dSYM.zip')\n      dsym_final_dst_path = os.path.join(dst, 'FlutterEmbedder.dSYM.zip')\n      shutil.move(dsym_final_src_path, dsym_final_dst_path)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_embedder_framework",
        "documentation": {}
    },
    {
        "label": "buildroot_dir",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_embedder_framework",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_embedder_framework",
        "peekOfCode": "buildroot_dir = os.path.abspath(os.path.join(os.path.realpath(__file__), '..', '..', '..', '..'))\nARCH_SUBPATH = 'mac-arm64' if platform.processor() == 'arm' else 'mac-x64'\nDSYMUTIL = os.path.join(\n    os.path.dirname(__file__), '..', '..', 'buildtools', ARCH_SUBPATH, 'clang', 'bin', 'dsymutil'\n)\nout_dir = os.path.join(buildroot_dir, 'out')\ndef main():\n  parser = argparse.ArgumentParser(description='Creates FlutterEmbedder.framework for macOS')\n  parser.add_argument('--dst', type=str, required=True)\n  parser.add_argument('--arm64-out-dir', type=str, required=True)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_embedder_framework",
        "documentation": {}
    },
    {
        "label": "ARCH_SUBPATH",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_embedder_framework",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_embedder_framework",
        "peekOfCode": "ARCH_SUBPATH = 'mac-arm64' if platform.processor() == 'arm' else 'mac-x64'\nDSYMUTIL = os.path.join(\n    os.path.dirname(__file__), '..', '..', 'buildtools', ARCH_SUBPATH, 'clang', 'bin', 'dsymutil'\n)\nout_dir = os.path.join(buildroot_dir, 'out')\ndef main():\n  parser = argparse.ArgumentParser(description='Creates FlutterEmbedder.framework for macOS')\n  parser.add_argument('--dst', type=str, required=True)\n  parser.add_argument('--arm64-out-dir', type=str, required=True)\n  parser.add_argument('--x64-out-dir', type=str, required=True)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_embedder_framework",
        "documentation": {}
    },
    {
        "label": "DSYMUTIL",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_embedder_framework",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_embedder_framework",
        "peekOfCode": "DSYMUTIL = os.path.join(\n    os.path.dirname(__file__), '..', '..', 'buildtools', ARCH_SUBPATH, 'clang', 'bin', 'dsymutil'\n)\nout_dir = os.path.join(buildroot_dir, 'out')\ndef main():\n  parser = argparse.ArgumentParser(description='Creates FlutterEmbedder.framework for macOS')\n  parser.add_argument('--dst', type=str, required=True)\n  parser.add_argument('--arm64-out-dir', type=str, required=True)\n  parser.add_argument('--x64-out-dir', type=str, required=True)\n  parser.add_argument('--strip', action='store_true', default=False)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_embedder_framework",
        "documentation": {}
    },
    {
        "label": "out_dir",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_embedder_framework",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_embedder_framework",
        "peekOfCode": "out_dir = os.path.join(buildroot_dir, 'out')\ndef main():\n  parser = argparse.ArgumentParser(description='Creates FlutterEmbedder.framework for macOS')\n  parser.add_argument('--dst', type=str, required=True)\n  parser.add_argument('--arm64-out-dir', type=str, required=True)\n  parser.add_argument('--x64-out-dir', type=str, required=True)\n  parser.add_argument('--strip', action='store_true', default=False)\n  parser.add_argument('--dsym', action='store_true', default=False)\n  # TODO(godofredoc): Remove after recipes v2 have landed.\n  parser.add_argument('--zip', action='store_true', default=False)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_embedder_framework",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_ios_framework",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_ios_framework",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser(\n      description=(\n          'Creates Flutter.framework, Flutter.xcframework and '\n          'copies architecture-dependent gen_snapshot binaries to output dir'\n      )\n  )\n  parser.add_argument('--dst', type=str, required=True)\n  parser.add_argument('--x64-out-dir', type=str)\n  parser.add_argument('--arm64-out-dir', type=str, required=True)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_ios_framework",
        "documentation": {}
    },
    {
        "label": "create_extension_safe_framework",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_ios_framework",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_ios_framework",
        "peekOfCode": "def create_extension_safe_framework( # pylint: disable=too-many-arguments\n    args, dst, arm64_out_dir, simulator_x64_out_dir, simulator_arm64_out_dir\n):\n  framework = os.path.join(dst, 'Flutter.framework')\n  simulator_framework = os.path.join(dst, 'sim', 'Flutter.framework')\n  arm64_framework = os.path.join(arm64_out_dir, 'Flutter.framework')\n  simulator_x64_framework = os.path.join(simulator_x64_out_dir, 'Flutter.framework')\n  simulator_arm64_framework = os.path.join(simulator_arm64_out_dir, 'Flutter.framework')\n  if not os.path.isdir(arm64_framework):\n    print('Cannot find extension safe iOS arm64 Framework at %s' % arm64_framework)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_ios_framework",
        "documentation": {}
    },
    {
        "label": "create_framework",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_ios_framework",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_ios_framework",
        "peekOfCode": "def create_framework(  # pylint: disable=too-many-arguments\n    args, dst, framework, arm64_framework, simulator_framework,\n    simulator_x64_framework, simulator_arm64_framework\n):\n  arm64_dylib = os.path.join(arm64_framework, 'Flutter')\n  simulator_x64_dylib = os.path.join(simulator_x64_framework, 'Flutter')\n  simulator_arm64_dylib = os.path.join(simulator_arm64_framework, 'Flutter')\n  sky_utils.assert_file(arm64_dylib, 'iOS arm64 dylib')\n  sky_utils.assert_file(simulator_arm64_dylib, 'iOS simulator arm64 dylib')\n  sky_utils.assert_file(simulator_x64_dylib, 'iOS simulator x64 dylib')",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_ios_framework",
        "documentation": {}
    },
    {
        "label": "zip_archive",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_ios_framework",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_ios_framework",
        "peekOfCode": "def zip_archive(dst, args):\n  # pylint: disable=line-too-long\n  # When updating with_entitlements and without_entitlements,\n  # `binariesWithoutEntitlements` and `signedXcframeworks` should be updated in\n  # the framework's `verifyCodeSignedTestRunner`.\n  #\n  # See: https://github.com/flutter/flutter/blob/62382c7b83a16b3f48dc06c19a47f6b8667005a5/dev/bots/suite_runners/run_verify_binaries_codesigned_tests.dart#L82-L130\n  # Binaries that must be codesigned and require entitlements for particular APIs.\n  with_entitlements = ['gen_snapshot_arm64']\n  with_entitlements_file = os.path.join(dst, 'entitlements.txt')",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_ios_framework",
        "documentation": {}
    },
    {
        "label": "process_framework",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_ios_framework",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_ios_framework",
        "peekOfCode": "def process_framework(args, dst, framework_binary, dsym):\n  if dsym:\n    sky_utils.extract_dsym(framework_binary, dsym)\n  if args.strip:\n    unstripped_out = os.path.join(dst, 'Flutter.unstripped')\n    sky_utils.strip_binary(framework_binary, unstripped_copy_path=unstripped_out)\nif __name__ == '__main__':\n  sys.exit(main())",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_ios_framework",
        "documentation": {}
    },
    {
        "label": "canonical_path",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_binary",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_binary",
        "peekOfCode": "def canonical_path(path):\n  \"\"\"Returns the canonical path for the input path.\n  If the input path is not absolute, it is treated as relative to the engine\n  source tree's buildroot directory.\"\"\"\n  if os.path.isabs(path):\n    return path\n  buildroot_dir = os.path.abspath(os.path.join(os.path.realpath(__file__), '..', '..', '..', '..'))\n  return os.path.join(buildroot_dir, path)\ndef assert_file_exists(binary_path, arch):\n  if not os.path.isfile(binary_path):",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_binary",
        "documentation": {}
    },
    {
        "label": "assert_file_exists",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_binary",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_binary",
        "peekOfCode": "def assert_file_exists(binary_path, arch):\n  if not os.path.isfile(binary_path):\n    print('Cannot find macOS %s binary at %s' % (arch, binary_path))\n    sys.exit(1)\ndef create_universal_binary(in_arm64, in_x64, out):\n  subprocess.check_call(['lipo', in_arm64, in_x64, '-create', '-output', out])\ndef main():\n  parser = argparse.ArgumentParser(\n      description='Creates a universal binary from input arm64, x64 binaries'\n  )",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_binary",
        "documentation": {}
    },
    {
        "label": "create_universal_binary",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_binary",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_binary",
        "peekOfCode": "def create_universal_binary(in_arm64, in_x64, out):\n  subprocess.check_call(['lipo', in_arm64, in_x64, '-create', '-output', out])\ndef main():\n  parser = argparse.ArgumentParser(\n      description='Creates a universal binary from input arm64, x64 binaries'\n  )\n  parser.add_argument('--in-arm64', type=str, required=True)\n  parser.add_argument('--in-x64', type=str, required=True)\n  parser.add_argument('--out', type=str, required=True)\n  args = parser.parse_args()",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_binary",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_binary",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_binary",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser(\n      description='Creates a universal binary from input arm64, x64 binaries'\n  )\n  parser.add_argument('--in-arm64', type=str, required=True)\n  parser.add_argument('--in-x64', type=str, required=True)\n  parser.add_argument('--out', type=str, required=True)\n  args = parser.parse_args()\n  in_arm64 = canonical_path(args.in_arm64)\n  in_x64 = canonical_path(args.in_x64)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_binary",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_framework",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_framework",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser(\n      description='Creates FlutterMacOS.framework and FlutterMacOS.xcframework for macOS'\n  )\n  parser.add_argument('--dst', type=str, required=True)\n  parser.add_argument('--arm64-out-dir', type=str, required=True)\n  parser.add_argument('--x64-out-dir', type=str, required=True)\n  parser.add_argument('--strip', action='store_true', default=False)\n  parser.add_argument('--dsym', action='store_true', default=False)\n  parser.add_argument('--zip', action='store_true', default=False)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_framework",
        "documentation": {}
    },
    {
        "label": "zip_framework",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_framework",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_framework",
        "peekOfCode": "def zip_framework(dst, args):\n  # pylint: disable=line-too-long\n  # When updating with_entitlements and without_entitlements,\n  # `binariesWithoutEntitlements` and `signedXcframeworks` should be updated in\n  # the framework's `verifyCodeSignedTestRunner`.\n  #\n  # See: https://github.com/flutter/flutter/blob/62382c7b83a16b3f48dc06c19a47f6b8667005a5/dev/bots/suite_runners/run_verify_binaries_codesigned_tests.dart#L82-L130\n  framework_dst = os.path.join(dst, 'FlutterMacOS.framework')\n  sky_utils.write_codesign_config(os.path.join(framework_dst, 'entitlements.txt'), [])\n  sky_utils.write_codesign_config(",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_framework",
        "documentation": {}
    },
    {
        "label": "zip_xcframework_archive",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_framework",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_framework",
        "peekOfCode": "def zip_xcframework_archive(dst, args):\n  # pylint: disable=line-too-long\n  # When updating with_entitlements and without_entitlements,\n  # `binariesWithoutEntitlements` and `signedXcframeworks` should be updated in\n  # the framework's `verifyCodeSignedTestRunner`.\n  #\n  # See: https://github.com/flutter/flutter/blob/62382c7b83a16b3f48dc06c19a47f6b8667005a5/dev/bots/suite_runners/run_verify_binaries_codesigned_tests.dart#L82-L130\n  # Binaries that must be codesigned and require entitlements for particular APIs.\n  with_entitlements = []\n  with_entitlements_file = os.path.join(dst, 'entitlements.txt')",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_framework",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_gen_snapshots",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_gen_snapshots",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser(\n      description='Copies architecture-dependent gen_snapshot binaries to output dir'\n  )\n  parser.add_argument('--dst', type=str, required=True)\n  parser.add_argument('--x64-path', type=str)\n  parser.add_argument('--arm64-path', type=str)\n  parser.add_argument('--zip', action='store_true', default=False)\n  args = parser.parse_args()\n  dst = (args.dst if os.path.isabs(args.dst) else os.path.join(buildroot_dir, args.dst))",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_gen_snapshots",
        "documentation": {}
    },
    {
        "label": "embed_codesign_configuration",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_gen_snapshots",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_gen_snapshots",
        "peekOfCode": "def embed_codesign_configuration(config_path, contents):\n  with open(config_path, 'w') as file:\n    file.write('\\n'.join(contents) + '\\n')\ndef zip_archive(dst):\n  snapshot_filepath = ['gen_snapshot_arm64', 'gen_snapshot_x64']\n  embed_codesign_configuration(os.path.join(dst, 'entitlements.txt'), snapshot_filepath)\n  subprocess.check_call([\n      'zip',\n      '-r',\n      'gen_snapshot.zip',",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_gen_snapshots",
        "documentation": {}
    },
    {
        "label": "zip_archive",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_gen_snapshots",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_gen_snapshots",
        "peekOfCode": "def zip_archive(dst):\n  snapshot_filepath = ['gen_snapshot_arm64', 'gen_snapshot_x64']\n  embed_codesign_configuration(os.path.join(dst, 'entitlements.txt'), snapshot_filepath)\n  subprocess.check_call([\n      'zip',\n      '-r',\n      'gen_snapshot.zip',\n      '.',\n  ], cwd=dst)\ndef generate_gen_snapshot(gen_snapshot_path, destination):",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_gen_snapshots",
        "documentation": {}
    },
    {
        "label": "generate_gen_snapshot",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_gen_snapshots",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_gen_snapshots",
        "peekOfCode": "def generate_gen_snapshot(gen_snapshot_path, destination):\n  if not os.path.isfile(gen_snapshot_path):\n    print('Cannot find gen_snapshot at %s' % gen_snapshot_path)\n    sys.exit(1)\n  shutil.copy2(gen_snapshot_path, destination)\nif __name__ == '__main__':\n  sys.exit(main())",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_gen_snapshots",
        "documentation": {}
    },
    {
        "label": "buildroot_dir",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_gen_snapshots",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_gen_snapshots",
        "peekOfCode": "buildroot_dir = os.path.abspath(os.path.join(os.path.realpath(__file__), '..', '..', '..', '..'))\ndef main():\n  parser = argparse.ArgumentParser(\n      description='Copies architecture-dependent gen_snapshot binaries to output dir'\n  )\n  parser.add_argument('--dst', type=str, required=True)\n  parser.add_argument('--x64-path', type=str)\n  parser.add_argument('--arm64-path', type=str)\n  parser.add_argument('--zip', action='store_true', default=False)\n  args = parser.parse_args()",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_macos_gen_snapshots",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_xcframework",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_xcframework",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser(\n      description='Creates an XCFramework consisting of the specified universal frameworks'\n  )\n  parser.add_argument(\n      '--frameworks',\n      nargs='+',\n      help='The framework paths used to create the XCFramework.',\n      required=True\n  )",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_xcframework",
        "documentation": {}
    },
    {
        "label": "create_xcframework",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_xcframework",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_xcframework",
        "peekOfCode": "def create_xcframework(location, name, frameworks, dsyms=None):\n  output_dir = os.path.abspath(location)\n  output_xcframework = os.path.join(output_dir, '%s.xcframework' % name)\n  if not os.path.exists(output_dir):\n    os.makedirs(output_dir)\n  if os.path.exists(output_xcframework):\n    # Remove old xcframework.\n    shutil.rmtree(output_xcframework)\n  # xcrun xcodebuild -create-xcframework -framework foo/baz.framework \\\n  #                  -framework bar/baz.framework -output output/",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.create_xcframework",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.dist_dart_pkg",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.dist_dart_pkg",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser(description='Copy a Dart package')\n  parser.add_argument('--source', type=str, help='Source directory assembled by dart_pkg.py')\n  parser.add_argument('--dest', type=str, help='Destination directory for the package')\n  args = parser.parse_args()\n  if os.path.exists(args.dest):\n    shutil.rmtree(args.dest)\n  # dart_pkg.py will create a packages directory within the package.\n  # Do not copy this into the release output.\n  shutil.copytree(args.source, args.dest, ignore=shutil.ignore_patterns('packages'))",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.dist_dart_pkg",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.install_framework_headers",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.install_framework_headers",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser(\n      description='Removes existing files and installs the specified headers' +\n      'at the given location.'\n  )\n  parser.add_argument(\n      '--headers', nargs='+', help='The headers to install at the location.', required=True\n  )\n  parser.add_argument('--location', type=str, required=True)\n  args = parser.parse_args()",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.install_framework_headers",
        "documentation": {}
    },
    {
        "label": "assert_directory",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "peekOfCode": "def assert_directory(path, what):\n  \"\"\"Logs an error and exits with EX_NOINPUT if the specified directory doesn't exist.\"\"\"\n  if not os.path.isdir(path):\n    log_error('Cannot find %s at %s' % (what, path))\n    sys.exit(os.EX_NOINPUT)\ndef assert_file(path, what):\n  \"\"\"Logs an error and exits with EX_NOINPUT if the specified file doesn't exist.\"\"\"\n  if not os.path.isfile(path):\n    log_error('Cannot find %s at %s' % (what, path))\n    sys.exit(os.EX_NOINPUT)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "documentation": {}
    },
    {
        "label": "assert_file",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "peekOfCode": "def assert_file(path, what):\n  \"\"\"Logs an error and exits with EX_NOINPUT if the specified file doesn't exist.\"\"\"\n  if not os.path.isfile(path):\n    log_error('Cannot find %s at %s' % (what, path))\n    sys.exit(os.EX_NOINPUT)\ndef assert_valid_codesign_config(\n    framework_dir, zip_contents, entitlements, without_entitlements, unsigned_binaries\n):\n  \"\"\"Exits with exit code 1 if the codesign configuration contents are incorrect.\n  All Mach-O binaries found within zip_contents exactly must be listed in",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "documentation": {}
    },
    {
        "label": "assert_valid_codesign_config",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "peekOfCode": "def assert_valid_codesign_config(\n    framework_dir, zip_contents, entitlements, without_entitlements, unsigned_binaries\n):\n  \"\"\"Exits with exit code 1 if the codesign configuration contents are incorrect.\n  All Mach-O binaries found within zip_contents exactly must be listed in\n  either entitlements or without_entitlements.\"\"\"\n  if _contains_duplicates(entitlements):\n    log_error('ERROR: duplicate value(s) found in entitlements.txt')\n    log_error_items(sorted(entitlements))\n    sys.exit(os.EX_DATAERR)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "documentation": {}
    },
    {
        "label": "buildroot_relative_path",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "peekOfCode": "def buildroot_relative_path(path):\n  \"\"\"Returns the absolute path to the specified buildroot-relative path.\"\"\"\n  buildroot_dir = os.path.abspath(os.path.join(os.path.realpath(__file__), '..', '..', '..', '..'))\n  return os.path.join(buildroot_dir, path)\ndef copy_binary(source_path, destination_path):\n  \"\"\"Copies a binary, preserving POSIX permissions.\"\"\"\n  assert_file(source_path, 'file to copy')\n  shutil.copy2(source_path, destination_path)\ndef copy_tree(source_path, destination_path, symlinks=False):\n  \"\"\"Performs a recursive copy of a directory. If the destination path is",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "documentation": {}
    },
    {
        "label": "copy_binary",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "peekOfCode": "def copy_binary(source_path, destination_path):\n  \"\"\"Copies a binary, preserving POSIX permissions.\"\"\"\n  assert_file(source_path, 'file to copy')\n  shutil.copy2(source_path, destination_path)\ndef copy_tree(source_path, destination_path, symlinks=False):\n  \"\"\"Performs a recursive copy of a directory. If the destination path is\n  present, it is deleted first.\"\"\"\n  assert_directory(source_path, 'directory to copy')\n  shutil.rmtree(destination_path, True)\n  shutil.copytree(source_path, destination_path, symlinks=symlinks)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "documentation": {}
    },
    {
        "label": "copy_tree",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "peekOfCode": "def copy_tree(source_path, destination_path, symlinks=False):\n  \"\"\"Performs a recursive copy of a directory. If the destination path is\n  present, it is deleted first.\"\"\"\n  assert_directory(source_path, 'directory to copy')\n  shutil.rmtree(destination_path, True)\n  shutil.copytree(source_path, destination_path, symlinks=symlinks)\ndef create_fat_macos_framework(args, dst, fat_framework, arm64_framework, x64_framework):\n  \"\"\"Creates a fat framework from two arm64 and x64 frameworks.\"\"\"\n  # Clone the arm64 framework bundle as a starting point.\n  copy_tree(arm64_framework, fat_framework, symlinks=True)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "documentation": {}
    },
    {
        "label": "create_fat_macos_framework",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "peekOfCode": "def create_fat_macos_framework(args, dst, fat_framework, arm64_framework, x64_framework):\n  \"\"\"Creates a fat framework from two arm64 and x64 frameworks.\"\"\"\n  # Clone the arm64 framework bundle as a starting point.\n  copy_tree(arm64_framework, fat_framework, symlinks=True)\n  _regenerate_symlinks(fat_framework)\n  framework_dylib = get_mac_framework_dylib_path(fat_framework)\n  lipo([get_mac_framework_dylib_path(arm64_framework),\n        get_mac_framework_dylib_path(x64_framework)], framework_dylib)\n  _set_framework_permissions(fat_framework)\n  framework_dsym = fat_framework + '.dSYM' if args.dsym else None",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "documentation": {}
    },
    {
        "label": "create_zip",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "peekOfCode": "def create_zip(cwd, zip_filename, paths):\n  \"\"\"Creates a zip archive in cwd, containing a set of cwd-relative files.\n  In order to preserve the correct internal structure of macOS frameworks,\n  symlinks are preserved (-y). In order to generate reproducible builds,\n  owner/group and unix file timestamps are not included in the archive (-X).\n  \"\"\"\n  subprocess.check_call(['zip', '-r', '-X', '-y', zip_filename] + paths, cwd=cwd)\ndef _dsymutil_path():\n  \"\"\"Returns the path to dsymutil within Flutter's clang toolchain.\"\"\"\n  arch_subpath = 'mac-arm64' if platform.processor() == 'arm' else 'mac-x64'",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "documentation": {}
    },
    {
        "label": "get_framework_name",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "peekOfCode": "def get_framework_name(framework_dir):\n  \"\"\"Returns Foo given /path/to/Foo.framework.\"\"\"\n  return os.path.splitext(os.path.basename(framework_dir))[0]\ndef get_mac_framework_dylib_path(framework_dir):\n  \"\"\"Returns /path/to/Foo.framework/Versions/A/Foo given /path/to/Foo.framework.\"\"\"\n  return os.path.join(framework_dir, 'Versions', 'A', get_framework_name(framework_dir))\ndef extract_dsym(binary_path, dsym_out_path):\n  \"\"\"Extracts a dSYM bundle from the specified Mach-O binary.\"\"\"\n  arch_dir = 'mac-arm64' if platform.processor() == 'arm' else 'mac-x64'\n  dsymutil = buildroot_relative_path(",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "documentation": {}
    },
    {
        "label": "get_mac_framework_dylib_path",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "peekOfCode": "def get_mac_framework_dylib_path(framework_dir):\n  \"\"\"Returns /path/to/Foo.framework/Versions/A/Foo given /path/to/Foo.framework.\"\"\"\n  return os.path.join(framework_dir, 'Versions', 'A', get_framework_name(framework_dir))\ndef extract_dsym(binary_path, dsym_out_path):\n  \"\"\"Extracts a dSYM bundle from the specified Mach-O binary.\"\"\"\n  arch_dir = 'mac-arm64' if platform.processor() == 'arm' else 'mac-x64'\n  dsymutil = buildroot_relative_path(\n      os.path.join('flutter', 'buildtools', arch_dir, 'clang', 'bin', 'dsymutil')\n  )\n  subprocess.check_call([dsymutil, '-o', dsym_out_path, binary_path])",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "documentation": {}
    },
    {
        "label": "extract_dsym",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "peekOfCode": "def extract_dsym(binary_path, dsym_out_path):\n  \"\"\"Extracts a dSYM bundle from the specified Mach-O binary.\"\"\"\n  arch_dir = 'mac-arm64' if platform.processor() == 'arm' else 'mac-x64'\n  dsymutil = buildroot_relative_path(\n      os.path.join('flutter', 'buildtools', arch_dir, 'clang', 'bin', 'dsymutil')\n  )\n  subprocess.check_call([dsymutil, '-o', dsym_out_path, binary_path])\ndef lipo(input_binaries, output_binary):\n  \"\"\"Uses lipo to create a fat binary from a set of input binaries.\"\"\"\n  subprocess.check_call(['lipo'] + input_binaries + ['-create', '-output', output_binary])",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "documentation": {}
    },
    {
        "label": "lipo",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "peekOfCode": "def lipo(input_binaries, output_binary):\n  \"\"\"Uses lipo to create a fat binary from a set of input binaries.\"\"\"\n  subprocess.check_call(['lipo'] + input_binaries + ['-create', '-output', output_binary])\ndef log_error(message):\n  \"\"\"Writes the message to stderr, followed by a newline.\"\"\"\n  print(message, file=sys.stderr)\ndef log_error_items(items):\n  \"\"\"Writes each item indented to stderr, followed by a newline.\"\"\"\n  for item in items:\n    log_error('  ' + item)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "documentation": {}
    },
    {
        "label": "log_error",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "peekOfCode": "def log_error(message):\n  \"\"\"Writes the message to stderr, followed by a newline.\"\"\"\n  print(message, file=sys.stderr)\ndef log_error_items(items):\n  \"\"\"Writes each item indented to stderr, followed by a newline.\"\"\"\n  for item in items:\n    log_error('  ' + item)\ndef strip_binary(binary_path, unstripped_copy_path):\n  \"\"\"Makes a copy of an unstripped binary, then strips symbols from the binary.\"\"\"\n  assert_file(binary_path, 'binary to strip')",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "documentation": {}
    },
    {
        "label": "log_error_items",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "peekOfCode": "def log_error_items(items):\n  \"\"\"Writes each item indented to stderr, followed by a newline.\"\"\"\n  for item in items:\n    log_error('  ' + item)\ndef strip_binary(binary_path, unstripped_copy_path):\n  \"\"\"Makes a copy of an unstripped binary, then strips symbols from the binary.\"\"\"\n  assert_file(binary_path, 'binary to strip')\n  shutil.copyfile(binary_path, unstripped_copy_path)\n  subprocess.check_call(['strip', '-x', '-S', binary_path])\ndef write_codesign_config(output_path, paths):",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "documentation": {}
    },
    {
        "label": "strip_binary",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "peekOfCode": "def strip_binary(binary_path, unstripped_copy_path):\n  \"\"\"Makes a copy of an unstripped binary, then strips symbols from the binary.\"\"\"\n  assert_file(binary_path, 'binary to strip')\n  shutil.copyfile(binary_path, unstripped_copy_path)\n  subprocess.check_call(['strip', '-x', '-S', binary_path])\ndef write_codesign_config(output_path, paths):\n  \"\"\"Writes an Apple codesign configuration file containing the specified paths.\"\"\"\n  with open(output_path, mode='w', encoding='utf-8') as file:\n    if paths:\n      file.write('\\n'.join(paths) + '\\n')",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "documentation": {}
    },
    {
        "label": "write_codesign_config",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "description": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "peekOfCode": "def write_codesign_config(output_path, paths):\n  \"\"\"Writes an Apple codesign configuration file containing the specified paths.\"\"\"\n  with open(output_path, mode='w', encoding='utf-8') as file:\n    if paths:\n      file.write('\\n'.join(paths) + '\\n')",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.sky.tools.sky_utils",
        "documentation": {}
    },
    {
        "label": "run_command_checked",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.android.native_activity.native_activity_apk",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.android.native_activity.native_activity_apk",
        "peekOfCode": "def run_command_checked(command, env=None):\n  try:\n    env = env if env is not None else os.environ\n    subprocess.check_output(command, stderr=subprocess.STDOUT, text=True, env=env)\n  except subprocess.CalledProcessError as cpe:\n    print(cpe.output)\n    raise cpe\ndef is_mac():\n  return sys.platform == 'darwin'\ndef java_home():",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.android.native_activity.native_activity_apk",
        "documentation": {}
    },
    {
        "label": "is_mac",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.android.native_activity.native_activity_apk",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.android.native_activity.native_activity_apk",
        "peekOfCode": "def is_mac():\n  return sys.platform == 'darwin'\ndef java_home():\n  script_path = os.path.dirname(os.path.realpath(__file__))\n  if is_mac():\n    return os.path.join(\n        script_path, '..', '..', '..', 'third_party', 'java', 'openjdk', 'Contents', 'Home'\n    )\n  return os.path.join(script_path, '..', 'third_party', 'java', 'openjdk')\ndef java_bin():",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.android.native_activity.native_activity_apk",
        "documentation": {}
    },
    {
        "label": "java_home",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.android.native_activity.native_activity_apk",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.android.native_activity.native_activity_apk",
        "peekOfCode": "def java_home():\n  script_path = os.path.dirname(os.path.realpath(__file__))\n  if is_mac():\n    return os.path.join(\n        script_path, '..', '..', '..', 'third_party', 'java', 'openjdk', 'Contents', 'Home'\n    )\n  return os.path.join(script_path, '..', 'third_party', 'java', 'openjdk')\ndef java_bin():\n  return os.path.join(java_home(), 'bin')\ndef main():",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.android.native_activity.native_activity_apk",
        "documentation": {}
    },
    {
        "label": "java_bin",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.android.native_activity.native_activity_apk",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.android.native_activity.native_activity_apk",
        "peekOfCode": "def java_bin():\n  return os.path.join(java_home(), 'bin')\ndef main():\n  parser = argparse.ArgumentParser()\n  parser.add_argument('--aapt2-bin', type=str, required=True, help='The path to the aapt2 binary.')\n  parser.add_argument(\n      '--zipalign-bin', type=str, required=True, help='The path to the zipalign binary.'\n  )\n  parser.add_argument(\n      '--apksigner-bin', type=str, required=True, help='The path to the apksigner binary.'",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.android.native_activity.native_activity_apk",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.android.native_activity.native_activity_apk",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.android.native_activity.native_activity_apk",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser()\n  parser.add_argument('--aapt2-bin', type=str, required=True, help='The path to the aapt2 binary.')\n  parser.add_argument(\n      '--zipalign-bin', type=str, required=True, help='The path to the zipalign binary.'\n  )\n  parser.add_argument(\n      '--apksigner-bin', type=str, required=True, help='The path to the apksigner binary.'\n  )\n  parser.add_argument(",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.android.native_activity.native_activity_apk",
        "documentation": {}
    },
    {
        "label": "BenchmarkResult",
        "kind": 6,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.benchmark.displaylist_benchmark_parser",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.benchmark.displaylist_benchmark_parser",
        "peekOfCode": "class BenchmarkResult:  # pylint: disable=too-many-instance-attributes\n  def __init__(self, name, backend, time_unit, draw_call_count):\n    self.name = name\n    self.series = {}\n    self.series_labels = {}\n    self.backend = backend\n    self.large_y_values = False\n    self.y_limit = 200\n    self.time_unit = time_unit\n    self.draw_call_count = draw_call_count",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.benchmark.displaylist_benchmark_parser",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.benchmark.displaylist_benchmark_parser",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.benchmark.displaylist_benchmark_parser",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser()\n  parser.add_argument(\n      'filename', action='store', help='Path to the JSON output from Google Benchmark'\n  )\n  parser.add_argument(\n      '-o',\n      '--output-pdf',\n      dest='output_pdf',\n      action='store',",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.benchmark.displaylist_benchmark_parser",
        "documentation": {}
    },
    {
        "label": "error",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.benchmark.displaylist_benchmark_parser",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.benchmark.displaylist_benchmark_parser",
        "peekOfCode": "def error(message):\n  print(message)\n  sys.exit(1)\ndef extrac_attributes_label(benchmark_result):\n  # Possible attribute keys are:\n  #  AntiAliasing\n  #  HairlineStroke\n  #  StrokedStyle\n  #  FilledStyle\n  attributes = ['AntiAliasing', 'HairlineStroke', 'StrokedStyle', 'FilledStyle']",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.benchmark.displaylist_benchmark_parser",
        "documentation": {}
    },
    {
        "label": "extrac_attributes_label",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.benchmark.displaylist_benchmark_parser",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.benchmark.displaylist_benchmark_parser",
        "peekOfCode": "def extrac_attributes_label(benchmark_result):\n  # Possible attribute keys are:\n  #  AntiAliasing\n  #  HairlineStroke\n  #  StrokedStyle\n  #  FilledStyle\n  attributes = ['AntiAliasing', 'HairlineStroke', 'StrokedStyle', 'FilledStyle']\n  label = ''\n  for attr in attributes:\n    try:",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.benchmark.displaylist_benchmark_parser",
        "documentation": {}
    },
    {
        "label": "process_benchmark_data",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.benchmark.displaylist_benchmark_parser",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.benchmark.displaylist_benchmark_parser",
        "peekOfCode": "def process_benchmark_data(benchmark_json, output_pdf, output_csv):\n  benchmark_results_data = {}\n  for benchmark_result in benchmark_json:\n    # Skip aggregate results\n    if 'aggregate_name' in benchmark_result:\n      continue\n    benchmark_variant = benchmark_result['name'].split('/')\n    # The final split is always `real_time` and can be discarded\n    benchmark_variant.remove('real_time')\n    splits = len(benchmark_variant)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.benchmark.displaylist_benchmark_parser",
        "documentation": {}
    },
    {
        "label": "parse_json",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.benchmark.displaylist_benchmark_parser",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.benchmark.displaylist_benchmark_parser",
        "peekOfCode": "def parse_json(filename):\n  try:\n    json_file = open(filename, 'r')\n  except:  # pylint: disable=bare-except\n    error('Unable to load file.')\n  try:\n    json_data = json.load(json_file)\n  except JSONDecodeError:  # pylint: disable=undefined-variable\n    error('Invalid JSON. Unable to parse.')\n  return json_data['benchmarks']",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.benchmark.displaylist_benchmark_parser",
        "documentation": {}
    },
    {
        "label": "resolve_packages",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.fuchsia.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.fuchsia.run_tests",
        "peekOfCode": "def resolve_packages(tests: Iterable[Mapping[str, Any]]) -> Set[str]:\n  packages = set()\n  for test in tests:\n    if 'package' in test:\n      packages.add(test['package'])\n    else:\n      assert 'packages' in test, \\\n             'Expect either one package or a list of packages'\n      packages.update(test['packages'])\n  resolved_packages = set()",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.fuchsia.run_tests",
        "documentation": {}
    },
    {
        "label": "build_test_cases",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.fuchsia.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.fuchsia.run_tests",
        "peekOfCode": "def build_test_cases(tests: Iterable[Mapping[str, Any]]) -> List[TestCase]:\n  test_cases = []\n  for test in [t['test_command'] for t in tests]:\n    assert test.startswith('test run ')\n    test = test[len('test run '):]\n    if ' -- ' in test:\n      package, args = test.split(' -- ', 1)\n      test_cases.append(TestCase(package=package, args=args))\n    else:\n      test_cases.append(TestCase(package=test))",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.fuchsia.run_tests",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.fuchsia.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.fuchsia.run_tests",
        "peekOfCode": "def main() -> int:\n  logging.basicConfig(level=logging.INFO)\n  logging.info('Running tests in %s', OUT_DIR)\n  force_running_unattended()\n  sys.argv.append('--out-dir=' + OUT_DIR)\n  if VARIANT.endswith('_arm64') or VARIANT.endswith('_arm64_tester'):\n    sys.argv.append('--product=terminal.qemu-arm64')\n  sys.argv.append('--logs-dir=' + os.environ.get('FLUTTER_LOGS_DIR', '/tmp/log'))\n  with open(os.path.join(os.path.dirname(__file__), 'test_suites.yaml'), 'r') as file:\n    tests = yaml.safe_load(file)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.fuchsia.run_tests",
        "documentation": {}
    },
    {
        "label": "OUT_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.fuchsia.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.fuchsia.run_tests",
        "peekOfCode": "OUT_DIR = os.path.join(DIR_SRC_ROOT, 'out', VARIANT)\n# Visible for testing\ndef resolve_packages(tests: Iterable[Mapping[str, Any]]) -> Set[str]:\n  packages = set()\n  for test in tests:\n    if 'package' in test:\n      packages.add(test['package'])\n    else:\n      assert 'packages' in test, \\\n             'Expect either one package or a list of packages'",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.fuchsia.run_tests",
        "documentation": {}
    },
    {
        "label": "RunTestsTest",
        "kind": 6,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.fuchsia.run_tests_test",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.fuchsia.run_tests_test",
        "peekOfCode": "class RunTestsTest(unittest.TestCase):\n  def test_resolve_both_package_and_packages(self):\n    packages = run_tests.resolve_packages([{'package': 'abc'}, {'packages': ['abc', 'def']}])\n    self.assertEqual(\n        packages, {os.path.join(run_tests.OUT_DIR, 'abc'),\n                   os.path.join(run_tests.OUT_DIR, 'def')}\n    )\n  def test_resolve_package_make_symbolic_link(self):\n    Path(os.path.join(run_tests.OUT_DIR, 'abc-0.far')).touch()\n    packages = run_tests.resolve_packages([",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.fuchsia.run_tests_test",
        "documentation": {}
    },
    {
        "label": "run_tests.OUT_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.fuchsia.run_tests_test",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.fuchsia.run_tests_test",
        "peekOfCode": "run_tests.OUT_DIR = '/tmp/out/fuchsia_debug_x64'\nos.makedirs(run_tests.OUT_DIR, exist_ok=True)\nclass RunTestsTest(unittest.TestCase):\n  def test_resolve_both_package_and_packages(self):\n    packages = run_tests.resolve_packages([{'package': 'abc'}, {'packages': ['abc', 'def']}])\n    self.assertEqual(\n        packages, {os.path.join(run_tests.OUT_DIR, 'abc'),\n                   os.path.join(run_tests.OUT_DIR, 'def')}\n    )\n  def test_resolve_package_make_symbolic_link(self):",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.fuchsia.run_tests_test",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.rules.run_gradle",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.rules.run_gradle",
        "peekOfCode": "def main():\n  if not os.path.isdir(ANDROID_HOME):\n    raise Exception('%s (ANDROID_HOME) is not a directory' % ANDROID_HOME)\n  android_dir = sys.argv[1]\n  subprocess.check_output(\n      args=[GRADLE_BIN] + sys.argv[2:],\n      cwd=android_dir,\n      env=dict(os.environ, ANDROID_HOME=ANDROID_HOME, JAVA_HOME=JAVA_HOME),\n  )\n  return 0",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.rules.run_gradle",
        "documentation": {}
    },
    {
        "label": "SCRIPT_PATH",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.rules.run_gradle",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.rules.run_gradle",
        "peekOfCode": "SCRIPT_PATH = os.path.dirname(os.path.realpath(__file__))\nBAT = '.bat' if sys.platform.startswith(('cygwin', 'win')) else ''\nGRADLE_BIN = os.path.normpath(\n    os.path.join(SCRIPT_PATH, '..', '..', 'third_party', 'gradle', 'bin', 'gradle%s' % BAT)\n)\nANDROID_HOME = os.path.normpath(\n    os.path.join(SCRIPT_PATH, '..', '..', 'third_party', 'android_tools', 'sdk')\n)\nif platform.system() == 'Darwin':\n  JAVA_HOME = os.path.normpath(",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.rules.run_gradle",
        "documentation": {}
    },
    {
        "label": "BAT",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.rules.run_gradle",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.rules.run_gradle",
        "peekOfCode": "BAT = '.bat' if sys.platform.startswith(('cygwin', 'win')) else ''\nGRADLE_BIN = os.path.normpath(\n    os.path.join(SCRIPT_PATH, '..', '..', 'third_party', 'gradle', 'bin', 'gradle%s' % BAT)\n)\nANDROID_HOME = os.path.normpath(\n    os.path.join(SCRIPT_PATH, '..', '..', 'third_party', 'android_tools', 'sdk')\n)\nif platform.system() == 'Darwin':\n  JAVA_HOME = os.path.normpath(\n      os.path.join(SCRIPT_PATH, '..', '..', 'third_party', 'java', 'openjdk', 'Contents', 'Home')",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.rules.run_gradle",
        "documentation": {}
    },
    {
        "label": "GRADLE_BIN",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.rules.run_gradle",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.rules.run_gradle",
        "peekOfCode": "GRADLE_BIN = os.path.normpath(\n    os.path.join(SCRIPT_PATH, '..', '..', 'third_party', 'gradle', 'bin', 'gradle%s' % BAT)\n)\nANDROID_HOME = os.path.normpath(\n    os.path.join(SCRIPT_PATH, '..', '..', 'third_party', 'android_tools', 'sdk')\n)\nif platform.system() == 'Darwin':\n  JAVA_HOME = os.path.normpath(\n      os.path.join(SCRIPT_PATH, '..', '..', 'third_party', 'java', 'openjdk', 'Contents', 'Home')\n  )",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.rules.run_gradle",
        "documentation": {}
    },
    {
        "label": "ANDROID_HOME",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.rules.run_gradle",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.rules.run_gradle",
        "peekOfCode": "ANDROID_HOME = os.path.normpath(\n    os.path.join(SCRIPT_PATH, '..', '..', 'third_party', 'android_tools', 'sdk')\n)\nif platform.system() == 'Darwin':\n  JAVA_HOME = os.path.normpath(\n      os.path.join(SCRIPT_PATH, '..', '..', 'third_party', 'java', 'openjdk', 'Contents', 'Home')\n  )\nelse:\n  JAVA_HOME = os.path.normpath(\n      os.path.join(SCRIPT_PATH, '..', '..', 'third_party', 'java', 'openjdk')",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.rules.run_gradle",
        "documentation": {}
    },
    {
        "label": "install_apk",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.android_systrace_test",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.android_systrace_test",
        "peekOfCode": "def install_apk(apk_path, package_name, adb_path='adb'):\n  print('Installing APK')\n  subprocess.check_output([adb_path, 'shell', 'am', 'force-stop', package_name])\n  # Allowed to fail if APK was never installed.\n  subprocess.call([adb_path, 'uninstall', package_name], stdout=subprocess.DEVNULL)\n  subprocess.check_output([adb_path, 'install', apk_path])\ndef start_perfetto(package_name, adb_path='adb'):\n  print('Starting trace')\n  cmd = [\n      adb_path, 'shell', 'echo', \"'\" + PERFETTO_CONFIG % package_name + \"'\", '|', 'perfetto', '-c',",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.android_systrace_test",
        "documentation": {}
    },
    {
        "label": "start_perfetto",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.android_systrace_test",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.android_systrace_test",
        "peekOfCode": "def start_perfetto(package_name, adb_path='adb'):\n  print('Starting trace')\n  cmd = [\n      adb_path, 'shell', 'echo', \"'\" + PERFETTO_CONFIG % package_name + \"'\", '|', 'perfetto', '-c',\n      '-', '--txt', '-o', PERFETTO_TRACE_FILE, '--detach', PERFETTO_SESSION_KEY\n  ]\n  subprocess.check_output(cmd, stderr=subprocess.STDOUT)\ndef launch_package(package_name, activity_name, adb_path='adb'):\n  print('Scanning logcat')\n  subprocess.check_output([adb_path, 'logcat', '-c'], stderr=subprocess.STDOUT)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.android_systrace_test",
        "documentation": {}
    },
    {
        "label": "launch_package",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.android_systrace_test",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.android_systrace_test",
        "peekOfCode": "def launch_package(package_name, activity_name, adb_path='adb'):\n  print('Scanning logcat')\n  subprocess.check_output([adb_path, 'logcat', '-c'], stderr=subprocess.STDOUT)\n  logcat = subprocess.Popen([adb_path, 'logcat'],\n                            stdout=subprocess.PIPE,\n                            stderr=subprocess.STDOUT,\n                            universal_newlines=True)\n  print('Launching %s (%s)' % (package_name, activity_name))\n  subprocess.check_output([\n      adb_path, 'shell', 'am ', 'start', '-n',",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.android_systrace_test",
        "documentation": {}
    },
    {
        "label": "collect_and_validate_trace",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.android_systrace_test",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.android_systrace_test",
        "peekOfCode": "def collect_and_validate_trace(adb_path='adb'):\n  print('Fetching trace')\n  subprocess.check_output([\n      adb_path, 'shell', 'perfetto', '--attach', PERFETTO_SESSION_KEY, '--stop'\n  ],\n                          stderr=subprocess.STDOUT)\n  subprocess.check_output([adb_path, 'pull', PERFETTO_TRACE_FILE, 'trace.pb'],\n                          stderr=subprocess.STDOUT)\n  print('Validating trace')\n  traceconv = os.path.join(",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.android_systrace_test",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.android_systrace_test",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.android_systrace_test",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser()\n  parser.add_argument(\n      '--apk-path', dest='apk_path', action='store', help='Provide the path to the APK to install'\n  )\n  parser.add_argument(\n      '--package-name',\n      dest='package_name',\n      action='store',\n      help='The package name of the APK, e.g. dev.flutter.scenarios'",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.android_systrace_test",
        "documentation": {}
    },
    {
        "label": "BUILDROOT_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.android_systrace_test",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.android_systrace_test",
        "peekOfCode": "BUILDROOT_DIR = os.path.abspath(os.path.join(os.path.realpath(__file__), '..', '..', '..'))\nPERFETTO_SESSION_KEY = 'session1'\nPERFETTO_TRACE_FILE = '/data/misc/perfetto-traces/trace'\nPERFETTO_CONFIG = \"\"\"\nwrite_into_file: true\nfile_write_period_ms: 1000000000\nflush_period_ms: 1000\nbuffers: {\n    size_kb: 129024\n}",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.android_systrace_test",
        "documentation": {}
    },
    {
        "label": "PERFETTO_SESSION_KEY",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.android_systrace_test",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.android_systrace_test",
        "peekOfCode": "PERFETTO_SESSION_KEY = 'session1'\nPERFETTO_TRACE_FILE = '/data/misc/perfetto-traces/trace'\nPERFETTO_CONFIG = \"\"\"\nwrite_into_file: true\nfile_write_period_ms: 1000000000\nflush_period_ms: 1000\nbuffers: {\n    size_kb: 129024\n}\ndata_sources: {",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.android_systrace_test",
        "documentation": {}
    },
    {
        "label": "PERFETTO_TRACE_FILE",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.android_systrace_test",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.android_systrace_test",
        "peekOfCode": "PERFETTO_TRACE_FILE = '/data/misc/perfetto-traces/trace'\nPERFETTO_CONFIG = \"\"\"\nwrite_into_file: true\nfile_write_period_ms: 1000000000\nflush_period_ms: 1000\nbuffers: {\n    size_kb: 129024\n}\ndata_sources: {\n    config {",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.android_systrace_test",
        "documentation": {}
    },
    {
        "label": "PERFETTO_CONFIG",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.android_systrace_test",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.android_systrace_test",
        "peekOfCode": "PERFETTO_CONFIG = \"\"\"\nwrite_into_file: true\nfile_write_period_ms: 1000000000\nflush_period_ms: 1000\nbuffers: {\n    size_kb: 129024\n}\ndata_sources: {\n    config {\n        name: \"linux.ftrace\"",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.android_systrace_test",
        "documentation": {}
    },
    {
        "label": "EngineExecutableTask",
        "kind": 6,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "class EngineExecutableTask():  # pylint: disable=too-many-instance-attributes\n  def __init__( # pylint: disable=too-many-arguments\n      self,\n      build_dir,\n      executable_name,\n      executable_filter,\n      flags=None,\n      cwd=BUILDROOT_DIR,\n      forbidden_output=None,\n      allowed_failure_output=None,",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "FlutterTesterOptions",
        "kind": 6,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "class FlutterTesterOptions():\n  def __init__( # pylint: disable=too-many-arguments\n      self,\n      multithreaded=False,\n      enable_impeller=False,\n      enable_vm_service=False,\n      enable_microtask_profiling=False,\n      expect_failure=False\n  ):\n    self.multithreaded = multithreaded",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "DirectoryChange",
        "kind": 6,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "class DirectoryChange():\n  \"\"\"\n  A scoped change in the CWD.\n  \"\"\"\n  old_cwd: str = ''\n  new_cwd: str = ''\n  def __init__(self, new_cwd: str):\n    self.new_cwd = new_cwd\n  def __enter__(self):\n    self.old_cwd = os.getcwd()",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "print",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def print(*args, **kwargs):  # pylint: disable=redefined-builtin\n  logger.info(*args, **kwargs)\ndef print_divider(char='='):\n  logger.info('\\n')\n  for _ in range(4):\n    logger.info(''.join([char for _ in range(80)]))\n  logger.info('\\n')\ndef is_asan(build_dir):\n  with open(os.path.join(build_dir, 'args.gn')) as args:\n    if 'is_asan = true' in args.read():",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "print_divider",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def print_divider(char='='):\n  logger.info('\\n')\n  for _ in range(4):\n    logger.info(''.join([char for _ in range(80)]))\n  logger.info('\\n')\ndef is_asan(build_dir):\n  with open(os.path.join(build_dir, 'args.gn')) as args:\n    if 'is_asan = true' in args.read():\n      return True\n  return False",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "is_asan",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def is_asan(build_dir):\n  with open(os.path.join(build_dir, 'args.gn')) as args:\n    if 'is_asan = true' in args.read():\n      return True\n  return False\ndef run_cmd( # pylint: disable=too-many-arguments\n    cmd: typing.List[str],\n    cwd: str = None,\n    forbidden_output: typing.List[str] = None,\n    expect_failure: bool = False,",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "run_cmd",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def run_cmd( # pylint: disable=too-many-arguments\n    cmd: typing.List[str],\n    cwd: str = None,\n    forbidden_output: typing.List[str] = None,\n    expect_failure: bool = False,\n    env: typing.Dict[str, str] = None,\n    allowed_failure_output: typing.List[str] = None,\n    **kwargs\n) -> None:\n  if forbidden_output is None:",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "is_mac",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def is_mac():\n  return sys_platform == 'darwin'\ndef is_aarm64():\n  assert is_mac()\n  output = subprocess.check_output(['sysctl', 'machdep.cpu'])\n  text = output.decode('utf-8')\n  aarm64 = text.find('Apple') >= 0\n  if not aarm64:\n    assert text.find('GenuineIntel') >= 0\n  return aarm64",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "is_aarm64",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def is_aarm64():\n  assert is_mac()\n  output = subprocess.check_output(['sysctl', 'machdep.cpu'])\n  text = output.decode('utf-8')\n  aarm64 = text.find('Apple') >= 0\n  if not aarm64:\n    assert text.find('GenuineIntel') >= 0\n  return aarm64\ndef is_linux():\n  return sys_platform.startswith('linux')",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "is_linux",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def is_linux():\n  return sys_platform.startswith('linux')\ndef is_windows():\n  return sys_platform.startswith(('cygwin', 'win'))\ndef executable_suffix():\n  return '.exe' if is_windows() else ''\ndef find_executable_path(path):\n  if os.path.exists(path):\n    return path\n  if is_windows():",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "is_windows",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def is_windows():\n  return sys_platform.startswith(('cygwin', 'win'))\ndef executable_suffix():\n  return '.exe' if is_windows() else ''\ndef find_executable_path(path):\n  if os.path.exists(path):\n    return path\n  if is_windows():\n    exe_path = path + '.exe'\n    if os.path.exists(exe_path):",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "executable_suffix",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def executable_suffix():\n  return '.exe' if is_windows() else ''\ndef find_executable_path(path):\n  if os.path.exists(path):\n    return path\n  if is_windows():\n    exe_path = path + '.exe'\n    if os.path.exists(exe_path):\n      return exe_path\n    bat_path = path + '.bat'",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "find_executable_path",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def find_executable_path(path):\n  if os.path.exists(path):\n    return path\n  if is_windows():\n    exe_path = path + '.exe'\n    if os.path.exists(exe_path):\n      return exe_path\n    bat_path = path + '.bat'\n    if os.path.exists(bat_path):\n      return bat_path",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "vulkan_validation_env",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def vulkan_validation_env(build_dir):\n  extra_env = {\n      # pylint: disable=line-too-long\n      # Note: built from //third_party/swiftshader\n      'VK_ICD_FILENAMES': os.path.join(build_dir, 'vk_swiftshader_icd.json'),\n      # Note: built from //third_party/vulkan_validation_layers:vulkan_gen_json_files\n      # and //third_party/vulkan_validation_layers.\n      'VK_LAYER_PATH': os.path.join(build_dir, 'vulkan-data'),\n      'VK_INSTANCE_LAYERS': 'VK_LAYER_KHRONOS_validation',\n  }",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "metal_validation_env",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def metal_validation_env():\n  extra_env = {\n      # pylint: disable=line-too-long\n      # See https://developer.apple.com/documentation/metal/diagnosing_metal_programming_issues_early?language=objc\n      'MTL_SHADER_VALIDATION': '1',  # Enables all shader validation tests.\n      'MTL_SHADER_VALIDATION_GLOBAL_MEMORY':\n          '1',  # Validates accesses to device and constant memory.\n      'MTL_SHADER_VALIDATION_THREADGROUP_MEMORY': '1',  # Validates accesses to threadgroup memory.\n      'MTL_SHADER_VALIDATION_TEXTURE_USAGE': '1',  # Validates that texture references are not nil.\n  }",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "build_engine_executable_command",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def build_engine_executable_command(\n    build_dir, executable_name, flags=None, coverage=False, gtest=False\n):\n  if flags is None:\n    flags = []\n  unstripped_exe = os.path.join(build_dir, 'exe.unstripped', executable_name)\n  # We cannot run the unstripped binaries directly when coverage is enabled.\n  if is_linux() and os.path.exists(unstripped_exe) and not coverage:\n    # Use unstripped executables in order to get better symbolized crash\n    # stack traces on Linux.",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "run_engine_executable",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def run_engine_executable( # pylint: disable=too-many-arguments\n    build_dir,\n    executable_name,\n    executable_filter,\n    flags=None,\n    cwd=BUILDROOT_DIR,\n    forbidden_output=None,\n    allowed_failure_output=None,\n    expect_failure=False,\n    coverage=False,",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "run_cc_tests",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def run_cc_tests(build_dir, executable_filter, coverage, capture_core_dump):\n  logger.info('Running Engine Unit-tests.')\n  if capture_core_dump and is_linux():\n    import resource  # pylint: disable=import-outside-toplevel\n    resource.setrlimit(resource.RLIMIT_CORE, (resource.RLIM_INFINITY, resource.RLIM_INFINITY))\n  def make_test(name, flags=None, extra_env=None):\n    if flags is None:\n      flags = repeat_flags\n    if extra_env is None:\n      extra_env = {}",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "run_engine_benchmarks",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def run_engine_benchmarks(build_dir, executable_filter):\n  logger.info('Running Engine Benchmarks.')\n  icu_flags = ['--icu-data-file-path=%s' % os.path.join(build_dir, 'icudtl.dat')]\n  run_engine_executable(build_dir, 'shell_benchmarks', executable_filter, icu_flags)\n  run_engine_executable(build_dir, 'fml_benchmarks', executable_filter, icu_flags)\n  run_engine_executable(build_dir, 'ui_benchmarks', executable_filter, icu_flags)\n  run_engine_executable(build_dir, 'display_list_builder_benchmarks', executable_filter, icu_flags)\n  run_engine_executable(build_dir, 'geometry_benchmarks', executable_filter, icu_flags)\n  if is_linux():\n    run_engine_executable(build_dir, 'txt_benchmarks', executable_filter, icu_flags)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "gather_dart_test",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def gather_dart_test(build_dir, dart_file, options):\n  kernel_file_name = os.path.basename(dart_file) + '.dill'\n  kernel_file_output = os.path.join(build_dir, 'gen', kernel_file_name)\n  error_message = \"%s doesn't exist. Please run the build that populates %s\" % (\n      kernel_file_output, build_dir\n  )\n  assert os.path.isfile(kernel_file_output), error_message\n  command_args = []\n  options.apply_args(command_args)\n  dart_file_contents = open(dart_file, 'r')",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "ensure_ios_tests_are_built",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def ensure_ios_tests_are_built(ios_out_dir):\n  \"\"\"Builds the engine variant and the test dylib containing the XCTests\"\"\"\n  tmp_out_dir = os.path.join(OUT_DIR, ios_out_dir)\n  ios_test_lib = os.path.join(tmp_out_dir, 'libios_test_flutter.dylib')\n  message = []\n  message.append('gn --ios --unoptimized --runtime-mode=debug --no-lto --simulator')\n  message.append('ninja -C %s ios_test_flutter' % ios_out_dir)\n  final_message = \"%s or %s doesn't exist. Please run the following commands: \\n%s\" % (\n      ios_out_dir, ios_test_lib, '\\n'.join(message)\n  )",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "assert_expected_xcode_version",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def assert_expected_xcode_version():\n  \"\"\"Checks that the user has a version of Xcode installed\"\"\"\n  version_output = subprocess.check_output(['xcodebuild', '-version'])\n  # TODO ricardoamador: remove this check when python 2 is deprecated.\n  version_output = version_output if isinstance(version_output,\n                                                str) else version_output.decode(ENCODING)\n  version_output = version_output.strip()\n  match = re.match(r'Xcode (\\d+)', version_output)\n  message = 'Xcode must be installed to run the iOS embedding unit tests'\n  assert match, message",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "java_home",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def java_home():\n  script_path = os.path.dirname(os.path.realpath(__file__))\n  if is_mac():\n    return os.path.join(script_path, '..', 'third_party', 'java', 'openjdk', 'Contents', 'Home')\n  return os.path.join(script_path, '..', 'third_party', 'java', 'openjdk')\ndef java_bin():\n  return os.path.join(java_home(), 'bin', 'java.exe' if is_windows() else 'java')\ndef run_java_tests(executable_filter, android_variant='android_debug_unopt'):\n  \"\"\"Runs the Java JUnit unit tests for the Android embedding\"\"\"\n  test_runner_dir = os.path.join(",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "java_bin",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def java_bin():\n  return os.path.join(java_home(), 'bin', 'java.exe' if is_windows() else 'java')\ndef run_java_tests(executable_filter, android_variant='android_debug_unopt'):\n  \"\"\"Runs the Java JUnit unit tests for the Android embedding\"\"\"\n  test_runner_dir = os.path.join(\n      BUILDROOT_DIR, 'flutter', 'shell', 'platform', 'android', 'test_runner'\n  )\n  gradle_bin = os.path.join(\n      BUILDROOT_DIR, 'flutter', 'third_party', 'gradle', 'bin',\n      'gradle.bat' if is_windows() else 'gradle'",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "run_java_tests",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def run_java_tests(executable_filter, android_variant='android_debug_unopt'):\n  \"\"\"Runs the Java JUnit unit tests for the Android embedding\"\"\"\n  test_runner_dir = os.path.join(\n      BUILDROOT_DIR, 'flutter', 'shell', 'platform', 'android', 'test_runner'\n  )\n  gradle_bin = os.path.join(\n      BUILDROOT_DIR, 'flutter', 'third_party', 'gradle', 'bin',\n      'gradle.bat' if is_windows() else 'gradle'\n  )\n  flutter_jar = os.path.join(OUT_DIR, android_variant, 'flutter.jar')",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "run_android_unittest",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def run_android_unittest(test_runner_name, android_variant, adb_path):\n  tests_path = os.path.join(OUT_DIR, android_variant, test_runner_name)\n  remote_path = '/data/local/tmp'\n  remote_tests_path = os.path.join(remote_path, test_runner_name)\n  run_cmd([adb_path, 'push', tests_path, remote_path], cwd=BUILDROOT_DIR)\n  try:\n    run_cmd([adb_path, 'shell', remote_tests_path])\n  except:\n    luci_test_outputs_path = os.environ.get('FLUTTER_TEST_OUTPUTS_DIR')\n    if luci_test_outputs_path:",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "run_android_tests",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def run_android_tests(android_variant='android_debug_unopt', adb_path=None):\n  if adb_path is None:\n    adb_path = 'adb'\n  run_android_unittest('flutter_shell_native_unittests', android_variant, adb_path)\n  run_android_unittest('impeller_toolkit_android_unittests', android_variant, adb_path)\n  run_android_unittest('impeller_vulkan_android_unittests', android_variant, adb_path)\ndef run_objc_tests(ios_variant='ios_debug_sim_unopt', test_filter=None):\n  \"\"\"Runs Objective-C XCTest unit tests for the iOS embedding\"\"\"\n  assert_expected_xcode_version()\n  ios_out_dir = os.path.join(OUT_DIR, ios_variant)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "run_objc_tests",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def run_objc_tests(ios_variant='ios_debug_sim_unopt', test_filter=None):\n  \"\"\"Runs Objective-C XCTest unit tests for the iOS embedding\"\"\"\n  assert_expected_xcode_version()\n  ios_out_dir = os.path.join(OUT_DIR, ios_variant)\n  ensure_ios_tests_are_built(ios_out_dir)\n  new_simulator_name = 'IosUnitTestsSimulator'\n  # Delete simulators with this name in case any were leaked\n  # from another test run.\n  delete_simulator(new_simulator_name)\n  create_simulator = [",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "delete_simulator",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def delete_simulator(simulator_name):\n  # Will delete all simulators with this name.\n  command = [\n      'xcrun',\n      'simctl',\n      'delete',\n      simulator_name,\n  ]\n  # Let this fail if the simulator was never created.\n  run_cmd(command, expect_failure=True)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "gather_dart_tests",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def gather_dart_tests(build_dir, test_filter):\n  dart_tests_dir = os.path.join(\n      BUILDROOT_DIR,\n      'flutter',\n      'testing',\n      'dart',\n  )\n  # Now that we have the Sky packages at the hardcoded location, run `dart pub get`.\n  run_engine_executable(\n      build_dir,",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "gather_dart_smoke_test",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def gather_dart_smoke_test(build_dir, test_filter):\n  smoke_test = os.path.join(\n      BUILDROOT_DIR,\n      'flutter',\n      'testing',\n      'smoke_test_failure',\n      'fail_test.dart',\n  )\n  if test_filter is not None and os.path.basename(smoke_test) not in test_filter:\n    logger.info(\"Skipping '%s' due to filter.\", smoke_test)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "gather_dart_package_tests",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def gather_dart_package_tests(build_dir, package_path):\n  if uses_package_test_runner(package_path):\n    opts = ['test', '--reporter=expanded']\n    yield EngineExecutableTask(\n        build_dir,\n        os.path.join('dart-sdk', 'bin', 'dart'),\n        None,\n        flags=opts,\n        cwd=package_path,\n    )",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "uses_package_test_runner",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def uses_package_test_runner(package):\n  pubspec = os.path.join(package, 'pubspec.yaml')\n  if not os.path.exists(pubspec):\n    return False\n  with open(pubspec, 'r') as file:\n    # Check if either \"dependencies\" or \"dev_dependencies\" contains \"test\".\n    data = yaml.safe_load(file)\n    if data is None:\n      return False\n    deps = data.get('dependencies', {})",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "build_dart_host_test_list",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def build_dart_host_test_list():\n  dart_host_tests = [\n      os.path.join('flutter', 'ci'),\n      os.path.join('flutter', 'flutter_frontend_server'),\n      os.path.join('flutter', 'testing', 'skia_gold_client'),\n      os.path.join('flutter', 'tools', 'api_check'),\n      os.path.join('flutter', 'tools', 'build_bucket_golden_scraper'),\n      os.path.join('flutter', 'tools', 'clang_tidy'),\n      os.path.join('flutter', 'tools', 'const_finder'),\n      os.path.join('flutter', 'tools', 'engine_tool'),",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "run_benchmark_tests",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def run_benchmark_tests(build_dir):\n  test_dir = os.path.join(BUILDROOT_DIR, 'flutter', 'testing', 'benchmark')\n  dart_tests = glob.glob('%s/test/*_test.dart' % test_dir)\n  for dart_test_file in dart_tests:\n    opts = [dart_test_file]\n    run_engine_executable(\n        build_dir, os.path.join('dart-sdk', 'bin', 'dart'), None, flags=opts, cwd=test_dir\n    )\ndef worker_init(queue, level):\n  queue_handler = logging.handlers.QueueHandler(queue)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "worker_init",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def worker_init(queue, level):\n  queue_handler = logging.handlers.QueueHandler(queue)\n  log = logging.getLogger(__name__)\n  log.setLevel(logging.INFO)\n  queue_handler.setLevel(level)\n  log.addHandler(queue_handler)\ndef run_engine_tasks_in_parallel(tasks):\n  # Work around a bug in Python.\n  #\n  # The multiprocessing package relies on the win32 WaitForMultipleObjects()",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "run_engine_tasks_in_parallel",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def run_engine_tasks_in_parallel(tasks):\n  # Work around a bug in Python.\n  #\n  # The multiprocessing package relies on the win32 WaitForMultipleObjects()\n  # call, which supports waiting on a maximum of MAXIMUM_WAIT_OBJECTS (defined\n  # by Windows to be 64) handles, processes in this case. To avoid hitting\n  # this, we limit ourselves to 60 handles (since there are a couple extra\n  # processes launched for the queue reader and thread wakeup reader).\n  #\n  # See: https://bugs.python.org/issue26903",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "contains_png_recursive",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def contains_png_recursive(directory):\n  \"\"\"\n  Recursively checks if a directory contains at least one .png file.\n  Args:\n    directory: The path to the directory to check.\n  Returns:\n    True if a .png file is found, False otherwise.\n  \"\"\"\n  for _, _, files in os.walk(directory):\n    for filename in files:",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "run_impeller_golden_tests",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def run_impeller_golden_tests(build_dir: str, require_skia_gold: bool = False):\n  \"\"\"\n  Executes the impeller golden image tests from in the `variant` build.\n  \"\"\"\n  tests_path: str = os.path.join(build_dir, 'impeller_golden_tests')\n  if not os.path.exists(tests_path):\n    raise Exception(\n        'Cannot find the \"impeller_golden_tests\" executable in \"%s\". You may need to build it.' %\n        (build_dir)\n    )",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser(\n      description=\"\"\"\nIn order to learn the details of running tests in the engine, please consult the\nFlutter Wiki page on the subject: https://github.com/flutter/flutter/wiki/Testing-the-engine\n\"\"\"\n  )\n  all_types = [\n      'engine',\n      'dart',",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "THIS_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "THIS_DIR = os.path.abspath(os.path.dirname(__file__))\nsys_path.insert(0, os.path.join(THIS_DIR, '..', 'third_party', 'pyyaml', 'lib'))\nimport yaml  # pylint: disable=import-error, wrong-import-position\nSCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))\nBUILDROOT_DIR = os.path.abspath(os.path.join(os.path.realpath(__file__), '..', '..', '..'))\nOUT_DIR = os.path.join(BUILDROOT_DIR, 'out')\nGOLDEN_DIR = os.path.join(BUILDROOT_DIR, 'flutter', 'testing', 'resources')\nFONTS_DIR = os.path.join(BUILDROOT_DIR, 'flutter', 'txt', 'third_party', 'fonts')\nROBOTO_FONT_PATH = os.path.join(FONTS_DIR, 'Roboto-Regular.ttf')\nFONT_SUBSET_DIR = os.path.join(BUILDROOT_DIR, 'flutter', 'tools', 'font_subset')",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "SCRIPT_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))\nBUILDROOT_DIR = os.path.abspath(os.path.join(os.path.realpath(__file__), '..', '..', '..'))\nOUT_DIR = os.path.join(BUILDROOT_DIR, 'out')\nGOLDEN_DIR = os.path.join(BUILDROOT_DIR, 'flutter', 'testing', 'resources')\nFONTS_DIR = os.path.join(BUILDROOT_DIR, 'flutter', 'txt', 'third_party', 'fonts')\nROBOTO_FONT_PATH = os.path.join(FONTS_DIR, 'Roboto-Regular.ttf')\nFONT_SUBSET_DIR = os.path.join(BUILDROOT_DIR, 'flutter', 'tools', 'font_subset')\nENCODING = 'UTF-8'\nLOG_FILE = os.path.join(OUT_DIR, 'run_tests.log')\nlogger = logging.getLogger(__name__)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "BUILDROOT_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "BUILDROOT_DIR = os.path.abspath(os.path.join(os.path.realpath(__file__), '..', '..', '..'))\nOUT_DIR = os.path.join(BUILDROOT_DIR, 'out')\nGOLDEN_DIR = os.path.join(BUILDROOT_DIR, 'flutter', 'testing', 'resources')\nFONTS_DIR = os.path.join(BUILDROOT_DIR, 'flutter', 'txt', 'third_party', 'fonts')\nROBOTO_FONT_PATH = os.path.join(FONTS_DIR, 'Roboto-Regular.ttf')\nFONT_SUBSET_DIR = os.path.join(BUILDROOT_DIR, 'flutter', 'tools', 'font_subset')\nENCODING = 'UTF-8'\nLOG_FILE = os.path.join(OUT_DIR, 'run_tests.log')\nlogger = logging.getLogger(__name__)\n# Write console logs to stdout (by default StreamHandler uses stderr)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "OUT_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "OUT_DIR = os.path.join(BUILDROOT_DIR, 'out')\nGOLDEN_DIR = os.path.join(BUILDROOT_DIR, 'flutter', 'testing', 'resources')\nFONTS_DIR = os.path.join(BUILDROOT_DIR, 'flutter', 'txt', 'third_party', 'fonts')\nROBOTO_FONT_PATH = os.path.join(FONTS_DIR, 'Roboto-Regular.ttf')\nFONT_SUBSET_DIR = os.path.join(BUILDROOT_DIR, 'flutter', 'tools', 'font_subset')\nENCODING = 'UTF-8'\nLOG_FILE = os.path.join(OUT_DIR, 'run_tests.log')\nlogger = logging.getLogger(__name__)\n# Write console logs to stdout (by default StreamHandler uses stderr)\nconsole_logger_handler = logging.StreamHandler(sys_stdout)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "GOLDEN_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "GOLDEN_DIR = os.path.join(BUILDROOT_DIR, 'flutter', 'testing', 'resources')\nFONTS_DIR = os.path.join(BUILDROOT_DIR, 'flutter', 'txt', 'third_party', 'fonts')\nROBOTO_FONT_PATH = os.path.join(FONTS_DIR, 'Roboto-Regular.ttf')\nFONT_SUBSET_DIR = os.path.join(BUILDROOT_DIR, 'flutter', 'tools', 'font_subset')\nENCODING = 'UTF-8'\nLOG_FILE = os.path.join(OUT_DIR, 'run_tests.log')\nlogger = logging.getLogger(__name__)\n# Write console logs to stdout (by default StreamHandler uses stderr)\nconsole_logger_handler = logging.StreamHandler(sys_stdout)\nfile_logger_handler = logging.FileHandler(LOG_FILE)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "FONTS_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "FONTS_DIR = os.path.join(BUILDROOT_DIR, 'flutter', 'txt', 'third_party', 'fonts')\nROBOTO_FONT_PATH = os.path.join(FONTS_DIR, 'Roboto-Regular.ttf')\nFONT_SUBSET_DIR = os.path.join(BUILDROOT_DIR, 'flutter', 'tools', 'font_subset')\nENCODING = 'UTF-8'\nLOG_FILE = os.path.join(OUT_DIR, 'run_tests.log')\nlogger = logging.getLogger(__name__)\n# Write console logs to stdout (by default StreamHandler uses stderr)\nconsole_logger_handler = logging.StreamHandler(sys_stdout)\nfile_logger_handler = logging.FileHandler(LOG_FILE)\n# Override print so that it uses the logger instead of stdout directly.",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "ROBOTO_FONT_PATH",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "ROBOTO_FONT_PATH = os.path.join(FONTS_DIR, 'Roboto-Regular.ttf')\nFONT_SUBSET_DIR = os.path.join(BUILDROOT_DIR, 'flutter', 'tools', 'font_subset')\nENCODING = 'UTF-8'\nLOG_FILE = os.path.join(OUT_DIR, 'run_tests.log')\nlogger = logging.getLogger(__name__)\n# Write console logs to stdout (by default StreamHandler uses stderr)\nconsole_logger_handler = logging.StreamHandler(sys_stdout)\nfile_logger_handler = logging.FileHandler(LOG_FILE)\n# Override print so that it uses the logger instead of stdout directly.\ndef print(*args, **kwargs):  # pylint: disable=redefined-builtin",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "FONT_SUBSET_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "FONT_SUBSET_DIR = os.path.join(BUILDROOT_DIR, 'flutter', 'tools', 'font_subset')\nENCODING = 'UTF-8'\nLOG_FILE = os.path.join(OUT_DIR, 'run_tests.log')\nlogger = logging.getLogger(__name__)\n# Write console logs to stdout (by default StreamHandler uses stderr)\nconsole_logger_handler = logging.StreamHandler(sys_stdout)\nfile_logger_handler = logging.FileHandler(LOG_FILE)\n# Override print so that it uses the logger instead of stdout directly.\ndef print(*args, **kwargs):  # pylint: disable=redefined-builtin\n  logger.info(*args, **kwargs)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "ENCODING",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "ENCODING = 'UTF-8'\nLOG_FILE = os.path.join(OUT_DIR, 'run_tests.log')\nlogger = logging.getLogger(__name__)\n# Write console logs to stdout (by default StreamHandler uses stderr)\nconsole_logger_handler = logging.StreamHandler(sys_stdout)\nfile_logger_handler = logging.FileHandler(LOG_FILE)\n# Override print so that it uses the logger instead of stdout directly.\ndef print(*args, **kwargs):  # pylint: disable=redefined-builtin\n  logger.info(*args, **kwargs)\ndef print_divider(char='='):",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "LOG_FILE",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "LOG_FILE = os.path.join(OUT_DIR, 'run_tests.log')\nlogger = logging.getLogger(__name__)\n# Write console logs to stdout (by default StreamHandler uses stderr)\nconsole_logger_handler = logging.StreamHandler(sys_stdout)\nfile_logger_handler = logging.FileHandler(LOG_FILE)\n# Override print so that it uses the logger instead of stdout directly.\ndef print(*args, **kwargs):  # pylint: disable=redefined-builtin\n  logger.info(*args, **kwargs)\ndef print_divider(char='='):\n  logger.info('\\n')",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# Write console logs to stdout (by default StreamHandler uses stderr)\nconsole_logger_handler = logging.StreamHandler(sys_stdout)\nfile_logger_handler = logging.FileHandler(LOG_FILE)\n# Override print so that it uses the logger instead of stdout directly.\ndef print(*args, **kwargs):  # pylint: disable=redefined-builtin\n  logger.info(*args, **kwargs)\ndef print_divider(char='='):\n  logger.info('\\n')\n  for _ in range(4):",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "console_logger_handler",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "console_logger_handler = logging.StreamHandler(sys_stdout)\nfile_logger_handler = logging.FileHandler(LOG_FILE)\n# Override print so that it uses the logger instead of stdout directly.\ndef print(*args, **kwargs):  # pylint: disable=redefined-builtin\n  logger.info(*args, **kwargs)\ndef print_divider(char='='):\n  logger.info('\\n')\n  for _ in range(4):\n    logger.info(''.join([char for _ in range(80)]))\n  logger.info('\\n')",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "file_logger_handler",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "file_logger_handler = logging.FileHandler(LOG_FILE)\n# Override print so that it uses the logger instead of stdout directly.\ndef print(*args, **kwargs):  # pylint: disable=redefined-builtin\n  logger.info(*args, **kwargs)\ndef print_divider(char='='):\n  logger.info('\\n')\n  for _ in range(4):\n    logger.info(''.join([char for _ in range(80)]))\n  logger.info('\\n')\ndef is_asan(build_dir):",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "shuffle_flags",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "shuffle_flags = [\n    '--gtest_repeat=2',\n    '--gtest_shuffle',\n]\nrepeat_flags = [\n    '--repeat=2',\n]\ndef run_cc_tests(build_dir, executable_filter, coverage, capture_core_dump):\n  logger.info('Running Engine Unit-tests.')\n  if capture_core_dump and is_linux():",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "repeat_flags",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "peekOfCode": "repeat_flags = [\n    '--repeat=2',\n]\ndef run_cc_tests(build_dir, executable_filter, coverage, capture_core_dump):\n  logger.info('Running Engine Unit-tests.')\n  if capture_core_dump and is_linux():\n    import resource  # pylint: disable=import-outside-toplevel\n    resource.setrlimit(resource.RLIMIT_CORE, (resource.RLIM_INFINITY, resource.RLIM_INFINITY))\n  def make_test(name, flags=None, extra_env=None):\n    if flags is None:",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.run_tests",
        "documentation": {}
    },
    {
        "label": "xvfb_display_index",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.xvfb",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.xvfb",
        "peekOfCode": "def xvfb_display_index(_child_build_name):\n  return '9'\ndef xvfb_pid_filename(child_build_name):\n  \"\"\"Returns the filename to the Xvfb pid file.  This name is unique for each\n  builder. This is used by the linux builders.\"\"\"\n  return os.path.join(\n      tempfile.gettempdir(), 'xvfb-' + xvfb_display_index(child_build_name) + '.pid'\n  )\ndef start_virtual_x(child_build_name, build_dir):\n  \"\"\"Start a virtual X server and set the DISPLAY environment variable so sub",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.xvfb",
        "documentation": {}
    },
    {
        "label": "xvfb_pid_filename",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.xvfb",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.xvfb",
        "peekOfCode": "def xvfb_pid_filename(child_build_name):\n  \"\"\"Returns the filename to the Xvfb pid file.  This name is unique for each\n  builder. This is used by the linux builders.\"\"\"\n  return os.path.join(\n      tempfile.gettempdir(), 'xvfb-' + xvfb_display_index(child_build_name) + '.pid'\n  )\ndef start_virtual_x(child_build_name, build_dir):\n  \"\"\"Start a virtual X server and set the DISPLAY environment variable so sub\n  processes will use the virtual X server.  Also start openbox. This only works\n  on Linux and assumes that xvfb and openbox are installed.",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.xvfb",
        "documentation": {}
    },
    {
        "label": "start_virtual_x",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.xvfb",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.xvfb",
        "peekOfCode": "def start_virtual_x(child_build_name, build_dir):\n  \"\"\"Start a virtual X server and set the DISPLAY environment variable so sub\n  processes will use the virtual X server.  Also start openbox. This only works\n  on Linux and assumes that xvfb and openbox are installed.\n  Args:\n    child_build_name: The name of the build that we use for the pid file.\n        E.g., webkit-rel-linux.\n    build_dir: The directory where binaries are produced.  If this is non-empty,\n        we try running xdisplaycheck from |build_dir| to verify our X\n        connection.",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.xvfb",
        "documentation": {}
    },
    {
        "label": "stop_virtual_x",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.testing.xvfb",
        "description": ".fvm.flutter_sdk.engine.src.flutter.testing.xvfb",
        "peekOfCode": "def stop_virtual_x(child_build_name):\n  \"\"\"Try and stop the virtual X server if one was started with StartVirtualX.\n  When the X server dies, it takes down the window manager with it.\n  If a virtual x server is not running, this method does nothing.\"\"\"\n  pid_filename = xvfb_pid_filename(child_build_name)\n  if os.path.exists(pid_filename):\n    xvfb_pid = int(open(pid_filename).read())\n    print('Stopping Xvfb with pid %d ...' % xvfb_pid)\n    # If the process doesn't exist, we raise an exception that we can ignore.\n    try:",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.testing.xvfb",
        "documentation": {}
    },
    {
        "label": "utf8",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.androidx.generate_pom_file",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.androidx.generate_pom_file",
        "peekOfCode": "def utf8(s):\n  return str(s, 'utf-8') if isinstance(s, (bytes, bytearray)) else s\ndef main():\n  with open(os.path.join(THIS_DIR, 'files.json')) as f:\n    dependencies = json.load(f)\n  parser = argparse.ArgumentParser(description='Generate the POM file for the engine artifacts')\n  parser.add_argument(\n      '--engine-artifact-id',\n      type=utf8,\n      required=True,",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.androidx.generate_pom_file",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.androidx.generate_pom_file",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.androidx.generate_pom_file",
        "peekOfCode": "def main():\n  with open(os.path.join(THIS_DIR, 'files.json')) as f:\n    dependencies = json.load(f)\n  parser = argparse.ArgumentParser(description='Generate the POM file for the engine artifacts')\n  parser.add_argument(\n      '--engine-artifact-id',\n      type=utf8,\n      required=True,\n      help='The artifact id. e.g. android_arm_release'\n  )",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.androidx.generate_pom_file",
        "documentation": {}
    },
    {
        "label": "THIS_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.androidx.generate_pom_file",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.androidx.generate_pom_file",
        "peekOfCode": "THIS_DIR = os.path.abspath(os.path.dirname(__file__))\n# The template for the POM file.\nPOM_FILE_CONTENT = '''<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>io.flutter</groupId>\n  <artifactId>{0}</artifactId>\n  <version>{1}</version>\n  <packaging>jar</packaging>",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.androidx.generate_pom_file",
        "documentation": {}
    },
    {
        "label": "POM_FILE_CONTENT",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.androidx.generate_pom_file",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.androidx.generate_pom_file",
        "peekOfCode": "POM_FILE_CONTENT = '''<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>io.flutter</groupId>\n  <artifactId>{0}</artifactId>\n  <version>{1}</version>\n  <packaging>jar</packaging>\n  <dependencies>\n    {2}",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.androidx.generate_pom_file",
        "documentation": {}
    },
    {
        "label": "POM_DEPENDENCY",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.androidx.generate_pom_file",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.androidx.generate_pom_file",
        "peekOfCode": "POM_DEPENDENCY = '''\n    <dependency>\n      <groupId>{0}</groupId>\n      <artifactId>{1}</artifactId>\n      <version>{2}</version>\n      <scope>compile</scope>\n    </dependency>\n'''\nMAVEN_METADATA_CONTENT = '''\n<metadata xmlns=\"http://maven.apache.org/METADATA/1.1.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/METADATA/1.1.0 http://maven.apache.org/xsd/metadata-1.1.0.xsd\" modelVersion=\"1.1.0\">",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.androidx.generate_pom_file",
        "documentation": {}
    },
    {
        "label": "MAVEN_METADATA_CONTENT",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.androidx.generate_pom_file",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.androidx.generate_pom_file",
        "peekOfCode": "MAVEN_METADATA_CONTENT = '''\n<metadata xmlns=\"http://maven.apache.org/METADATA/1.1.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/METADATA/1.1.0 http://maven.apache.org/xsd/metadata-1.1.0.xsd\" modelVersion=\"1.1.0\">\n  <groupId>io.flutter</groupId>\n  <artifactId>{0}</artifactId>\n  <version>{1}</version>\n  <versioning>\n    <versions>\n      <version>{1}</version>\n    </versions>\n    <snapshot>",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.androidx.generate_pom_file",
        "documentation": {}
    },
    {
        "label": "fail_tests",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "peekOfCode": "def fail_tests(font_subset):\n  return [\n      ([font_subset, 'output.ttf', 'does-not-exist.ttf'], [\n          '1',\n      ]),  # non-existent input font\n      ([font_subset, 'output.ttf', MATERIAL_TTF], [\n          '0xFFFFFFFF',\n      ]),  # Value too big.\n      ([font_subset, 'output.ttf', MATERIAL_TTF], [\n          '-1',",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "documentation": {}
    },
    {
        "label": "run_cmd",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "peekOfCode": "def run_cmd(cmd, codepoints, fail=False):\n  print('Running command:')\n  print('       %s' % ' '.join(cmd))\n  print('STDIN: \"%s\"' % ' '.join(codepoints))\n  p = subprocess.Popen(\n      cmd, stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE, cwd=SRC_DIR\n  )\n  stdout_data, stderr_data = p.communicate(input=' '.join(codepoints).encode())\n  if p.returncode != 0 and fail == False:\n    print('FAILURE: %s' % p.returncode)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "documentation": {}
    },
    {
        "label": "test_zip",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "peekOfCode": "def test_zip(font_subset_zip, exe):\n  with ZipFile(font_subset_zip, 'r') as zip:\n    files = zip.namelist()\n    if 'font-subset%s' % exe not in files:\n      print('expected %s to contain font-subset%s' % (files, exe))\n      return 1\n    return 0\n# Maps the platform name to the output directory of the font artifacts.\ndef platform_to_path(os, cpu):\n  d = {",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "documentation": {}
    },
    {
        "label": "platform_to_path",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "peekOfCode": "def platform_to_path(os, cpu):\n  d = {\n      'darwin': 'darwin-',\n      'linux': 'linux-',\n      'linux2': 'linux-',\n      'cygwin': 'windows-',\n      'win': 'windows-',\n      'win32': 'windows-',\n  }\n  return d[os] + cpu",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser(description='Runs font-subset tests.')\n  parser.add_argument('--variant', type=str, required=True)\n  parser.add_argument('--target-cpu', type=str, default='x64')\n  args = parser.parse_args()\n  variant = args.variant\n  is_windows = sys.platform.startswith(('cygwin', 'win'))\n  exe = '.exe' if is_windows else ''\n  font_subset = os.path.join(SRC_DIR, 'out', variant, 'font-subset' + exe)\n  font_subset_zip = os.path.join(",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "documentation": {}
    },
    {
        "label": "SCRIPT_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "peekOfCode": "SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))\nSRC_DIR = os.path.normpath(os.path.join(SCRIPT_DIR, '..', '..', '..'))\nMATERIAL_TTF = os.path.join(SCRIPT_DIR, 'fixtures', 'MaterialIcons-Regular.ttf')\nVARIABLE_MATERIAL_TTF = os.path.join(SCRIPT_DIR, 'fixtures', 'MaterialSymbols-Variable.ttf')\nCOMPARE_TESTS = (\n    (True, '1.ttf', MATERIAL_TTF, [r'57347']),\n    (True, '1.ttf', MATERIAL_TTF, [r'0xE003']),\n    (True, '1.ttf', MATERIAL_TTF, [r'\\uE003']),\n    (False, '1.ttf', MATERIAL_TTF, [r'57348']),  # False because different codepoint\n    (True, '2.ttf', MATERIAL_TTF, [r'0xE003', r'0xE004']),",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "documentation": {}
    },
    {
        "label": "SRC_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "peekOfCode": "SRC_DIR = os.path.normpath(os.path.join(SCRIPT_DIR, '..', '..', '..'))\nMATERIAL_TTF = os.path.join(SCRIPT_DIR, 'fixtures', 'MaterialIcons-Regular.ttf')\nVARIABLE_MATERIAL_TTF = os.path.join(SCRIPT_DIR, 'fixtures', 'MaterialSymbols-Variable.ttf')\nCOMPARE_TESTS = (\n    (True, '1.ttf', MATERIAL_TTF, [r'57347']),\n    (True, '1.ttf', MATERIAL_TTF, [r'0xE003']),\n    (True, '1.ttf', MATERIAL_TTF, [r'\\uE003']),\n    (False, '1.ttf', MATERIAL_TTF, [r'57348']),  # False because different codepoint\n    (True, '2.ttf', MATERIAL_TTF, [r'0xE003', r'0xE004']),\n    (True, '2.ttf', MATERIAL_TTF, [r'0xE003',",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "documentation": {}
    },
    {
        "label": "MATERIAL_TTF",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "peekOfCode": "MATERIAL_TTF = os.path.join(SCRIPT_DIR, 'fixtures', 'MaterialIcons-Regular.ttf')\nVARIABLE_MATERIAL_TTF = os.path.join(SCRIPT_DIR, 'fixtures', 'MaterialSymbols-Variable.ttf')\nCOMPARE_TESTS = (\n    (True, '1.ttf', MATERIAL_TTF, [r'57347']),\n    (True, '1.ttf', MATERIAL_TTF, [r'0xE003']),\n    (True, '1.ttf', MATERIAL_TTF, [r'\\uE003']),\n    (False, '1.ttf', MATERIAL_TTF, [r'57348']),  # False because different codepoint\n    (True, '2.ttf', MATERIAL_TTF, [r'0xE003', r'0xE004']),\n    (True, '2.ttf', MATERIAL_TTF, [r'0xE003',\n                                   r'optional:0xE004']),  # Optional codepoint that is found",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "documentation": {}
    },
    {
        "label": "VARIABLE_MATERIAL_TTF",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "peekOfCode": "VARIABLE_MATERIAL_TTF = os.path.join(SCRIPT_DIR, 'fixtures', 'MaterialSymbols-Variable.ttf')\nCOMPARE_TESTS = (\n    (True, '1.ttf', MATERIAL_TTF, [r'57347']),\n    (True, '1.ttf', MATERIAL_TTF, [r'0xE003']),\n    (True, '1.ttf', MATERIAL_TTF, [r'\\uE003']),\n    (False, '1.ttf', MATERIAL_TTF, [r'57348']),  # False because different codepoint\n    (True, '2.ttf', MATERIAL_TTF, [r'0xE003', r'0xE004']),\n    (True, '2.ttf', MATERIAL_TTF, [r'0xE003',\n                                   r'optional:0xE004']),  # Optional codepoint that is found\n    (True, '2.ttf', MATERIAL_TTF, [",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "documentation": {}
    },
    {
        "label": "COMPARE_TESTS",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "peekOfCode": "COMPARE_TESTS = (\n    (True, '1.ttf', MATERIAL_TTF, [r'57347']),\n    (True, '1.ttf', MATERIAL_TTF, [r'0xE003']),\n    (True, '1.ttf', MATERIAL_TTF, [r'\\uE003']),\n    (False, '1.ttf', MATERIAL_TTF, [r'57348']),  # False because different codepoint\n    (True, '2.ttf', MATERIAL_TTF, [r'0xE003', r'0xE004']),\n    (True, '2.ttf', MATERIAL_TTF, [r'0xE003',\n                                   r'optional:0xE004']),  # Optional codepoint that is found\n    (True, '2.ttf', MATERIAL_TTF, [\n        r'0xE003',",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.font_subset.test",
        "documentation": {}
    },
    {
        "label": "collect",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.kernel.convert_manifest_to_json",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.kernel.convert_manifest_to_json",
        "peekOfCode": "def collect(path_prefix, lines):\n  '''Reads the kernel manifest and creates an array of Entry objects.\n    - lines: a list of lines from the manifest\n    '''\n  entries = []\n  for line in lines:\n    values = line.split(\"=\", 1)\n    entries.append(Entry(source=path_prefix + values[1], dest=values[0]))\n  return entries\ndef main():",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.kernel.convert_manifest_to_json",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.kernel.convert_manifest_to_json",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.kernel.convert_manifest_to_json",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser(description=__doc__)\n  parser.add_argument(\n      '--path_prefix', help='Directory path containing the manifest entry sources', required=True\n  )\n  parser.add_argument('--input', help='Path to original manifest', required=True)\n  parser.add_argument('--output', help='Path to the updated json file', required=True)\n  args = parser.parse_args()\n  with open(args.input, 'r') as input_file:\n    contents = input_file.read().splitlines()",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.kernel.convert_manifest_to_json",
        "documentation": {}
    },
    {
        "label": "Entry",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.kernel.convert_manifest_to_json",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.kernel.convert_manifest_to_json",
        "peekOfCode": "Entry = collections.namedtuple('Entry', ['source', 'dest'])\ndef collect(path_prefix, lines):\n  '''Reads the kernel manifest and creates an array of Entry objects.\n    - lines: a list of lines from the manifest\n    '''\n  entries = []\n  for line in lines:\n    values = line.split(\"=\", 1)\n    entries.append(Entry(source=path_prefix + values[1], dest=values[0]))\n  return entries",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.kernel.convert_manifest_to_json",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.gen_app_invocation",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.gen_app_invocation",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser(description='Generate a script that invokes a Dart application')\n  parser.add_argument('--out', help='Path to the invocation file to generate', required=True)\n  parser.add_argument('--dart', help='Path to the Dart binary', required=True)\n  parser.add_argument('--snapshot', help='Path to the app snapshot', required=True)\n  args = parser.parse_args()\n  app_file = args.out\n  app_path = os.path.dirname(app_file)\n  if not os.path.exists(app_path):\n    os.makedirs(app_path)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.gen_app_invocation",
        "documentation": {}
    },
    {
        "label": "PackageConfig",
        "kind": 6,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.gen_dart_package_config",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.gen_dart_package_config",
        "peekOfCode": "class PackageConfig:\n  # The version of the package config.\n  VERSION = 2\n  # The name of the generator which gets written to the json output\n  GENERATOR_NAME = os.path.basename(__file__)\n  def __init__(self, packages):\n    self.packages = packages\n  def asdict(self):\n    \"\"\"Converts the package config to a dictionary\"\"\"\n    return {",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.gen_dart_package_config",
        "documentation": {}
    },
    {
        "label": "language_version_from_pubspec",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.gen_dart_package_config",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.gen_dart_package_config",
        "peekOfCode": "def language_version_from_pubspec(pubspec):\n  \"\"\"Parse the content of a pubspec.yaml\"\"\"\n  with open(pubspec) as pubspec:\n    parsed = yaml.safe_load(pubspec)\n    if not parsed:\n      return DEFAULT_LANGUAGE_VERSION\n    # If any format like:\n    #   sdk: '>=a.b'\n    #   sdk: '^a.b'\n    #   sdk: 'a.b'",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.gen_dart_package_config",
        "documentation": {}
    },
    {
        "label": "collect_packages",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.gen_dart_package_config",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.gen_dart_package_config",
        "peekOfCode": "def collect_packages(items, relative_to):\n  \"\"\"Reads metadata produced by GN to create lists of packages and pubspecs.\n        - items: a list of objects collected from gn\n        - relative_to: The directory which the packages are relative to. This is\n          the location that contains the package_config.json file\n    Returns None if there was a problem parsing packages\n    \"\"\"\n  packages = []\n  pubspec_paths = []\n  for item in items:",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.gen_dart_package_config",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.gen_dart_package_config",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.gen_dart_package_config",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser(description=__doc__)\n  parser.add_argument('--input', help='Path to original package_config', required=True)\n  parser.add_argument('--output', help='Path to the updated package_config', required=True)\n  parser.add_argument('--root', help='Path to fuchsia root', required=True)\n  parser.add_argument('--depfile', help='Path to the depfile', required=True)\n  args = parser.parse_args()\n  with open(args.input, 'r') as input_file:\n    contents = json.load(input_file)\n  output_dir = os.path.dirname(os.path.abspath(args.output))",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.gen_dart_package_config",
        "documentation": {}
    },
    {
        "label": "THIS_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.gen_dart_package_config",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.gen_dart_package_config",
        "peekOfCode": "THIS_DIR = os.path.abspath(os.path.dirname(__file__))\nsys.path.insert(0, os.path.join(THIS_DIR, '..', '..', '..', 'third_party', 'pyyaml', 'lib'))\nimport yaml\nDEFAULT_LANGUAGE_VERSION = '2.8'\nPackage = collections.namedtuple('Package', ['name', 'rootUri', 'languageVersion', 'packageUri'])\nclass PackageConfig:\n  # The version of the package config.\n  VERSION = 2\n  # The name of the generator which gets written to the json output\n  GENERATOR_NAME = os.path.basename(__file__)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.gen_dart_package_config",
        "documentation": {}
    },
    {
        "label": "DEFAULT_LANGUAGE_VERSION",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.gen_dart_package_config",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.gen_dart_package_config",
        "peekOfCode": "DEFAULT_LANGUAGE_VERSION = '2.8'\nPackage = collections.namedtuple('Package', ['name', 'rootUri', 'languageVersion', 'packageUri'])\nclass PackageConfig:\n  # The version of the package config.\n  VERSION = 2\n  # The name of the generator which gets written to the json output\n  GENERATOR_NAME = os.path.basename(__file__)\n  def __init__(self, packages):\n    self.packages = packages\n  def asdict(self):",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.gen_dart_package_config",
        "documentation": {}
    },
    {
        "label": "Package",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.gen_dart_package_config",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.gen_dart_package_config",
        "peekOfCode": "Package = collections.namedtuple('Package', ['name', 'rootUri', 'languageVersion', 'packageUri'])\nclass PackageConfig:\n  # The version of the package config.\n  VERSION = 2\n  # The name of the generator which gets written to the json output\n  GENERATOR_NAME = os.path.basename(__file__)\n  def __init__(self, packages):\n    self.packages = packages\n  def asdict(self):\n    \"\"\"Converts the package config to a dictionary\"\"\"",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.gen_dart_package_config",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.merge_deps_sources",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.merge_deps_sources",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser(\n      'Merges sources of a Dart target and its dependencies', fromfile_prefix_chars='@'\n  )\n  parser.add_argument(\n      '--output', help='Path to output the final list', type=argparse.FileType('w'), required=True\n  )\n  parser.add_argument(\n      '--depfile',\n      help='Path to the depfile to generate',",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.merge_deps_sources",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.verify_sources",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.verify_sources",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser(\n      \"Verifies that all .dart files are included in sources, and sources don't include nonexsitent files\"\n  )\n  parser.add_argument(\n      \"--source_dir\", help=\"Path to the directory containing the package sources\", required=True\n  )\n  parser.add_argument(\"--stamp\", help=\"File to touch when source checking succeeds\", required=True)\n  parser.add_argument(\"sources\", help=\"source files\", nargs=argparse.REMAINDER)\n  args = parser.parse_args()",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.dart.verify_sources",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.toolchain.copy",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.toolchain.copy",
        "peekOfCode": "def main():\n  if len(sys.argv) != 3:\n    print('usage: copy.py source dest', file=sys.stderr)\n    return 1\n  source = sys.argv[1]\n  dest = sys.argv[2]\n  if os.path.isdir(source):\n    print(f'{source} is a directory, tool \"copy\" does not support directory copies')\n    return 1\n  if os.path.exists(dest):",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.toolchain.copy",
        "documentation": {}
    },
    {
        "label": "EnsureParentExists",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "peekOfCode": "def EnsureParentExists(path):\n  dir_name, _ = os.path.split(path)\n  if not os.path.exists(dir_name):\n    os.makedirs(dir_name)\ndef CopyPath(src, dst):\n  try:\n    EnsureParentExists(dst)\n    shutil.copytree(src, dst)\n  except OSError as exc:\n    if exc.errno == errno.ENOTDIR:",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "documentation": {}
    },
    {
        "label": "CopyPath",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "peekOfCode": "def CopyPath(src, dst):\n  try:\n    EnsureParentExists(dst)\n    shutil.copytree(src, dst)\n  except OSError as exc:\n    if exc.errno == errno.ENOTDIR:\n      shutil.copy(src, dst)\n    else:\n      raise\ndef IsLinux():",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "documentation": {}
    },
    {
        "label": "IsLinux",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "peekOfCode": "def IsLinux():\n  return platform.system() == 'Linux'\ndef IsMac():\n  return platform.system() == 'Darwin'\ndef GetFuchsiaSDKPath():\n  # host_os references the gn host_os\n  # https://gn.googlesource.com/gn/+/main/docs/reference.md#var_host_os\n  host_os = ''\n  if IsLinux():\n    host_os = 'linux'",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "documentation": {}
    },
    {
        "label": "IsMac",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "peekOfCode": "def IsMac():\n  return platform.system() == 'Darwin'\ndef GetFuchsiaSDKPath():\n  # host_os references the gn host_os\n  # https://gn.googlesource.com/gn/+/main/docs/reference.md#var_host_os\n  host_os = ''\n  if IsLinux():\n    host_os = 'linux'\n  elif IsMac():\n    host_os = 'mac'",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "documentation": {}
    },
    {
        "label": "GetFuchsiaSDKPath",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "peekOfCode": "def GetFuchsiaSDKPath():\n  # host_os references the gn host_os\n  # https://gn.googlesource.com/gn/+/main/docs/reference.md#var_host_os\n  host_os = ''\n  if IsLinux():\n    host_os = 'linux'\n  elif IsMac():\n    host_os = 'mac'\n  else:\n    host_os = 'windows'",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "documentation": {}
    },
    {
        "label": "RemoveDirectoryIfExists",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "peekOfCode": "def RemoveDirectoryIfExists(path):\n  if not os.path.exists(path):\n    return\n  if os.path.isfile(path) or os.path.islink(path):\n    os.unlink(path)\n  else:\n    shutil.rmtree(path)\ndef CopyFiles(source, destination):\n  try:\n    shutil.copytree(source, destination)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "documentation": {}
    },
    {
        "label": "CopyFiles",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "peekOfCode": "def CopyFiles(source, destination):\n  try:\n    shutil.copytree(source, destination)\n  except OSError as error:\n    if error.errno == errno.ENOTDIR:\n      shutil.copy(source, destination)\n    else:\n      raise\ndef FindFile(name, path):\n  for root, dirs, files in os.walk(path):",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "documentation": {}
    },
    {
        "label": "FindFile",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "peekOfCode": "def FindFile(name, path):\n  for root, dirs, files in os.walk(path):\n    if name in files:\n      return os.path.join(root, name)\ndef FindFileAndCopyTo(file_name, source, dest_parent, dst_name=None):\n  found = FindFile(file_name, source)\n  if not dst_name:\n    dst_name = file_name\n  if found:\n    dst_path = os.path.join(dest_parent, dst_name)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "documentation": {}
    },
    {
        "label": "FindFileAndCopyTo",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "peekOfCode": "def FindFileAndCopyTo(file_name, source, dest_parent, dst_name=None):\n  found = FindFile(file_name, source)\n  if not dst_name:\n    dst_name = file_name\n  if found:\n    dst_path = os.path.join(dest_parent, dst_name)\n    CopyPath(found, dst_path)\ndef CopyGenSnapshotIfExists(source, destination):\n  source_root = os.path.join(_out_dir, source)\n  destination_base = os.path.join(destination, 'dart_binaries')",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "documentation": {}
    },
    {
        "label": "CopyGenSnapshotIfExists",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "peekOfCode": "def CopyGenSnapshotIfExists(source, destination):\n  source_root = os.path.join(_out_dir, source)\n  destination_base = os.path.join(destination, 'dart_binaries')\n  FindFileAndCopyTo('gen_snapshot', source_root, destination_base)\n  FindFileAndCopyTo('gen_snapshot_product', source_root, destination_base)\n  FindFileAndCopyTo(\n      'kernel_compiler.dart.snapshot', source_root, destination_base, 'kernel_compiler.snapshot'\n  )\n  FindFileAndCopyTo(\n      'frontend_server.dart.snapshot', source_root, destination_base,",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "documentation": {}
    },
    {
        "label": "CopyFlutterTesterBinIfExists",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "peekOfCode": "def CopyFlutterTesterBinIfExists(source, destination):\n  source_root = os.path.join(_out_dir, source)\n  destination_base = os.path.join(destination, 'flutter_binaries')\n  FindFileAndCopyTo('flutter_tester', source_root, destination_base)\ndef CopyZirconFFILibIfExists(source, destination):\n  source_root = os.path.join(_out_dir, source)\n  destination_base = os.path.join(destination, 'flutter_binaries')\n  FindFileAndCopyTo('libzircon_ffi.so', source_root, destination_base)\ndef CopyToBucketWithMode(source, destination, aot, product, runner_type, api_level):\n  mode = 'aot' if aot else 'jit'",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "documentation": {}
    },
    {
        "label": "CopyZirconFFILibIfExists",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "peekOfCode": "def CopyZirconFFILibIfExists(source, destination):\n  source_root = os.path.join(_out_dir, source)\n  destination_base = os.path.join(destination, 'flutter_binaries')\n  FindFileAndCopyTo('libzircon_ffi.so', source_root, destination_base)\ndef CopyToBucketWithMode(source, destination, aot, product, runner_type, api_level):\n  mode = 'aot' if aot else 'jit'\n  source_root = os.path.join(_out_dir, source)\n  destination = os.path.join(_bucket_directory, destination, mode)\n  far_file = '%s_%s%s_runner-0.far' % (runner_type, mode, '_product' if product else '')\n  CopyPath('%s/%s' % (source_root, far_file), '%s/%s' % (destination, far_file))",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "documentation": {}
    },
    {
        "label": "CopyToBucketWithMode",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "peekOfCode": "def CopyToBucketWithMode(source, destination, aot, product, runner_type, api_level):\n  mode = 'aot' if aot else 'jit'\n  source_root = os.path.join(_out_dir, source)\n  destination = os.path.join(_bucket_directory, destination, mode)\n  far_file = '%s_%s%s_runner-0.far' % (runner_type, mode, '_product' if product else '')\n  CopyPath('%s/%s' % (source_root, far_file), '%s/%s' % (destination, far_file))\n  patched_sdk_dirname = '%s_runner_patched_sdk' % runner_type\n  patched_sdk_dir = os.path.join(source_root, patched_sdk_dirname)\n  dest_sdk_path = os.path.join(destination, patched_sdk_dirname)\n  if not os.path.exists(dest_sdk_path):",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "documentation": {}
    },
    {
        "label": "CopyToBucket",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "peekOfCode": "def CopyToBucket(src, dst, product=False):\n  api_level = ReadTargetAPILevel()\n  CopyToBucketWithMode(src, dst, False, product, 'flutter', api_level)\n  CopyToBucketWithMode(src, dst, True, product, 'flutter', api_level)\n  CopyToBucketWithMode(src, dst, False, product, 'dart', api_level)\n  CopyToBucketWithMode(src, dst, True, product, 'dart', api_level)\ndef ReadTargetAPILevel():\n  filename = os.path.join(os.path.dirname(__file__), 'gn-sdk/src/gn_configs.gni')\n  with open(filename) as f:\n    for line in f:",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "documentation": {}
    },
    {
        "label": "ReadTargetAPILevel",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "peekOfCode": "def ReadTargetAPILevel():\n  filename = os.path.join(os.path.dirname(__file__), 'gn-sdk/src/gn_configs.gni')\n  with open(filename) as f:\n    for line in f:\n      line = line.strip()\n      if line.startswith('fuchsia_target_api_level'):\n        return line.split('=')[-1].strip()\n  assert False, 'No fuchsia_target_api_level found in ' + filename\ndef CopyVulkanDepsToBucket(src, dst, arch):\n  sdk_path = GetFuchsiaSDKPath()",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "documentation": {}
    },
    {
        "label": "CopyVulkanDepsToBucket",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "peekOfCode": "def CopyVulkanDepsToBucket(src, dst, arch):\n  sdk_path = GetFuchsiaSDKPath()\n  deps_bucket_path = os.path.join(_bucket_directory, dst)\n  if not os.path.exists(deps_bucket_path):\n    FindFileAndCopyTo('VkLayer_khronos_validation.json', '%s/pkg' % (sdk_path), deps_bucket_path)\n    FindFileAndCopyTo(\n        'VkLayer_khronos_validation.so', '%s/arch/%s' % (sdk_path, arch), deps_bucket_path\n    )\ndef CopyIcuDepsToBucket(src, dst):\n  source_root = os.path.join(_out_dir, src)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "documentation": {}
    },
    {
        "label": "CopyIcuDepsToBucket",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "peekOfCode": "def CopyIcuDepsToBucket(src, dst):\n  source_root = os.path.join(_out_dir, src)\n  deps_bucket_path = os.path.join(_bucket_directory, dst)\n  FindFileAndCopyTo('icudtl.dat', source_root, deps_bucket_path)\ndef CopyBuildToBucket(runtime_mode, arch, optimized, product):\n  unopt = \"_unopt\" if not optimized else \"\"\n  out_dir = 'fuchsia_%s%s_%s/' % (runtime_mode, unopt, arch)\n  bucket_dir = 'flutter/%s/%s%s/' % (arch, runtime_mode, unopt)\n  deps_dir = 'flutter/%s/deps/' % (arch)\n  CopyToBucket(out_dir, bucket_dir, product)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "documentation": {}
    },
    {
        "label": "CopyBuildToBucket",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "peekOfCode": "def CopyBuildToBucket(runtime_mode, arch, optimized, product):\n  unopt = \"_unopt\" if not optimized else \"\"\n  out_dir = 'fuchsia_%s%s_%s/' % (runtime_mode, unopt, arch)\n  bucket_dir = 'flutter/%s/%s%s/' % (arch, runtime_mode, unopt)\n  deps_dir = 'flutter/%s/deps/' % (arch)\n  CopyToBucket(out_dir, bucket_dir, product)\n  CopyVulkanDepsToBucket(out_dir, deps_dir, arch)\n  CopyIcuDepsToBucket(out_dir, deps_dir)\n  # Copy the CIPD YAML template from the source directory to be next to the bucket\n  # we are about to package.",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "documentation": {}
    },
    {
        "label": "CheckCIPDPackageExists",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "peekOfCode": "def CheckCIPDPackageExists(package_name, tag):\n  '''Check to see if the current package/tag combo has been published'''\n  command = [\n      'cipd',\n      'search',\n      package_name,\n      '-tag',\n      tag,\n  ]\n  stdout = subprocess.check_output(command)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "documentation": {}
    },
    {
        "label": "RunCIPDCommandWithRetries",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "peekOfCode": "def RunCIPDCommandWithRetries(command):\n  # Retry up to three times.  We've seen CIPD fail on verification in some\n  # instances. Normally verification takes slightly more than 1 minute when\n  # it succeeds.\n  num_tries = 3\n  for tries in range(num_tries):\n    try:\n      subprocess.check_call(command, cwd=_bucket_directory)\n      break\n    except subprocess.CalledProcessError:",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "documentation": {}
    },
    {
        "label": "ProcessCIPDPackage",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "peekOfCode": "def ProcessCIPDPackage(upload, engine_version, content_hash):\n  if not upload or not IsLinux():\n    RunCIPDCommandWithRetries([\n        'cipd', 'pkg-build', '-pkg-def', 'fuchsia.cipd.yaml', '-out',\n        os.path.join(_bucket_directory, 'fuchsia.cipd')\n    ])\n    return\n  # Everything after this point will only run iff `upload==true` and\n  # `IsLinux() == true`\n  assert (upload)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser()\n  parser.add_argument(\n      '--cipd-dry-run',\n      default=False,\n      action='store_true',\n      help='If set, creates the CIPD package but does not upload it.'\n  )\n  parser.add_argument(\n      '--upload',",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "documentation": {}
    },
    {
        "label": "_script_dir",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "peekOfCode": "_script_dir = os.path.abspath(os.path.join(os.path.realpath(__file__), '..'))\n_src_root_dir = os.path.join(_script_dir, '..', '..', '..')\n_out_dir = os.path.join(_src_root_dir, 'out', 'ci')\n_bucket_directory = os.path.join(_out_dir, 'fuchsia_bucket')\ndef EnsureParentExists(path):\n  dir_name, _ = os.path.split(path)\n  if not os.path.exists(dir_name):\n    os.makedirs(dir_name)\ndef CopyPath(src, dst):\n  try:",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "documentation": {}
    },
    {
        "label": "_src_root_dir",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "peekOfCode": "_src_root_dir = os.path.join(_script_dir, '..', '..', '..')\n_out_dir = os.path.join(_src_root_dir, 'out', 'ci')\n_bucket_directory = os.path.join(_out_dir, 'fuchsia_bucket')\ndef EnsureParentExists(path):\n  dir_name, _ = os.path.split(path)\n  if not os.path.exists(dir_name):\n    os.makedirs(dir_name)\ndef CopyPath(src, dst):\n  try:\n    EnsureParentExists(dst)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "documentation": {}
    },
    {
        "label": "_out_dir",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "peekOfCode": "_out_dir = os.path.join(_src_root_dir, 'out', 'ci')\n_bucket_directory = os.path.join(_out_dir, 'fuchsia_bucket')\ndef EnsureParentExists(path):\n  dir_name, _ = os.path.split(path)\n  if not os.path.exists(dir_name):\n    os.makedirs(dir_name)\ndef CopyPath(src, dst):\n  try:\n    EnsureParentExists(dst)\n    shutil.copytree(src, dst)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "documentation": {}
    },
    {
        "label": "_bucket_directory",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "peekOfCode": "_bucket_directory = os.path.join(_out_dir, 'fuchsia_bucket')\ndef EnsureParentExists(path):\n  dir_name, _ = os.path.split(path)\n  if not os.path.exists(dir_name):\n    os.makedirs(dir_name)\ndef CopyPath(src, dst):\n  try:\n    EnsureParentExists(dst)\n    shutil.copytree(src, dst)\n  except OSError as exc:",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts",
        "documentation": {}
    },
    {
        "label": "BuildFuchsiaArtifactsTest",
        "kind": 6,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts_test",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts_test",
        "peekOfCode": "class BuildFuchsiaArtifactsTest(unittest.TestCase):\n  def test_read_fuchsia_target_api_level(self):\n    self.assertGreater(int(build_fuchsia_artifacts.ReadTargetAPILevel()), 21)\nif __name__ == '__main__':\n  unittest.main()",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.build_fuchsia_artifacts_test",
        "documentation": {}
    },
    {
        "label": "HashFile",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.copy_debug_symbols",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.copy_debug_symbols",
        "peekOfCode": "def HashFile(filepath):\n  \"\"\"Calculates the hash of a file without reading it all in memory at once.\"\"\"\n  digest = hashlib.sha1()\n  with open(filepath, 'rb') as f:\n    while True:\n      chunk = f.read(1024 * 1024)\n      if not chunk:\n        break\n      digest.update(chunk)\n  return digest.hexdigest()",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.copy_debug_symbols",
        "documentation": {}
    },
    {
        "label": "Touch",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.copy_debug_symbols",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.copy_debug_symbols",
        "peekOfCode": "def Touch(fname):\n  with open(fname, 'a'):\n    os.utime(fname, None)\ndef GetBuildIdParts(exec_path, read_elf):\n  sha1_pattern = re.compile(r'[0-9a-fA-F\\-]+')\n  file_out = subprocess.check_output([read_elf, '-n', exec_path])\n  build_id_line = file_out.splitlines()[-1].split()\n  if (build_id_line[0] != b'Build' or build_id_line[1] != b'ID:' or\n      not sha1_pattern.match(str(build_id_line[-1])) or not len(build_id_line[-1]) > 2):\n    raise Exception(",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.copy_debug_symbols",
        "documentation": {}
    },
    {
        "label": "GetBuildIdParts",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.copy_debug_symbols",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.copy_debug_symbols",
        "peekOfCode": "def GetBuildIdParts(exec_path, read_elf):\n  sha1_pattern = re.compile(r'[0-9a-fA-F\\-]+')\n  file_out = subprocess.check_output([read_elf, '-n', exec_path])\n  build_id_line = file_out.splitlines()[-1].split()\n  if (build_id_line[0] != b'Build' or build_id_line[1] != b'ID:' or\n      not sha1_pattern.match(str(build_id_line[-1])) or not len(build_id_line[-1]) > 2):\n    raise Exception(\n        'Expected the last line of llvm-readelf to match \"Build ID <Hex String>\" Got: %s' % file_out\n    )\n  build_id = build_id_line[-1]",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.copy_debug_symbols",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.copy_debug_symbols",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.copy_debug_symbols",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser()\n  parser.add_argument(\n      '--executable-name',\n      dest='exec_name',\n      action='store',\n      required=True,\n      help='This is the name of the executable that we wish to layout debug symbols for.'\n  )\n  parser.add_argument(",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.copy_debug_symbols",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.depfile_path_to_relative",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.depfile_path_to_relative",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser(\n      description='Executes a command, then rewrites the depfile, converts all absolute paths to relative'\n  )\n  parser.add_argument('--depfile', help='Path to the depfile to rewrite', required=True)\n  parser.add_argument('command', nargs='+', help='Positional args for the command to run')\n  args = parser.parse_args()\n  retval = subprocess.call(args.command)\n  if retval != 0:\n    return retval",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.depfile_path_to_relative",
        "documentation": {}
    },
    {
        "label": "get_content_hash",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.get_content_hash",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.get_content_hash",
        "peekOfCode": "def get_content_hash():\n  ci_config_path = os.path.join(_src_root_dir, 'flutter', 'ci', 'builders', 'linux_fuchsia.json')\n  upload_content_hash = False\n  if os.path.exists(ci_config_path):\n    with open(ci_config_path, 'r') as f:\n      ci_config = json.load(f)\n      upload_content_hash = ci_config.get('luci_flags', {}).get('upload_content_hash', False)\n  if upload_content_hash:\n    script_path = os.path.join(\n        _src_root_dir, '..', '..', 'bin', 'internal', 'content_aware_hash.sh'",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.get_content_hash",
        "documentation": {}
    },
    {
        "label": "_script_dir",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.get_content_hash",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.get_content_hash",
        "peekOfCode": "_script_dir = os.path.abspath(os.path.join(os.path.realpath(__file__), '..'))\n_src_root_dir = os.path.join(_script_dir, '..', '..', '..')\ndef get_content_hash():\n  ci_config_path = os.path.join(_src_root_dir, 'flutter', 'ci', 'builders', 'linux_fuchsia.json')\n  upload_content_hash = False\n  if os.path.exists(ci_config_path):\n    with open(ci_config_path, 'r') as f:\n      ci_config = json.load(f)\n      upload_content_hash = ci_config.get('luci_flags', {}).get('upload_content_hash', False)\n  if upload_content_hash:",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.get_content_hash",
        "documentation": {}
    },
    {
        "label": "_src_root_dir",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.get_content_hash",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.get_content_hash",
        "peekOfCode": "_src_root_dir = os.path.join(_script_dir, '..', '..', '..')\ndef get_content_hash():\n  ci_config_path = os.path.join(_src_root_dir, 'flutter', 'ci', 'builders', 'linux_fuchsia.json')\n  upload_content_hash = False\n  if os.path.exists(ci_config_path):\n    with open(ci_config_path, 'r') as f:\n      ci_config = json.load(f)\n      upload_content_hash = ci_config.get('luci_flags', {}).get('upload_content_hash', False)\n  if upload_content_hash:\n    script_path = os.path.join(",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.get_content_hash",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.interpolate_test_suite",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.interpolate_test_suite",
        "peekOfCode": "def main():\n  # Parse arguments.\n  parser = ArgumentParser()\n  parser.add_argument('--input', action='store', required=True)\n  parser.add_argument('--test-suite', action='store', required=True)\n  parser.add_argument('--output', action='store', required=True)\n  args = parser.parse_args()\n  # Read, interpolate, write.\n  with open(args.input, 'r') as i, open(args.output, 'w') as o:\n    o.write(i.read().replace('{{TEST_SUITE}}', args.test_suite))",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.interpolate_test_suite",
        "documentation": {}
    },
    {
        "label": "GetDartPath",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.make_build_info",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.make_build_info",
        "peekOfCode": "def GetDartPath(buildroot):\n  dart_path = path.join(buildroot, 'flutter', 'third_party', 'dart')\n  if not path.exists(dart_path):\n    dart_path = path.join(buildroot, 'third_party', 'dart')\n  return dart_path\ndef GetDartSdkGitRevision(buildroot):\n  return subprocess.check_output(['git', '-C', GetDartPath(buildroot), 'rev-parse', 'HEAD']).strip()\ndef GetDartSdkSemanticVersion(buildroot):\n  project_root = path.join(buildroot, 'third_party', 'dart')\n  return subprocess.check_output(['git', '-C',",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.make_build_info",
        "documentation": {}
    },
    {
        "label": "GetDartSdkGitRevision",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.make_build_info",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.make_build_info",
        "peekOfCode": "def GetDartSdkGitRevision(buildroot):\n  return subprocess.check_output(['git', '-C', GetDartPath(buildroot), 'rev-parse', 'HEAD']).strip()\ndef GetDartSdkSemanticVersion(buildroot):\n  project_root = path.join(buildroot, 'third_party', 'dart')\n  return subprocess.check_output(['git', '-C',\n                                  GetDartPath(buildroot), 'describe', '--abbrev=0']).strip()\ndef GetFlutterEngineGitRevision(buildroot):\n  project_root = path.join(buildroot, 'flutter')\n  return subprocess.check_output(['git', '-C', project_root, 'rev-parse', 'HEAD']).strip()\ndef GetFuchsiaSdkVersion(buildroot):",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.make_build_info",
        "documentation": {}
    },
    {
        "label": "GetDartSdkSemanticVersion",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.make_build_info",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.make_build_info",
        "peekOfCode": "def GetDartSdkSemanticVersion(buildroot):\n  project_root = path.join(buildroot, 'third_party', 'dart')\n  return subprocess.check_output(['git', '-C',\n                                  GetDartPath(buildroot), 'describe', '--abbrev=0']).strip()\ndef GetFlutterEngineGitRevision(buildroot):\n  project_root = path.join(buildroot, 'flutter')\n  return subprocess.check_output(['git', '-C', project_root, 'rev-parse', 'HEAD']).strip()\ndef GetFuchsiaSdkVersion(buildroot):\n  with open(path.join(buildroot, 'fuchsia', 'sdk',\n                      'linux' if sys.platform.startswith('linux') else 'mac', 'meta',",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.make_build_info",
        "documentation": {}
    },
    {
        "label": "GetFlutterEngineGitRevision",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.make_build_info",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.make_build_info",
        "peekOfCode": "def GetFlutterEngineGitRevision(buildroot):\n  project_root = path.join(buildroot, 'flutter')\n  return subprocess.check_output(['git', '-C', project_root, 'rev-parse', 'HEAD']).strip()\ndef GetFuchsiaSdkVersion(buildroot):\n  with open(path.join(buildroot, 'fuchsia', 'sdk',\n                      'linux' if sys.platform.startswith('linux') else 'mac', 'meta',\n                      'manifest.json'), 'r') as fuchsia_sdk_manifest:\n    return json.load(fuchsia_sdk_manifest)['id']\ndef main():\n  # Parse arguments.",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.make_build_info",
        "documentation": {}
    },
    {
        "label": "GetFuchsiaSdkVersion",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.make_build_info",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.make_build_info",
        "peekOfCode": "def GetFuchsiaSdkVersion(buildroot):\n  with open(path.join(buildroot, 'fuchsia', 'sdk',\n                      'linux' if sys.platform.startswith('linux') else 'mac', 'meta',\n                      'manifest.json'), 'r') as fuchsia_sdk_manifest:\n    return json.load(fuchsia_sdk_manifest)['id']\ndef main():\n  # Parse arguments.\n  parser = ArgumentParser()\n  parser.add_argument('--input', action='store', help='input file path', required=True)\n  parser.add_argument('--output', action='store', help='output file path', required=True)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.make_build_info",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.make_build_info",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.make_build_info",
        "peekOfCode": "def main():\n  # Parse arguments.\n  parser = ArgumentParser()\n  parser.add_argument('--input', action='store', help='input file path', required=True)\n  parser.add_argument('--output', action='store', help='output file path', required=True)\n  parser.add_argument(\n      '--buildroot', action='store', help='path to the flutter engine buildroot', required=True\n  )\n  parser.add_argument(\n      '--engine-version', action='store', help='Flutter engine commit hash', required=True",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.make_build_info",
        "documentation": {}
    },
    {
        "label": "IsLinux",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "peekOfCode": "def IsLinux():\n  return platform.system() == 'Linux'\n# out_dir here is of the format \"/b/s/w/ir/k/recipe_cleanup/tmpIbWDdp\"\n# we need to place the cipd definition in this directory.\ndef GetPackagingDir(out_dir):\n  return os.path.abspath(out_dir)\ndef CreateCIPDDefinition(target_arch, out_dir, symbol_dirs):\n  dir_name = os.path.basename(os.path.normpath(out_dir))\n  pkg_def = \"\"\"\npackage: flutter/fuchsia-debug-symbols-%s",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "documentation": {}
    },
    {
        "label": "GetPackagingDir",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "peekOfCode": "def GetPackagingDir(out_dir):\n  return os.path.abspath(out_dir)\ndef CreateCIPDDefinition(target_arch, out_dir, symbol_dirs):\n  dir_name = os.path.basename(os.path.normpath(out_dir))\n  pkg_def = \"\"\"\npackage: flutter/fuchsia-debug-symbols-%s\ndescription: Flutter and Dart runner debug symbols for Fuchsia. Target architecture %s.\ninstall_mode: copy\ndata:\n\"\"\" % (target_arch, target_arch)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "documentation": {}
    },
    {
        "label": "CreateCIPDDefinition",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "peekOfCode": "def CreateCIPDDefinition(target_arch, out_dir, symbol_dirs):\n  dir_name = os.path.basename(os.path.normpath(out_dir))\n  pkg_def = \"\"\"\npackage: flutter/fuchsia-debug-symbols-%s\ndescription: Flutter and Dart runner debug symbols for Fuchsia. Target architecture %s.\ninstall_mode: copy\ndata:\n\"\"\" % (target_arch, target_arch)\n  for symbol_dir in symbol_dirs:\n    symbol_dir_name = os.path.basename(os.path.normpath(symbol_dir))",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "documentation": {}
    },
    {
        "label": "WriteCIPDDefinition",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "peekOfCode": "def WriteCIPDDefinition(target_arch, out_dir, symbol_dirs):\n  _packaging_dir = GetPackagingDir(out_dir)\n  yaml_file = os.path.join(_packaging_dir, 'debug_symbols.cipd.yaml')\n  with open(yaml_file, 'w') as f:\n    cipd_def = CreateCIPDDefinition(target_arch, out_dir, symbol_dirs)\n    f.write(cipd_def)\n  return yaml_file\ndef CheckCIPDPackageExists(package_name, tag):\n  '''Check to see if the current package/tag combo has been published'''\n  command = [",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "documentation": {}
    },
    {
        "label": "CheckCIPDPackageExists",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "peekOfCode": "def CheckCIPDPackageExists(package_name, tag):\n  '''Check to see if the current package/tag combo has been published'''\n  command = [\n      'cipd',\n      'search',\n      package_name,\n      '-tag',\n      tag,\n  ]\n  stdout = subprocess.check_output(command)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "documentation": {}
    },
    {
        "label": "ProcessCIPDPackage",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "peekOfCode": "def ProcessCIPDPackage(upload, cipd_yaml, engine_version, content_hash, out_dir, target_arch):\n  _packaging_dir = GetPackagingDir(out_dir)\n  package_name = 'flutter/fuchsia-debug-symbols-%s' % target_arch\n  git_tag = 'git_revision:%s' % engine_version\n  already_exists = CheckCIPDPackageExists(package_name, git_tag)\n  if already_exists:\n    print('CIPD package %s tag %s already exists!' % (package_name, git_tag))\n  content_tag = ''\n  if content_hash:\n    content_tag = 'content_aware_hash:%s' % content_hash",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "documentation": {}
    },
    {
        "label": "HardlinkContents",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "peekOfCode": "def HardlinkContents(dirA, dirB):\n  internal_symbol_dirs = []\n  for src_dir, _, filenames in os.walk(dirA):\n    for filename in filenames:\n      # if a file contains 'dbg_success' in its name, it is a stamp file.\n      # An example of this would be\n      # '._dart_jit_runner_dbg_symbols_unstripped_dbg_success' these\n      # are generated by GN and have to be ignored.\n      if 'dbg_success' in filename:\n        continue",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "documentation": {}
    },
    {
        "label": "CalculateAbsoluteDirs",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "peekOfCode": "def CalculateAbsoluteDirs(dirs):\n  results = []\n  for directory in dirs:\n    if os.path.isabs(directory):\n      results.append(directory)\n    else:\n      results.append(os.path.join(BUILD_ROOT_DIR, directory))\n  return results\ndef main():\n  parser = argparse.ArgumentParser()",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser()\n  parser.add_argument(\n      '--symbol-dirs',\n      required=True,\n      nargs='+',\n      help='Space separated list of directories that contain the debug symbols.'\n  )\n  parser.add_argument(\n      '--out-dir',",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "documentation": {}
    },
    {
        "label": "BUILD_ROOT_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "peekOfCode": "BUILD_ROOT_DIR = os.path.abspath(os.path.join(os.path.realpath(__file__), '..', '..', '..', '..'))\ndef IsLinux():\n  return platform.system() == 'Linux'\n# out_dir here is of the format \"/b/s/w/ir/k/recipe_cleanup/tmpIbWDdp\"\n# we need to place the cipd definition in this directory.\ndef GetPackagingDir(out_dir):\n  return os.path.abspath(out_dir)\ndef CreateCIPDDefinition(target_arch, out_dir, symbol_dirs):\n  dir_name = os.path.basename(os.path.normpath(out_dir))\n  pkg_def = \"\"\"",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.merge_and_upload_debug_symbols",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.parse_manifest",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.parse_manifest",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser()\n  parser.add_argument('--input', dest='file_path', action='store', required=True)\n  parser.add_argument('--clang-cpu', dest='clang_cpu', action='store', required=True)\n  args = parser.parse_args()\n  with open(args.file_path) as f:\n    data = json.load(f)\n  output = {}\n  target = args.clang_cpu + '-fuchsia'\n  for d in data:",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.parse_manifest",
        "documentation": {}
    },
    {
        "label": "remote_filename",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.upload_to_symbol_server",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.upload_to_symbol_server",
        "peekOfCode": "def remote_filename(exec_path):\n  # An example of exec_path is:\n  # out/fuchsia_debug_x64/flutter-fuchsia-x64/d4/917f5976.debug\n  # In the above example \"d4917f5976\" is the elf BuildID for the\n  # executable. First 2 characters are used as the directory name\n  # and the rest of the string is the name of the unstripped executable.\n  parts = exec_path.split('/')\n  # We want d4917f5976.debug as the result.\n  return ''.join(parts[-2:])\ndef exists_remotely(remote_path):",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.upload_to_symbol_server",
        "documentation": {}
    },
    {
        "label": "exists_remotely",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.upload_to_symbol_server",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.upload_to_symbol_server",
        "peekOfCode": "def exists_remotely(remote_path):\n  gsutil = os.path.join(os.environ['DEPOT_TOOLS'], 'gsutil.py')\n  command = ['python3', gsutil, '--', 'stat', remote_path]\n  process = subprocess.Popen(command, stderr=subprocess.PIPE, stdout=subprocess.PIPE)\n  stdout, stderr = process.communicate()\n  return_code = process.wait()\n  if return_code == 0:\n    print('%s exists - skipping copy' % remote_path)\n  return return_code == 0\ndef process_symbols(should_upload, symbol_dir):",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.upload_to_symbol_server",
        "documentation": {}
    },
    {
        "label": "process_symbols",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.upload_to_symbol_server",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.upload_to_symbol_server",
        "peekOfCode": "def process_symbols(should_upload, symbol_dir):\n  full_path = os.path.join(BUILD_ROOT_DIR, symbol_dir)\n  files = []\n  for (dirpath, dirnames, filenames) in os.walk(full_path):\n    files.extend([os.path.join(dirpath, f) for f in filenames])\n  print('List of files to upload')\n  print('\\n'.join(files))\n  # Remove dbg_files\n  files = [f for f in files if 'dbg_success' not in f]\n  for file in files:",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.upload_to_symbol_server",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.upload_to_symbol_server",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.upload_to_symbol_server",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser()\n  parser.add_argument(\n      '--symbol-dir', required=True, help='Directory that contain the debug symbols.'\n  )\n  parser.add_argument('--engine-version', required=True, help='Specifies the flutter engine SHA.')\n  parser.add_argument(\n      '--upload', default=False, action='store_true', help='If set, uploads symbols to the server.'\n  )\n  args = parser.parse_args()",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.upload_to_symbol_server",
        "documentation": {}
    },
    {
        "label": "BUILD_ROOT_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.upload_to_symbol_server",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.upload_to_symbol_server",
        "peekOfCode": "BUILD_ROOT_DIR = os.path.abspath(os.path.join(os.path.realpath(__file__), '..', '..', '..', '..'))\nFUCHSIA_ARTIFACTS_DEBUG_NAMESPACE = 'debug'\nFUCHSIA_ARTIFACTS_BUCKET_NAME = 'fuchsia-artifacts-release'\ndef remote_filename(exec_path):\n  # An example of exec_path is:\n  # out/fuchsia_debug_x64/flutter-fuchsia-x64/d4/917f5976.debug\n  # In the above example \"d4917f5976\" is the elf BuildID for the\n  # executable. First 2 characters are used as the directory name\n  # and the rest of the string is the name of the unstripped executable.\n  parts = exec_path.split('/')",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.upload_to_symbol_server",
        "documentation": {}
    },
    {
        "label": "FUCHSIA_ARTIFACTS_DEBUG_NAMESPACE",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.upload_to_symbol_server",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.upload_to_symbol_server",
        "peekOfCode": "FUCHSIA_ARTIFACTS_DEBUG_NAMESPACE = 'debug'\nFUCHSIA_ARTIFACTS_BUCKET_NAME = 'fuchsia-artifacts-release'\ndef remote_filename(exec_path):\n  # An example of exec_path is:\n  # out/fuchsia_debug_x64/flutter-fuchsia-x64/d4/917f5976.debug\n  # In the above example \"d4917f5976\" is the elf BuildID for the\n  # executable. First 2 characters are used as the directory name\n  # and the rest of the string is the name of the unstripped executable.\n  parts = exec_path.split('/')\n  # We want d4917f5976.debug as the result.",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.upload_to_symbol_server",
        "documentation": {}
    },
    {
        "label": "FUCHSIA_ARTIFACTS_BUCKET_NAME",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.upload_to_symbol_server",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.upload_to_symbol_server",
        "peekOfCode": "FUCHSIA_ARTIFACTS_BUCKET_NAME = 'fuchsia-artifacts-release'\ndef remote_filename(exec_path):\n  # An example of exec_path is:\n  # out/fuchsia_debug_x64/flutter-fuchsia-x64/d4/917f5976.debug\n  # In the above example \"d4917f5976\" is the elf BuildID for the\n  # executable. First 2 characters are used as the directory name\n  # and the rest of the string is the name of the unstripped executable.\n  parts = exec_path.split('/')\n  # We want d4917f5976.debug as the result.\n  return ''.join(parts[-2:])",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.upload_to_symbol_server",
        "documentation": {}
    },
    {
        "label": "Main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.with_envs",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.with_envs",
        "peekOfCode": "def Main():\n  \"\"\"\n    Executes the test-scripts with required environment variables. It acts like\n    /usr/bin/env, but provides some extra functionality to dynamically set up\n    the environment variables.\n  \"\"\"\n  # Ensures the signals can be correctly forwarded to the subprocesses.\n  catch_sigterm()\n  os.environ['SRC_ROOT'] = os.path.abspath(os.path.join(os.path.dirname(__file__), '../../../'))\n  # Flutter uses a different repo structure and fuchsia sdk is not in the",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.fuchsia.with_envs",
        "documentation": {}
    },
    {
        "label": "IsWindows",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.githooks.setup",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.githooks.setup",
        "peekOfCode": "def IsWindows():\n  os_id = sys.platform\n  return os_id.startswith('win32') or os_id.startswith('cygwin')\ndef Main(argv):\n  parser = argparse.ArgumentParser()\n  parser.add_argument('--unset', action=argparse.BooleanOptionalAction, default=False)\n  args = parser.parse_args()\n  git = 'git'\n  if IsWindows():\n    git = 'git.bat'",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.githooks.setup",
        "documentation": {}
    },
    {
        "label": "Main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.githooks.setup",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.githooks.setup",
        "peekOfCode": "def Main(argv):\n  parser = argparse.ArgumentParser()\n  parser.add_argument('--unset', action=argparse.BooleanOptionalAction, default=False)\n  args = parser.parse_args()\n  git = 'git'\n  if IsWindows():\n    git = 'git.bat'\n  command = [\n      git,\n      'config',",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.githooks.setup",
        "documentation": {}
    },
    {
        "label": "SRC_ROOT",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.githooks.setup",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.githooks.setup",
        "peekOfCode": "SRC_ROOT = os.path.dirname(\n    os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n)\nFLUTTER_DIR = os.path.join(SRC_ROOT, 'flutter')\ndef IsWindows():\n  os_id = sys.platform\n  return os_id.startswith('win32') or os_id.startswith('cygwin')\ndef Main(argv):\n  parser = argparse.ArgumentParser()\n  parser.add_argument('--unset', action=argparse.BooleanOptionalAction, default=False)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.githooks.setup",
        "documentation": {}
    },
    {
        "label": "FLUTTER_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.githooks.setup",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.githooks.setup",
        "peekOfCode": "FLUTTER_DIR = os.path.join(SRC_ROOT, 'flutter')\ndef IsWindows():\n  os_id = sys.platform\n  return os_id.startswith('win32') or os_id.startswith('cygwin')\ndef Main(argv):\n  parser = argparse.ArgumentParser()\n  parser.add_argument('--unset', action=argparse.BooleanOptionalAction, default=False)\n  args = parser.parse_args()\n  git = 'git'\n  if IsWindows():",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.githooks.setup",
        "documentation": {}
    },
    {
        "label": "JavadocBin",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.javadoc.gen_javadoc",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.javadoc.gen_javadoc",
        "peekOfCode": "def JavadocBin():\n  if sys.platform == 'darwin':\n    return os.path.join(\n        SCRIPT_DIR, '..', '..', 'third_party', 'java', 'openjdk', 'Contents', 'Home', 'bin',\n        'javadoc'\n    )\n  elif sys.platform.startswith(('cygwin', 'win')):\n    return os.path.join(\n        SCRIPT_DIR, '..', '..', 'third_party', 'java', 'openjdk', 'bin', 'javadoc.exe'\n    )",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.javadoc.gen_javadoc",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.javadoc.gen_javadoc",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.javadoc.gen_javadoc",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser(description='Runs javadoc on Flutter Android libraries')\n  parser.add_argument('--out-dir', type=str, required=True)\n  parser.add_argument('--android-source-root', type=str, default=ANDROID_SRC_ROOT)\n  parser.add_argument('--build-config-path', type=str)\n  parser.add_argument('--src-dir', type=str, default='.')\n  parser.add_argument('--quiet', default=False, action='store_true')\n  args = parser.parse_args()\n  if not os.path.exists(args.android_source_root):\n    print(",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.javadoc.gen_javadoc",
        "documentation": {}
    },
    {
        "label": "ANDROID_SRC_ROOT",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.javadoc.gen_javadoc",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.javadoc.gen_javadoc",
        "peekOfCode": "ANDROID_SRC_ROOT = 'flutter/shell/platform/android'\nSCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))\ndef JavadocBin():\n  if sys.platform == 'darwin':\n    return os.path.join(\n        SCRIPT_DIR, '..', '..', 'third_party', 'java', 'openjdk', 'Contents', 'Home', 'bin',\n        'javadoc'\n    )\n  elif sys.platform.startswith(('cygwin', 'win')):\n    return os.path.join(",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.javadoc.gen_javadoc",
        "documentation": {}
    },
    {
        "label": "SCRIPT_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.javadoc.gen_javadoc",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.javadoc.gen_javadoc",
        "peekOfCode": "SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))\ndef JavadocBin():\n  if sys.platform == 'darwin':\n    return os.path.join(\n        SCRIPT_DIR, '..', '..', 'third_party', 'java', 'openjdk', 'Contents', 'Home', 'bin',\n        'javadoc'\n    )\n  elif sys.platform.startswith(('cygwin', 'win')):\n    return os.path.join(\n        SCRIPT_DIR, '..', '..', 'third_party', 'java', 'openjdk', 'bin', 'javadoc.exe'",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.javadoc.gen_javadoc",
        "documentation": {}
    },
    {
        "label": "GetAllBuilders",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.luci.build",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.luci.build",
        "peekOfCode": "def GetAllBuilders():\n  curl_command = [\n      'curl',\n      'https://ci.chromium.org/p/flutter/g/engine/builders',\n  ]\n  curl_result = subprocess.run(\n      curl_command,\n      universal_newlines=True,\n      capture_output=True,\n  )",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.luci.build",
        "documentation": {}
    },
    {
        "label": "Main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.luci.build",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.luci.build",
        "peekOfCode": "def Main():\n  parser = argparse.ArgumentParser(description='Reruns Engine LUCI prod builds')\n  parser.add_argument(\n      '--force-upload',\n      action='store_true',\n      default=False,\n      help='Force artifact upload, overwriting existing artifacts.'\n  )\n  parser.add_argument('--all', action='store_true', default=False, help='Re-run all builds.')\n  parser.add_argument('--builder', type=str, help='The builer to rerun.')",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.luci.build",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.activate_emsdk",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.activate_emsdk",
        "peekOfCode": "def main():\n  try:\n    subprocess.check_call([sys.executable, EMSDK_PATH, 'install', EMSDK_VERSION],\n                          stdout=subprocess.DEVNULL)\n  except subprocess.CalledProcessError:\n    print('Failed to install emsdk')\n    return 1\n  try:\n    subprocess.check_call([sys.executable, EMSDK_PATH, 'activate', EMSDK_VERSION],\n                          stdout=subprocess.DEVNULL)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.activate_emsdk",
        "documentation": {}
    },
    {
        "label": "EMSDK_ROOT",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.activate_emsdk",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.activate_emsdk",
        "peekOfCode": "EMSDK_ROOT = os.path.abspath(os.path.join(__file__, '..', '..', 'prebuilts', 'emsdk'))\nEMSDK_PATH = os.path.join(EMSDK_ROOT, 'emsdk.py')\n# See lib/web_ui/README.md for instructions on updating the EMSDK version.\nEMSDK_VERSION = '3.1.70'\ndef main():\n  try:\n    subprocess.check_call([sys.executable, EMSDK_PATH, 'install', EMSDK_VERSION],\n                          stdout=subprocess.DEVNULL)\n  except subprocess.CalledProcessError:\n    print('Failed to install emsdk')",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.activate_emsdk",
        "documentation": {}
    },
    {
        "label": "EMSDK_PATH",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.activate_emsdk",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.activate_emsdk",
        "peekOfCode": "EMSDK_PATH = os.path.join(EMSDK_ROOT, 'emsdk.py')\n# See lib/web_ui/README.md for instructions on updating the EMSDK version.\nEMSDK_VERSION = '3.1.70'\ndef main():\n  try:\n    subprocess.check_call([sys.executable, EMSDK_PATH, 'install', EMSDK_VERSION],\n                          stdout=subprocess.DEVNULL)\n  except subprocess.CalledProcessError:\n    print('Failed to install emsdk')\n    return 1",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.activate_emsdk",
        "documentation": {}
    },
    {
        "label": "EMSDK_VERSION",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.activate_emsdk",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.activate_emsdk",
        "peekOfCode": "EMSDK_VERSION = '3.1.70'\ndef main():\n  try:\n    subprocess.check_call([sys.executable, EMSDK_PATH, 'install', EMSDK_VERSION],\n                          stdout=subprocess.DEVNULL)\n  except subprocess.CalledProcessError:\n    print('Failed to install emsdk')\n    return 1\n  try:\n    subprocess.check_call([sys.executable, EMSDK_PATH, 'activate', EMSDK_VERSION],",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.activate_emsdk",
        "documentation": {}
    },
    {
        "label": "CheckBadFiles",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.android_illegal_imports",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.android_illegal_imports",
        "peekOfCode": "def CheckBadFiles(bad_files, bad_class, good_class):\n  if bad_files:\n    print('')\n    print('Illegal import %s detected in the following files:' % bad_class)\n    for bad_file in bad_files:\n      print('  - ' + bad_file)\n    print('Use %s instead.' % good_class)\n    print('')\n    return True\n  return False",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.android_illegal_imports",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.android_illegal_imports",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.android_illegal_imports",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser(\n      description='Checks Flutter Android library for forbidden imports'\n  )\n  parser.add_argument('--stamp', type=str, required=True)\n  parser.add_argument('--files', type=str, required=True, nargs='+')\n  args = parser.parse_args()\n  open(args.stamp, 'a').close()\n  bad_log_files = []\n  bad_trace_files = []",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.android_illegal_imports",
        "documentation": {}
    },
    {
        "label": "ANDROID_LOG_CLASS",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.android_illegal_imports",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.android_illegal_imports",
        "peekOfCode": "ANDROID_LOG_CLASS = 'android.util.Log'\nFLUTTER_LOG_CLASS = 'io.flutter.Log'\nANDROIDX_TRACE_CLASS = 'androidx.tracing.Trace'\nANDROID_TRACE_CLASS = 'android.tracing.Trace'\nFLUTTER_TRACE_CLASS = 'io.flutter.util.TraceSection'\nANDROID_BUILD_VERSION_CODE_CLASS = 'VERSION_CODES'\ndef CheckBadFiles(bad_files, bad_class, good_class):\n  if bad_files:\n    print('')\n    print('Illegal import %s detected in the following files:' % bad_class)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.android_illegal_imports",
        "documentation": {}
    },
    {
        "label": "FLUTTER_LOG_CLASS",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.android_illegal_imports",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.android_illegal_imports",
        "peekOfCode": "FLUTTER_LOG_CLASS = 'io.flutter.Log'\nANDROIDX_TRACE_CLASS = 'androidx.tracing.Trace'\nANDROID_TRACE_CLASS = 'android.tracing.Trace'\nFLUTTER_TRACE_CLASS = 'io.flutter.util.TraceSection'\nANDROID_BUILD_VERSION_CODE_CLASS = 'VERSION_CODES'\ndef CheckBadFiles(bad_files, bad_class, good_class):\n  if bad_files:\n    print('')\n    print('Illegal import %s detected in the following files:' % bad_class)\n    for bad_file in bad_files:",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.android_illegal_imports",
        "documentation": {}
    },
    {
        "label": "ANDROIDX_TRACE_CLASS",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.android_illegal_imports",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.android_illegal_imports",
        "peekOfCode": "ANDROIDX_TRACE_CLASS = 'androidx.tracing.Trace'\nANDROID_TRACE_CLASS = 'android.tracing.Trace'\nFLUTTER_TRACE_CLASS = 'io.flutter.util.TraceSection'\nANDROID_BUILD_VERSION_CODE_CLASS = 'VERSION_CODES'\ndef CheckBadFiles(bad_files, bad_class, good_class):\n  if bad_files:\n    print('')\n    print('Illegal import %s detected in the following files:' % bad_class)\n    for bad_file in bad_files:\n      print('  - ' + bad_file)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.android_illegal_imports",
        "documentation": {}
    },
    {
        "label": "ANDROID_TRACE_CLASS",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.android_illegal_imports",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.android_illegal_imports",
        "peekOfCode": "ANDROID_TRACE_CLASS = 'android.tracing.Trace'\nFLUTTER_TRACE_CLASS = 'io.flutter.util.TraceSection'\nANDROID_BUILD_VERSION_CODE_CLASS = 'VERSION_CODES'\ndef CheckBadFiles(bad_files, bad_class, good_class):\n  if bad_files:\n    print('')\n    print('Illegal import %s detected in the following files:' % bad_class)\n    for bad_file in bad_files:\n      print('  - ' + bad_file)\n    print('Use %s instead.' % good_class)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.android_illegal_imports",
        "documentation": {}
    },
    {
        "label": "FLUTTER_TRACE_CLASS",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.android_illegal_imports",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.android_illegal_imports",
        "peekOfCode": "FLUTTER_TRACE_CLASS = 'io.flutter.util.TraceSection'\nANDROID_BUILD_VERSION_CODE_CLASS = 'VERSION_CODES'\ndef CheckBadFiles(bad_files, bad_class, good_class):\n  if bad_files:\n    print('')\n    print('Illegal import %s detected in the following files:' % bad_class)\n    for bad_file in bad_files:\n      print('  - ' + bad_file)\n    print('Use %s instead.' % good_class)\n    print('')",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.android_illegal_imports",
        "documentation": {}
    },
    {
        "label": "ANDROID_BUILD_VERSION_CODE_CLASS",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.android_illegal_imports",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.android_illegal_imports",
        "peekOfCode": "ANDROID_BUILD_VERSION_CODE_CLASS = 'VERSION_CODES'\ndef CheckBadFiles(bad_files, bad_class, good_class):\n  if bad_files:\n    print('')\n    print('Illegal import %s detected in the following files:' % bad_class)\n    for bad_file in bad_files:\n      print('  - ' + bad_file)\n    print('Use %s instead.' % good_class)\n    print('')\n    return True",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.android_illegal_imports",
        "documentation": {}
    },
    {
        "label": "GetDiaDll",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.dia_dll",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.dia_dll",
        "peekOfCode": "def GetDiaDll():\n  \"\"\"Get the location of msdia*.dll for the platform.\"\"\"\n  # Bump after VC updates.\n  DIA_DLL = {\n      '2013': 'msdia120.dll',\n      '2015': 'msdia140.dll',\n      '2017': 'msdia140.dll',\n      '2019': 'msdia140.dll',\n      '2022': 'msdia140.dll',\n  }",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.dia_dll",
        "documentation": {}
    },
    {
        "label": "CopyFile",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.dia_dll",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.dia_dll",
        "peekOfCode": "def CopyFile(src, dst):\n  \"\"\"Copy a file from src to dst.\"\"\"\n  print(\"Copying %s to %s\" % (str(src), str(dst)))\n  shutil.copy(src, dst)\ndef CopyDiaDllTo(target_dir):\n  # This script always wants to use the 64-bit msdia*.dll.\n  dia_dll = GetDiaDll()\n  CopyFile(dia_dll, target_dir)\ndef main():\n  CopyDiaDllTo(os.path.join(LLVM_BUILD_DIR, 'bin'))",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.dia_dll",
        "documentation": {}
    },
    {
        "label": "CopyDiaDllTo",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.dia_dll",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.dia_dll",
        "peekOfCode": "def CopyDiaDllTo(target_dir):\n  # This script always wants to use the 64-bit msdia*.dll.\n  dia_dll = GetDiaDll()\n  CopyFile(dia_dll, target_dir)\ndef main():\n  CopyDiaDllTo(os.path.join(LLVM_BUILD_DIR, 'bin'))\n  return 0\nif __name__ == '__main__':\n  sys.exit(main())",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.dia_dll",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.dia_dll",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.dia_dll",
        "peekOfCode": "def main():\n  CopyDiaDllTo(os.path.join(LLVM_BUILD_DIR, 'bin'))\n  return 0\nif __name__ == '__main__':\n  sys.exit(main())",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.dia_dll",
        "documentation": {}
    },
    {
        "label": "THIS_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.dia_dll",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.dia_dll",
        "peekOfCode": "THIS_DIR = os.path.abspath(os.path.dirname(__file__))\nLLVM_BUILD_DIR = os.path.abspath(os.path.join(THIS_DIR, '..', 'buildtools', 'windows-x64', 'clang'))\ndef GetDiaDll():\n  \"\"\"Get the location of msdia*.dll for the platform.\"\"\"\n  # Bump after VC updates.\n  DIA_DLL = {\n      '2013': 'msdia120.dll',\n      '2015': 'msdia140.dll',\n      '2017': 'msdia140.dll',\n      '2019': 'msdia140.dll',",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.dia_dll",
        "documentation": {}
    },
    {
        "label": "LLVM_BUILD_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.dia_dll",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.dia_dll",
        "peekOfCode": "LLVM_BUILD_DIR = os.path.abspath(os.path.join(THIS_DIR, '..', 'buildtools', 'windows-x64', 'clang'))\ndef GetDiaDll():\n  \"\"\"Get the location of msdia*.dll for the platform.\"\"\"\n  # Bump after VC updates.\n  DIA_DLL = {\n      '2013': 'msdia120.dll',\n      '2015': 'msdia140.dll',\n      '2017': 'msdia140.dll',\n      '2019': 'msdia140.dll',\n      '2022': 'msdia140.dll',",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.dia_dll",
        "documentation": {}
    },
    {
        "label": "eprint",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.download_fuchsia_sdk",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.download_fuchsia_sdk",
        "peekOfCode": "def eprint(*args, **kwargs):\n  print(*args, file=sys.stderr, **kwargs)\ndef FileNameForSdkPath(sdk_path):\n  return sdk_path.split('/')[-1]\ndef DownloadFuchsiaSDKFromGCS(sdk_path, verbose):\n  file = FileNameForSdkPath(sdk_path)\n  url = 'https://storage.googleapis.com/fuchsia-artifacts/{}'.format(sdk_path)\n  dest = os.path.join(FUCHSIA_SDK_DIR, file)\n  if verbose:\n    print('Fuchsia SDK url: \"%s\"' % url)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.download_fuchsia_sdk",
        "documentation": {}
    },
    {
        "label": "FileNameForSdkPath",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.download_fuchsia_sdk",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.download_fuchsia_sdk",
        "peekOfCode": "def FileNameForSdkPath(sdk_path):\n  return sdk_path.split('/')[-1]\ndef DownloadFuchsiaSDKFromGCS(sdk_path, verbose):\n  file = FileNameForSdkPath(sdk_path)\n  url = 'https://storage.googleapis.com/fuchsia-artifacts/{}'.format(sdk_path)\n  dest = os.path.join(FUCHSIA_SDK_DIR, file)\n  if verbose:\n    print('Fuchsia SDK url: \"%s\"' % url)\n    print('Fuchsia SDK destination path: \"%s\"' % dest)\n  if os.path.isfile(dest):",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.download_fuchsia_sdk",
        "documentation": {}
    },
    {
        "label": "DownloadFuchsiaSDKFromGCS",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.download_fuchsia_sdk",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.download_fuchsia_sdk",
        "peekOfCode": "def DownloadFuchsiaSDKFromGCS(sdk_path, verbose):\n  file = FileNameForSdkPath(sdk_path)\n  url = 'https://storage.googleapis.com/fuchsia-artifacts/{}'.format(sdk_path)\n  dest = os.path.join(FUCHSIA_SDK_DIR, file)\n  if verbose:\n    print('Fuchsia SDK url: \"%s\"' % url)\n    print('Fuchsia SDK destination path: \"%s\"' % dest)\n  if os.path.isfile(dest):\n    os.unlink(dest)\n  # Ensure destination folder exists.",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.download_fuchsia_sdk",
        "documentation": {}
    },
    {
        "label": "OnErrorRmTree",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.download_fuchsia_sdk",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.download_fuchsia_sdk",
        "peekOfCode": "def OnErrorRmTree(func, path, exc_info):\n  \"\"\"\n  Error handler for ``shutil.rmtree``.\n  If the error is due to an access error (read only file)\n  it attempts to add write permission and then retries.\n  If the error is for another reason it re-raises the error.\n  Usage : ``shutil.rmtree(path, onerror=onerror)``\n  \"\"\"\n  import stat\n  # Is the error an access error?",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.download_fuchsia_sdk",
        "documentation": {}
    },
    {
        "label": "ExtractGzipArchive",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.download_fuchsia_sdk",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.download_fuchsia_sdk",
        "peekOfCode": "def ExtractGzipArchive(archive, host_os, verbose):\n  sdk_dest = os.path.join(FUCHSIA_SDK_DIR, host_os)\n  if os.path.isdir(sdk_dest):\n    shutil.rmtree(sdk_dest, onerror=OnErrorRmTree)\n  extract_dest = os.path.join(FUCHSIA_SDK_DIR, 'temp')\n  if os.path.isdir(extract_dest):\n    shutil.rmtree(extract_dest, onerror=OnErrorRmTree)\n  os.makedirs(extract_dest, exist_ok=True)\n  if verbose:\n    print('Extracting \"%s\" to \"%s\"' % (archive, extract_dest))",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.download_fuchsia_sdk",
        "documentation": {}
    },
    {
        "label": "Main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.download_fuchsia_sdk",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.download_fuchsia_sdk",
        "peekOfCode": "def Main():\n  parser = argparse.ArgumentParser()\n  parser.add_argument(\n      '--fail-loudly',\n      action='store_true',\n      default=False,\n      help=\"Return an error code if a prebuilt couldn't be fetched and extracted\"\n  )\n  parser.add_argument(\n      '--verbose',",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.download_fuchsia_sdk",
        "documentation": {}
    },
    {
        "label": "SRC_ROOT",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.download_fuchsia_sdk",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.download_fuchsia_sdk",
        "peekOfCode": "SRC_ROOT = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\nFUCHSIA_SDK_DIR = os.path.join(SRC_ROOT, 'fuchsia', 'sdk')\nFLUTTER_DIR = os.path.join(SRC_ROOT, 'flutter')\n# Prints to stderr.\ndef eprint(*args, **kwargs):\n  print(*args, file=sys.stderr, **kwargs)\ndef FileNameForSdkPath(sdk_path):\n  return sdk_path.split('/')[-1]\ndef DownloadFuchsiaSDKFromGCS(sdk_path, verbose):\n  file = FileNameForSdkPath(sdk_path)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.download_fuchsia_sdk",
        "documentation": {}
    },
    {
        "label": "FUCHSIA_SDK_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.download_fuchsia_sdk",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.download_fuchsia_sdk",
        "peekOfCode": "FUCHSIA_SDK_DIR = os.path.join(SRC_ROOT, 'fuchsia', 'sdk')\nFLUTTER_DIR = os.path.join(SRC_ROOT, 'flutter')\n# Prints to stderr.\ndef eprint(*args, **kwargs):\n  print(*args, file=sys.stderr, **kwargs)\ndef FileNameForSdkPath(sdk_path):\n  return sdk_path.split('/')[-1]\ndef DownloadFuchsiaSDKFromGCS(sdk_path, verbose):\n  file = FileNameForSdkPath(sdk_path)\n  url = 'https://storage.googleapis.com/fuchsia-artifacts/{}'.format(sdk_path)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.download_fuchsia_sdk",
        "documentation": {}
    },
    {
        "label": "FLUTTER_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.download_fuchsia_sdk",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.download_fuchsia_sdk",
        "peekOfCode": "FLUTTER_DIR = os.path.join(SRC_ROOT, 'flutter')\n# Prints to stderr.\ndef eprint(*args, **kwargs):\n  print(*args, file=sys.stderr, **kwargs)\ndef FileNameForSdkPath(sdk_path):\n  return sdk_path.split('/')[-1]\ndef DownloadFuchsiaSDKFromGCS(sdk_path, verbose):\n  file = FileNameForSdkPath(sdk_path)\n  url = 'https://storage.googleapis.com/fuchsia-artifacts/{}'.format(sdk_path)\n  dest = os.path.join(FUCHSIA_SDK_DIR, file)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.download_fuchsia_sdk",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_android_buildconfig",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_android_buildconfig",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser(description='Generate BuildConfig.java for Android')\n  parser.add_argument('--runtime-mode', type=str, required=True)\n  parser.add_argument('--out', type=str, required=True)\n  args = parser.parse_args()\n  jit_release = 'jit_release' in args.runtime_mode.lower()\n  release = not jit_release and 'release' in args.runtime_mode.lower()\n  profile = 'profile' in args.runtime_mode.lower()\n  debug = 'debug' in args.runtime_mode.lower()\n  assert debug or profile or release or jit_release",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_android_buildconfig",
        "documentation": {}
    },
    {
        "label": "BUILD_CONFIG_TEMPLATE",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_android_buildconfig",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_android_buildconfig",
        "peekOfCode": "BUILD_CONFIG_TEMPLATE = \"\"\"\n// Copyright 2013 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n// THIS FILE IS AUTO_GENERATED\n// DO NOT EDIT THE VALUES HERE - SEE $flutter_root/tools/gen_android_buildconfig.py\npackage io.flutter;\npublic final class BuildConfig {{\n  private BuildConfig() {{}}\n  public final static boolean DEBUG = {0};",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_android_buildconfig",
        "documentation": {}
    },
    {
        "label": "generate_doxyfile",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_docs",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_docs",
        "peekOfCode": "def generate_doxyfile(section, output_dir, log_file, doxy_file):\n  doxyfile = open('docs/Doxyfile.template', 'r').read()\n  doxyfile = doxyfile.replace('@@OUTPUT_DIRECTORY@@', output_dir)\n  doxyfile = doxyfile.replace('@@LOG_FILE@@', log_file)\n  doxyfile = doxyfile.replace('@@INPUT_DIRECTORIES@@', '\"{}\"'.format('\" \"'.join(section.inputs)))\n  doxyfile = doxyfile.replace('@@PROJECT_NAME@@', 'Flutter {}'.format(section.title))\n  doxyfile = doxyfile.replace(\n      '@@DOCSET_FEEDNAME@@', 'Flutter {} Documentation'.format(section.title)\n  )\n  with open(doxy_file, 'w') as f:",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_docs",
        "documentation": {}
    },
    {
        "label": "process_section",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_docs",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_docs",
        "peekOfCode": "def process_section(name, section, destination):\n  output_dir = tempfile.mkdtemp(prefix=\"doxygen\")\n  log_file = os.path.join(destination, '{}-doxygen.log'.format(name))\n  zip_file = os.path.join(destination, '{}-docs.zip'.format(name))\n  doxy_file = os.path.join(output_dir, 'Doxyfile')\n  generate_doxyfile(section, output_dir, log_file, doxy_file)\n  # Update the Doxyfile format to the latest format.\n  subprocess.call(['doxygen', '-u'], cwd=output_dir)\n  subprocess.call(['doxygen', doxy_file])\n  html_dir = os.path.join(output_dir, 'html')",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_docs",
        "documentation": {}
    },
    {
        "label": "generate_docs",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_docs",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_docs",
        "peekOfCode": "def generate_docs(argv):\n  if len(argv) != 2:\n    print(\n        'Error: Argument specifying output directory required. '\n        'Directory may be an absolute path, or a relative path from the \"src\" directory.'\n    )\n    exit(1)\n  destination = argv[1]\n  script_path = os.path.realpath(__file__)\n  src_path = os.path.dirname(os.path.dirname(os.path.dirname(script_path)))",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_docs",
        "documentation": {}
    },
    {
        "label": "Section",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_docs",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_docs",
        "peekOfCode": "Section = namedtuple('Section', ['title', 'inputs'])\nSECTIONS = {\n    'ios':\n        Section(\n            'iOS Embedder', [\n                'shell/platform/darwin/ios',\n                'shell/platform/darwin/common',\n                'shell/platform/common',\n            ]\n        ),",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_docs",
        "documentation": {}
    },
    {
        "label": "SECTIONS",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_docs",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_docs",
        "peekOfCode": "SECTIONS = {\n    'ios':\n        Section(\n            'iOS Embedder', [\n                'shell/platform/darwin/ios',\n                'shell/platform/darwin/common',\n                'shell/platform/common',\n            ]\n        ),\n    'macos':",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_docs",
        "documentation": {}
    },
    {
        "label": "glyph_program",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "def glyph_program(glyph):\n  # Shift Zone 1 by CVT[0]. In FreeType SHZ actually shifts the zone zp2\n  # points to, instead of top of the stack. That's probably a bug.\n  instructions = \"\"\"\n        SVTCA[0]\n        PUSHB_4\n        0\n        0\n        0\n        0",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "square_glyph",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "def square_glyph(glyph):\n  pen = glyph.glyphPen()\n  # Counter Clockwise\n  pen.moveTo((0, DESCENT))\n  pen.lineTo((0, ASCENT))\n  pen.lineTo((EM, ASCENT))\n  pen.lineTo((EM, DESCENT))\n  pen.closePath()\n  glyph.ttinstrs = glyph_program(glyph)\ndef ascent_flushed_glyph(glyph):",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "ascent_flushed_glyph",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "def ascent_flushed_glyph(glyph):\n  pen = glyph.glyphPen()\n  pen.moveTo((0, DESCENT))\n  pen.lineTo((0, 0))\n  pen.lineTo((EM, 0))\n  pen.lineTo((EM, DESCENT))\n  pen.closePath()\n  glyph.ttinstrs = glyph_program(glyph)\ndef descent_flushed_glyph(glyph):\n  pen = glyph.glyphPen()",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "descent_flushed_glyph",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "def descent_flushed_glyph(glyph):\n  pen = glyph.glyphPen()\n  pen.moveTo((0, 0))\n  pen.lineTo((0, ASCENT))\n  pen.lineTo((EM, ASCENT))\n  pen.lineTo((EM, 0))\n  pen.closePath()\n  glyph.ttinstrs = glyph_program(glyph)\ndef not_def_glyph(glyph):\n  pen = glyph.glyphPen()",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "not_def_glyph",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "def not_def_glyph(glyph):\n  pen = glyph.glyphPen()\n  # Counter Clockwise for the outer contour.\n  pen.moveTo((EM // 8, 0))\n  pen.lineTo((EM // 8, ASCENT))\n  pen.lineTo((EM - EM // 8, ASCENT))\n  pen.lineTo((EM - EM // 8, 0))\n  pen.closePath()\n  # Clockwise, inner contour.\n  pen.moveTo((EM // 4, EM // 8))",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "unicode_range",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "def unicode_range(fromUnicode, throughUnicode):\n  return range(fromUnicode, throughUnicode + 1)\nsquare_codepoints = [\n    codepoint for l in [\n        unicode_range(0x21, 0x26),\n        unicode_range(0x28, 0x6F),\n        unicode_range(0x71, 0x7E),\n        unicode_range(0xA1, 0xC8),\n        unicode_range(0xCA, 0xFF),\n        [0x131],",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "create_glyph",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "def create_glyph(name, contour):\n  glyph = font.createChar(-1, name)\n  contour(glyph)\n  glyph.width = EM\n  return glyph\nif square_codepoints:\n  create_glyph(\"Square\", square_glyph).altuni = square_codepoints\ncreate_glyph(\"Ascent Flushed\", ascent_flushed_glyph).unicode = 0x70\ncreate_glyph(\"Descent Flushed\", descent_flushed_glyph).unicode = 0xC9\ncreate_glyph(\".notdef\", not_def_glyph).unicode = -1",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "create_no_path_glyph",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "def create_no_path_glyph(codepoint, advance_percentage):\n  name = \"Zero Advance\" if advance_percentage == 0 else (\n      \"Full Advance\" if advance_percentage == 1 else f\"1/{(int)(1/advance_percentage)} Advance\"\n  )\n  no_path_glyph = font.createChar(codepoint, name)\n  no_path_glyph.width = (int)(EM * advance_percentage)\n  return no_path_glyph\nfor (codepoint, advance_percentage) in no_path_codepoints:\n  if (codepoint in square_codepoints):\n    raise ValueError(f\"{hex(codepoint)} is occupied.\")",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "NAME",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "NAME = \"FlutterTest\"\n# Turn off auto-hinting and enable manual hinting. FreeType skips auto-hinting\n# if the font's family name is in a hard-coded \"tricky\" font list.\nTRICKY_NAME = \"MingLiU\"\nEM = 1024\nDESCENT = -EM // 4\nASCENT = EM + DESCENT\n# -143 and 20 are the underline location and width Ahem uses.\nUPOS = -143 * 1000 // EM\nUWIDTH = 20 * 1000 // EM",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "TRICKY_NAME",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "TRICKY_NAME = \"MingLiU\"\nEM = 1024\nDESCENT = -EM // 4\nASCENT = EM + DESCENT\n# -143 and 20 are the underline location and width Ahem uses.\nUPOS = -143 * 1000 // EM\nUWIDTH = 20 * 1000 // EM\n### Font Metadata and Metrics\nfont = fontforge.font()\nfont.familyname = TRICKY_NAME",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "EM",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "EM = 1024\nDESCENT = -EM // 4\nASCENT = EM + DESCENT\n# -143 and 20 are the underline location and width Ahem uses.\nUPOS = -143 * 1000 // EM\nUWIDTH = 20 * 1000 // EM\n### Font Metadata and Metrics\nfont = fontforge.font()\nfont.familyname = TRICKY_NAME\nfont.fullname = NAME",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "DESCENT",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "DESCENT = -EM // 4\nASCENT = EM + DESCENT\n# -143 and 20 are the underline location and width Ahem uses.\nUPOS = -143 * 1000 // EM\nUWIDTH = 20 * 1000 // EM\n### Font Metadata and Metrics\nfont = fontforge.font()\nfont.familyname = TRICKY_NAME\nfont.fullname = NAME\nfont.fontname = NAME",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "ASCENT",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "ASCENT = EM + DESCENT\n# -143 and 20 are the underline location and width Ahem uses.\nUPOS = -143 * 1000 // EM\nUWIDTH = 20 * 1000 // EM\n### Font Metadata and Metrics\nfont = fontforge.font()\nfont.familyname = TRICKY_NAME\nfont.fullname = NAME\nfont.fontname = NAME\n# This sets the relevant fields in the os2 table and hhea table.",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "UPOS",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "UPOS = -143 * 1000 // EM\nUWIDTH = 20 * 1000 // EM\n### Font Metadata and Metrics\nfont = fontforge.font()\nfont.familyname = TRICKY_NAME\nfont.fullname = NAME\nfont.fontname = NAME\n# This sets the relevant fields in the os2 table and hhea table.\nfont.ascent = ASCENT\nfont.descent = -DESCENT",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "UWIDTH",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "UWIDTH = 20 * 1000 // EM\n### Font Metadata and Metrics\nfont = fontforge.font()\nfont.familyname = TRICKY_NAME\nfont.fullname = NAME\nfont.fontname = NAME\n# This sets the relevant fields in the os2 table and hhea table.\nfont.ascent = ASCENT\nfont.descent = -DESCENT\nfont.upos = UPOS",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "font",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "font = fontforge.font()\nfont.familyname = TRICKY_NAME\nfont.fullname = NAME\nfont.fontname = NAME\n# This sets the relevant fields in the os2 table and hhea table.\nfont.ascent = ASCENT\nfont.descent = -DESCENT\nfont.upos = UPOS\nfont.uwidth = UWIDTH\nfont.hhea_linegap = 0",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "font.familyname",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "font.familyname = TRICKY_NAME\nfont.fullname = NAME\nfont.fontname = NAME\n# This sets the relevant fields in the os2 table and hhea table.\nfont.ascent = ASCENT\nfont.descent = -DESCENT\nfont.upos = UPOS\nfont.uwidth = UWIDTH\nfont.hhea_linegap = 0\nfont.os2_typolinegap = 0",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "font.fullname",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "font.fullname = NAME\nfont.fontname = NAME\n# This sets the relevant fields in the os2 table and hhea table.\nfont.ascent = ASCENT\nfont.descent = -DESCENT\nfont.upos = UPOS\nfont.uwidth = UWIDTH\nfont.hhea_linegap = 0\nfont.os2_typolinegap = 0\nfont.horizontalBaseline = (",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "font.fontname",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "font.fontname = NAME\n# This sets the relevant fields in the os2 table and hhea table.\nfont.ascent = ASCENT\nfont.descent = -DESCENT\nfont.upos = UPOS\nfont.uwidth = UWIDTH\nfont.hhea_linegap = 0\nfont.os2_typolinegap = 0\nfont.horizontalBaseline = (\n    (\"hang\", \"ideo\", \"romn\"),",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "font.ascent",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "font.ascent = ASCENT\nfont.descent = -DESCENT\nfont.upos = UPOS\nfont.uwidth = UWIDTH\nfont.hhea_linegap = 0\nfont.os2_typolinegap = 0\nfont.horizontalBaseline = (\n    (\"hang\", \"ideo\", \"romn\"),\n    (\n        (\"latn\", \"romn\", (ASCENT, DESCENT, 0), ()),",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "font.descent",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "font.descent = -DESCENT\nfont.upos = UPOS\nfont.uwidth = UWIDTH\nfont.hhea_linegap = 0\nfont.os2_typolinegap = 0\nfont.horizontalBaseline = (\n    (\"hang\", \"ideo\", \"romn\"),\n    (\n        (\"latn\", \"romn\", (ASCENT, DESCENT, 0), ()),\n        (\"grek\", \"romn\", (ASCENT, DESCENT, 0), ()),",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "font.upos",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "font.upos = UPOS\nfont.uwidth = UWIDTH\nfont.hhea_linegap = 0\nfont.os2_typolinegap = 0\nfont.horizontalBaseline = (\n    (\"hang\", \"ideo\", \"romn\"),\n    (\n        (\"latn\", \"romn\", (ASCENT, DESCENT, 0), ()),\n        (\"grek\", \"romn\", (ASCENT, DESCENT, 0), ()),\n        (\"hani\", \"ideo\", (ASCENT, DESCENT, 0), ()),",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "font.uwidth",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "font.uwidth = UWIDTH\nfont.hhea_linegap = 0\nfont.os2_typolinegap = 0\nfont.horizontalBaseline = (\n    (\"hang\", \"ideo\", \"romn\"),\n    (\n        (\"latn\", \"romn\", (ASCENT, DESCENT, 0), ()),\n        (\"grek\", \"romn\", (ASCENT, DESCENT, 0), ()),\n        (\"hani\", \"ideo\", (ASCENT, DESCENT, 0), ()),\n    ),",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "font.hhea_linegap",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "font.hhea_linegap = 0\nfont.os2_typolinegap = 0\nfont.horizontalBaseline = (\n    (\"hang\", \"ideo\", \"romn\"),\n    (\n        (\"latn\", \"romn\", (ASCENT, DESCENT, 0), ()),\n        (\"grek\", \"romn\", (ASCENT, DESCENT, 0), ()),\n        (\"hani\", \"ideo\", (ASCENT, DESCENT, 0), ()),\n    ),\n)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "font.os2_typolinegap",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "font.os2_typolinegap = 0\nfont.horizontalBaseline = (\n    (\"hang\", \"ideo\", \"romn\"),\n    (\n        (\"latn\", \"romn\", (ASCENT, DESCENT, 0), ()),\n        (\"grek\", \"romn\", (ASCENT, DESCENT, 0), ()),\n        (\"hani\", \"ideo\", (ASCENT, DESCENT, 0), ()),\n    ),\n)\n### TrueType Hinting",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "font.horizontalBaseline",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "font.horizontalBaseline = (\n    (\"hang\", \"ideo\", \"romn\"),\n    (\n        (\"latn\", \"romn\", (ASCENT, DESCENT, 0), ()),\n        (\"grek\", \"romn\", (ASCENT, DESCENT, 0), ()),\n        (\"hani\", \"ideo\", (ASCENT, DESCENT, 0), ()),\n    ),\n)\n### TrueType Hinting\n# Hints are ignored on macOS.",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "font.cvt",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "font.cvt = [0]\n# gcd is used to avoid overflowing, this works for the current ASCENT and EM value.\ngcd = math.gcd(ASCENT, EM)\n# The control value program is for computing the y-offset (in pixels) to move\n# the embox's top edge to grid. The end result will be stored to CVT entry 0.\n# CVT[0] = (pointSize * ASCENT / EM) - ceil(pointSize * ASCENT / EM)\nprep_program = f\"\"\"\n    RTG\n    PUSHW_1\n    0",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "gcd",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "gcd = math.gcd(ASCENT, EM)\n# The control value program is for computing the y-offset (in pixels) to move\n# the embox's top edge to grid. The end result will be stored to CVT entry 0.\n# CVT[0] = (pointSize * ASCENT / EM) - ceil(pointSize * ASCENT / EM)\nprep_program = f\"\"\"\n    RTG\n    PUSHW_1\n    0\n    MPS\n    PUSHW_1",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "prep_program",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "prep_program = f\"\"\"\n    RTG\n    PUSHW_1\n    0\n    MPS\n    PUSHW_1\n    {(ASCENT << 6) // gcd}\n    MUL\n    PUSHW_1\n    {EM // gcd}",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "square_codepoints",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "square_codepoints = [\n    codepoint for l in [\n        unicode_range(0x21, 0x26),\n        unicode_range(0x28, 0x6F),\n        unicode_range(0x71, 0x7E),\n        unicode_range(0xA1, 0xC8),\n        unicode_range(0xCA, 0xFF),\n        [0x131],\n        unicode_range(0x152, 0x153),\n        [0x178, 0x192],",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "no_path_codepoints",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "no_path_codepoints = [\n    #(codepoint, advance %)\n    (0x0020, 1),\n    (0x00A0, 1),\n    (0x2003, 1),\n    (0x3000, 1),\n    (0x2002, 1 / 2),\n    (0x2004, 1 / 3),\n    (0x2005, 1 / 4),\n    (0x2006, 1 / 6),",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "scripts",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "scripts = set()\nfor glyph in font.glyphs():\n  if glyph.unicode >= 0:\n    scripts.add(fontforge.scriptFromUnicode(glyph.unicode))\n  for codepoint, _, _ in glyph.altuni or []:\n    scripts.add(fontforge.scriptFromUnicode(codepoint))\nscript_list = list(scripts)\nscript_list.sort()\nprint(f\"|     \\ Script <br />Glyph | {' | '.join(script_list)} |\")\nprint(\" | :--- \" + \" | :----: \" * len(script_list) + \"|\")",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "script_list",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "peekOfCode": "script_list = list(scripts)\nscript_list.sort()\nprint(f\"|     \\ Script <br />Glyph | {' | '.join(script_list)} |\")\nprint(\" | :--- \" + \" | :----: \" * len(script_list) + \"|\")\nfor glyph in font.glyphs():\n  if glyph.unicode < 0 and not glyph.altuni:\n    continue\n  glyph_mapping = {}\n  if glyph.unicode >= 0:\n    glyph_mapping[fontforge.scriptFromUnicode(glyph.unicode)] = [glyph.unicode]",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gen_test_font",
        "documentation": {}
    },
    {
        "label": "GNTestCase",
        "kind": 6,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gn_test",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gn_test",
        "peekOfCode": "class GNTestCase(unittest.TestCase):\n  def _expect_build_dir(self, arg_list, expected_build_dir):\n    args = gn.parse_args(['gn'] + arg_list)\n    self.assertEqual(gn.get_out_dir(args), expected_build_dir)\n  def test_get_out_dir(self):\n    self._expect_build_dir(['--runtime-mode', 'debug'], os.path.join('out', 'host_debug'))\n    self._expect_build_dir(['--runtime-mode', 'release'], os.path.join('out', 'host_release'))\n    self._expect_build_dir(['--ios'], os.path.join('out', 'ios_debug'))\n    self._expect_build_dir(['--ios', '--darwin-extension-safe'],\n                           os.path.join('out', 'ios_debug_extension_safe'))",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gn_test",
        "documentation": {}
    },
    {
        "label": "SKY_TOOLS",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gn_test",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gn_test",
        "peekOfCode": "SKY_TOOLS = os.path.dirname(os.path.abspath(__file__))\ngn = imp.load_source('gn', os.path.join(SKY_TOOLS, 'gn'))\nclass GNTestCase(unittest.TestCase):\n  def _expect_build_dir(self, arg_list, expected_build_dir):\n    args = gn.parse_args(['gn'] + arg_list)\n    self.assertEqual(gn.get_out_dir(args), expected_build_dir)\n  def test_get_out_dir(self):\n    self._expect_build_dir(['--runtime-mode', 'debug'], os.path.join('out', 'host_debug'))\n    self._expect_build_dir(['--runtime-mode', 'release'], os.path.join('out', 'host_release'))\n    self._expect_build_dir(['--ios'], os.path.join('out', 'ios_debug'))",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gn_test",
        "documentation": {}
    },
    {
        "label": "gn",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.gn_test",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.gn_test",
        "peekOfCode": "gn = imp.load_source('gn', os.path.join(SKY_TOOLS, 'gn'))\nclass GNTestCase(unittest.TestCase):\n  def _expect_build_dir(self, arg_list, expected_build_dir):\n    args = gn.parse_args(['gn'] + arg_list)\n    self.assertEqual(gn.get_out_dir(args), expected_build_dir)\n  def test_get_out_dir(self):\n    self._expect_build_dir(['--runtime-mode', 'debug'], os.path.join('out', 'host_debug'))\n    self._expect_build_dir(['--runtime-mode', 'release'], os.path.join('out', 'host_release'))\n    self._expect_build_dir(['--ios'], os.path.join('out', 'ios_debug'))\n    self._expect_build_dir(['--ios', '--darwin-extension-safe'],",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.gn_test",
        "documentation": {}
    },
    {
        "label": "fetch_package",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "peekOfCode": "def fetch_package(pub, package):\n  try:\n    subprocess.check_output(pub, cwd=package, stderr=subprocess.STDOUT)\n  except subprocess.CalledProcessError as err:\n    print(\n        '\"%s\" failed in \"%s\" with status %d:\\n%s' %\n        (' '.join(pub), package, err.returncode, err.output)\n    )\n    return 1\n  return 0",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "documentation": {}
    },
    {
        "label": "package_uses_workspace_resolution",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "peekOfCode": "def package_uses_workspace_resolution(package):\n  pubspec = os.path.join(package, 'pubspec.yaml')\n  with open(pubspec) as pubspec_file:\n    return yaml.safe_load(pubspec_file).get('resolution') == 'workspace'\ndef check_package_config(package):\n  package_config = os.path.join(package, '.dart_tool', 'package_config.json')\n  pub_count = 0\n  with open(package_config) as config_file:\n    data_dict = json.load(config_file)\n    packages_data = data_dict['packages']",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "documentation": {}
    },
    {
        "label": "check_package_config",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "peekOfCode": "def check_package_config(package):\n  package_config = os.path.join(package, '.dart_tool', 'package_config.json')\n  pub_count = 0\n  with open(package_config) as config_file:\n    data_dict = json.load(config_file)\n    packages_data = data_dict['packages']\n    for package_data in packages_data:\n      package_uri = package_data['rootUri']\n      package_name = package_data['name']\n      if '.pub-cache' in package_uri and ('pub.dartlang.org' in package_uri or",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "documentation": {}
    },
    {
        "label": "find_unlisted_packages",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "peekOfCode": "def find_unlisted_packages():\n  unlisted = []\n  for root, dirs, files in os.walk(ENGINE_DIR):\n    excluded = []\n    for dirname in dirs:\n      full_dirname = os.path.join(root, dirname)\n      if full_dirname in EXCLUDED_DIRS:\n        excluded.append(dirname)\n    for exclude in excluded:\n      dirs.remove(exclude)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "documentation": {}
    },
    {
        "label": "delete_config_files",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "peekOfCode": "def delete_config_files():\n  # Find all package_config.json that are not under version control.\n  gitcmd = ['git', 'ls-files', '-o', '**/.dart_tool/package_config.json']\n  files_to_delete = subprocess.check_output(\n      gitcmd, cwd=ENGINE_DIR, stderr=subprocess.STDOUT, text=True\n  ).splitlines()\n  for file in files_to_delete:\n    file_path = os.path.join(ENGINE_DIR, file)\n    if os.path.exists(file_path):\n      print('Deleting %s...' % file)",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "peekOfCode": "def main():\n  # Intentionally use the Dart SDK prebuilt instead of the Flutter prebuilt\n  # (i.e. prebuilts/{platform}/dart-sdk/bin/dart) because the script has to run\n  # in a monorepo build *before* the newer Dart SDK has been built from source.\n  dart_sdk_bin = os.path.join(\n      SRC_ROOT, 'flutter', 'third_party', 'dart', 'tools', 'sdks', 'dart-sdk', 'bin'\n  )\n  # Delete all package_config.json files. These may be stale.\n  # Required ones will be regenerated fresh below.\n  delete_config_files()",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "documentation": {}
    },
    {
        "label": "THIS_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "peekOfCode": "THIS_DIR = os.path.abspath(os.path.dirname(__file__))\nsys.path.insert(0, os.path.join(THIS_DIR, '..', 'third_party', 'pyyaml', 'lib'))\nimport yaml  # pylint: disable=import-error, wrong-import-position\nSRC_ROOT = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\nENGINE_DIR = os.path.join(SRC_ROOT, 'flutter')\nALL_PACKAGES = [\n    os.path.join(ENGINE_DIR),\n    os.path.join(ENGINE_DIR, 'ci'),\n    os.path.join(ENGINE_DIR, 'flutter_frontend_server'),\n    os.path.join(ENGINE_DIR, 'impeller', 'tessellator', 'dart'),",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "documentation": {}
    },
    {
        "label": "SRC_ROOT",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "peekOfCode": "SRC_ROOT = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\nENGINE_DIR = os.path.join(SRC_ROOT, 'flutter')\nALL_PACKAGES = [\n    os.path.join(ENGINE_DIR),\n    os.path.join(ENGINE_DIR, 'ci'),\n    os.path.join(ENGINE_DIR, 'flutter_frontend_server'),\n    os.path.join(ENGINE_DIR, 'impeller', 'tessellator', 'dart'),\n    os.path.join(ENGINE_DIR, 'shell', 'vmservice'),\n    os.path.join(ENGINE_DIR, 'testing', 'benchmark'),\n    os.path.join(ENGINE_DIR, 'testing', 'dart'),",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "documentation": {}
    },
    {
        "label": "ENGINE_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "peekOfCode": "ENGINE_DIR = os.path.join(SRC_ROOT, 'flutter')\nALL_PACKAGES = [\n    os.path.join(ENGINE_DIR),\n    os.path.join(ENGINE_DIR, 'ci'),\n    os.path.join(ENGINE_DIR, 'flutter_frontend_server'),\n    os.path.join(ENGINE_DIR, 'impeller', 'tessellator', 'dart'),\n    os.path.join(ENGINE_DIR, 'shell', 'vmservice'),\n    os.path.join(ENGINE_DIR, 'testing', 'benchmark'),\n    os.path.join(ENGINE_DIR, 'testing', 'dart'),\n    os.path.join(ENGINE_DIR, 'testing', 'ios_scenario_app'),",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "documentation": {}
    },
    {
        "label": "ALL_PACKAGES",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "peekOfCode": "ALL_PACKAGES = [\n    os.path.join(ENGINE_DIR),\n    os.path.join(ENGINE_DIR, 'ci'),\n    os.path.join(ENGINE_DIR, 'flutter_frontend_server'),\n    os.path.join(ENGINE_DIR, 'impeller', 'tessellator', 'dart'),\n    os.path.join(ENGINE_DIR, 'shell', 'vmservice'),\n    os.path.join(ENGINE_DIR, 'testing', 'benchmark'),\n    os.path.join(ENGINE_DIR, 'testing', 'dart'),\n    os.path.join(ENGINE_DIR, 'testing', 'ios_scenario_app'),\n    os.path.join(ENGINE_DIR, 'testing', 'skia_gold_client'),",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "documentation": {}
    },
    {
        "label": "EXCLUDED_DIRS",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "description": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "peekOfCode": "EXCLUDED_DIRS = [\n    os.path.join(ENGINE_DIR, 'lib'),\n    os.path.join(ENGINE_DIR, 'prebuilts'),\n    os.path.join(ENGINE_DIR, 'shell', 'platform', 'fuchsia'),\n    os.path.join(ENGINE_DIR, 'shell', 'vmservice'),\n    os.path.join(ENGINE_DIR, 'sky', 'packages'),\n    os.path.join(ENGINE_DIR, 'third_party'),\n    os.path.join(ENGINE_DIR, 'web_sdk'),\n]\n# Returns a list of paths to directories containing pubspec.yaml files that",
        "detail": ".fvm.flutter_sdk.engine.src.flutter.tools.pub_get_offline",
        "documentation": {}
    },
    {
        "label": "VarImpl",
        "kind": 6,
        "importPath": ".fvm.flutter_sdk.engine.src.tools.dart.create_updated_flutter_deps",
        "description": ".fvm.flutter_sdk.engine.src.tools.dart.create_updated_flutter_deps",
        "peekOfCode": "class VarImpl(object):\n  def __init__(self, local_scope):\n    self._local_scope = local_scope\n  def Lookup(self, var_name):\n    \"\"\"Implements the Var syntax.\"\"\"\n    if var_name in self._local_scope.get(\"vars\", {}):\n      return self._local_scope[\"vars\"][var_name]\n    if var_name == 'host_os':\n      return 'linux' # assume some default value\n    if var_name == 'host_cpu':",
        "detail": ".fvm.flutter_sdk.engine.src.tools.dart.create_updated_flutter_deps",
        "documentation": {}
    },
    {
        "label": "ParseDepsFile",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.tools.dart.create_updated_flutter_deps",
        "description": ".fvm.flutter_sdk.engine.src.tools.dart.create_updated_flutter_deps",
        "peekOfCode": "def ParseDepsFile(deps_file):\n  local_scope = {}\n  var = VarImpl(local_scope)\n  global_scope = {\n    'Var': var.Lookup,\n    'deps_os': {},\n  }\n  # Read the content.\n  with open(deps_file, 'r') as fp:\n    deps_content = fp.read()",
        "detail": ".fvm.flutter_sdk.engine.src.tools.dart.create_updated_flutter_deps",
        "documentation": {}
    },
    {
        "label": "ParseArgs",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.tools.dart.create_updated_flutter_deps",
        "description": ".fvm.flutter_sdk.engine.src.tools.dart.create_updated_flutter_deps",
        "peekOfCode": "def ParseArgs(args):\n  args = args[1:]\n  parser = argparse.ArgumentParser(\n      description='A script to generate updated dart dependencies for flutter DEPS.')\n  parser.add_argument('--dart_deps', '-d',\n      type=str,\n      help='Dart DEPS file.',\n      default=DART_DEPS)\n  parser.add_argument('--flutter_deps', '-f',\n      type=str,",
        "detail": ".fvm.flutter_sdk.engine.src.tools.dart.create_updated_flutter_deps",
        "documentation": {}
    },
    {
        "label": "Main",
        "kind": 2,
        "importPath": ".fvm.flutter_sdk.engine.src.tools.dart.create_updated_flutter_deps",
        "description": ".fvm.flutter_sdk.engine.src.tools.dart.create_updated_flutter_deps",
        "peekOfCode": "def Main(argv):\n  args = ParseArgs(argv)\n  if args.dart_deps == DART_DEPS and not os.path.isfile(DART_DEPS):\n    args.dart_deps = OLD_DART_DEPS\n  (new_vars, new_deps) = ParseDepsFile(args.dart_deps)\n  (old_vars, old_deps) = ParseDepsFile(args.flutter_deps)\n  updated_vars = {}\n  # Collect updated dependencies\n  for (k,v) in sorted(old_vars.items()):\n    if k not in ('dart_revision', 'dart_git') and k.startswith('dart_'):",
        "detail": ".fvm.flutter_sdk.engine.src.tools.dart.create_updated_flutter_deps",
        "documentation": {}
    },
    {
        "label": "DART_SCRIPT_DIR",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.tools.dart.create_updated_flutter_deps",
        "description": ".fvm.flutter_sdk.engine.src.tools.dart.create_updated_flutter_deps",
        "peekOfCode": "DART_SCRIPT_DIR = os.path.dirname(sys.argv[0])\nOLD_DART_DEPS = os.path.realpath(os.path.join(DART_SCRIPT_DIR, '../../third_party/dart/DEPS'))\nDART_DEPS = os.path.realpath(os.path.join(DART_SCRIPT_DIR, '../../flutter/third_party/dart/DEPS'))\nFLUTTER_DEPS = os.path.realpath(os.path.join(DART_SCRIPT_DIR, '../../../../DEPS'))\nclass VarImpl(object):\n  def __init__(self, local_scope):\n    self._local_scope = local_scope\n  def Lookup(self, var_name):\n    \"\"\"Implements the Var syntax.\"\"\"\n    if var_name in self._local_scope.get(\"vars\", {}):",
        "detail": ".fvm.flutter_sdk.engine.src.tools.dart.create_updated_flutter_deps",
        "documentation": {}
    },
    {
        "label": "OLD_DART_DEPS",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.tools.dart.create_updated_flutter_deps",
        "description": ".fvm.flutter_sdk.engine.src.tools.dart.create_updated_flutter_deps",
        "peekOfCode": "OLD_DART_DEPS = os.path.realpath(os.path.join(DART_SCRIPT_DIR, '../../third_party/dart/DEPS'))\nDART_DEPS = os.path.realpath(os.path.join(DART_SCRIPT_DIR, '../../flutter/third_party/dart/DEPS'))\nFLUTTER_DEPS = os.path.realpath(os.path.join(DART_SCRIPT_DIR, '../../../../DEPS'))\nclass VarImpl(object):\n  def __init__(self, local_scope):\n    self._local_scope = local_scope\n  def Lookup(self, var_name):\n    \"\"\"Implements the Var syntax.\"\"\"\n    if var_name in self._local_scope.get(\"vars\", {}):\n      return self._local_scope[\"vars\"][var_name]",
        "detail": ".fvm.flutter_sdk.engine.src.tools.dart.create_updated_flutter_deps",
        "documentation": {}
    },
    {
        "label": "DART_DEPS",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.tools.dart.create_updated_flutter_deps",
        "description": ".fvm.flutter_sdk.engine.src.tools.dart.create_updated_flutter_deps",
        "peekOfCode": "DART_DEPS = os.path.realpath(os.path.join(DART_SCRIPT_DIR, '../../flutter/third_party/dart/DEPS'))\nFLUTTER_DEPS = os.path.realpath(os.path.join(DART_SCRIPT_DIR, '../../../../DEPS'))\nclass VarImpl(object):\n  def __init__(self, local_scope):\n    self._local_scope = local_scope\n  def Lookup(self, var_name):\n    \"\"\"Implements the Var syntax.\"\"\"\n    if var_name in self._local_scope.get(\"vars\", {}):\n      return self._local_scope[\"vars\"][var_name]\n    if var_name == 'host_os':",
        "detail": ".fvm.flutter_sdk.engine.src.tools.dart.create_updated_flutter_deps",
        "documentation": {}
    },
    {
        "label": "FLUTTER_DEPS",
        "kind": 5,
        "importPath": ".fvm.flutter_sdk.engine.src.tools.dart.create_updated_flutter_deps",
        "description": ".fvm.flutter_sdk.engine.src.tools.dart.create_updated_flutter_deps",
        "peekOfCode": "FLUTTER_DEPS = os.path.realpath(os.path.join(DART_SCRIPT_DIR, '../../../../DEPS'))\nclass VarImpl(object):\n  def __init__(self, local_scope):\n    self._local_scope = local_scope\n  def Lookup(self, var_name):\n    \"\"\"Implements the Var syntax.\"\"\"\n    if var_name in self._local_scope.get(\"vars\", {}):\n      return self._local_scope[\"vars\"][var_name]\n    if var_name == 'host_os':\n      return 'linux' # assume some default value",
        "detail": ".fvm.flutter_sdk.engine.src.tools.dart.create_updated_flutter_deps",
        "documentation": {}
    }
]